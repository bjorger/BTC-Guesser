/**
 * This class allows to express wide range of cases in an expression.
 * You can use it with setups or verifies methods.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
 *  .returns(value)
 *  .setup(instance => instance(It.IsAny())
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 *
 * This class could be used not only for args matching, but also for function names, property names and so on.
 *
 * @example
 * ```typescript
 *
 * const object = new Mock<ITestObject>()
 * // the expression dynamically checks the property name that is being read
 * .setup(instance => It.Is((expression: ExpectedGetPropertyExpression) => expression.name === 'property'))
 * .returns(value)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * //denis any write operation on the property
 * .setup(instance => { instance.property = It.IsAny()})
 * // true - allow, false - deny
 * .returns(false)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * .setup(instance => It.Is((expression: ExpectedNamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
 * .returns(value)
 * .object();
 *
 * // how to use with verify
 * mock.verify(instance => instance.method(It.Is(a => a === 2)));
 * ```
 */
export class It {
    constructor(predicate) {
        this.predicate = predicate;
    }
    /**
     * This factory method returns an expression that matches custom cases.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static Is(predicate) {
        return new It(predicate);
    }
    /**
     * This factory method returns a wildcat expression that matches any value.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(any_value_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static IsAny() {
        return new It(() => true);
    }
    /**
     * @hidden
     */
    test(instance) {
        try {
            const result = this.predicate(instance);
            return result === true || result === undefined;
        }
        catch (e) {
            return false;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1wcmVkaWNhdGVzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL21vcS9zcmMvIiwic291cmNlcyI6WyJsaWIvZXhwZWN0ZWQtZXhwcmVzc2lvbnMvZXhwcmVzc2lvbi1wcmVkaWNhdGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnREc7QUFDSCxNQUFNLE9BQU8sRUFBRTtJQUNYLFlBQW1CLFNBQXdCO1FBQXhCLGNBQVMsR0FBVCxTQUFTLENBQWU7SUFFM0MsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBSSxTQUF3QjtRQUN4QyxPQUFPLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNJLE1BQU0sQ0FBQyxLQUFLO1FBQ2YsT0FBTyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxJQUFJLENBQUMsUUFBWTtRQUNwQixJQUFJO1lBQ0EsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN4QyxPQUFPLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxLQUFLLFNBQVMsQ0FBQztTQUNsRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsT0FBTyxLQUFLLENBQUM7U0FDaEI7SUFDTCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyIvKmVzbGludCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb246IFwib2ZmXCIqL1xuZXhwb3J0IHR5cGUgSVByZWRpY2F0ZTxUPiA9IChpbnN0YW5jZTogVCkgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGFsbG93cyB0byBleHByZXNzIHdpZGUgcmFuZ2Ugb2YgY2FzZXMgaW4gYW4gZXhwcmVzc2lvbi5cbiAqIFlvdSBjYW4gdXNlIGl0IHdpdGggc2V0dXBzIG9yIHZlcmlmaWVzIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiAgY29uc3QgdmFsdWUgPSAndmFsdWUnO1xuICogIGNvbnN0IG9iamVjdCA9IG5ldyBNb2NrPEZ1bmN0aW9uPigpXG4gKiAgLnNldHVwKGluc3RhbmNlID0+IGluc3RhbmNlKDEpKVxuICogIC5yZXR1cm5zKHZhbHVlKVxuICogIC5zZXR1cChpbnN0YW5jZSA9PiBpbnN0YW5jZShJdC5JcyhwYXJhbSA9PiBwYXJhbSA+IDAgJiYgcGFyYW0gPCAyKSlcbiAqICAucmV0dXJucyh2YWx1ZSlcbiAqICAuc2V0dXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UoSXQuSXNBbnkoKSlcbiAqICAucmV0dXJucyh2YWx1ZSlcbiAqICAub2JqZWN0KCk7XG4gKlxuICogIGNvbnN0IGFjdHVhbCA9IG9iamVjdCgxKTtcbiAqXG4gKiAgZXhwZWN0KGFjdHVhbCkudG9CZSh2YWx1ZSk7XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGNsYXNzIGNvdWxkIGJlIHVzZWQgbm90IG9ubHkgZm9yIGFyZ3MgbWF0Y2hpbmcsIGJ1dCBhbHNvIGZvciBmdW5jdGlvbiBuYW1lcywgcHJvcGVydHkgbmFtZXMgYW5kIHNvIG9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogY29uc3Qgb2JqZWN0ID0gbmV3IE1vY2s8SVRlc3RPYmplY3Q+KClcbiAqIC8vIHRoZSBleHByZXNzaW9uIGR5bmFtaWNhbGx5IGNoZWNrcyB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IGlzIGJlaW5nIHJlYWRcbiAqIC5zZXR1cChpbnN0YW5jZSA9PiBJdC5JcygoZXhwcmVzc2lvbjogRXhwZWN0ZWRHZXRQcm9wZXJ0eUV4cHJlc3Npb24pID0+IGV4cHJlc3Npb24ubmFtZSA9PT0gJ3Byb3BlcnR5JykpXG4gKiAucmV0dXJucyh2YWx1ZSlcbiAqIC5vYmplY3QoKTtcbiAqXG4gKiBjb25zdCBvYmplY3QgPSBuZXcgTW9jazxJVGVzdE9iamVjdD4oKVxuICogLy9kZW5pcyBhbnkgd3JpdGUgb3BlcmF0aW9uIG9uIHRoZSBwcm9wZXJ0eVxuICogLnNldHVwKGluc3RhbmNlID0+IHsgaW5zdGFuY2UucHJvcGVydHkgPSBJdC5Jc0FueSgpfSlcbiAqIC8vIHRydWUgLSBhbGxvdywgZmFsc2UgLSBkZW55XG4gKiAucmV0dXJucyhmYWxzZSlcbiAqIC5vYmplY3QoKTtcbiAqXG4gKiBjb25zdCBvYmplY3QgPSBuZXcgTW9jazxJVGVzdE9iamVjdD4oKVxuICogLnNldHVwKGluc3RhbmNlID0+IEl0LklzKChleHByZXNzaW9uOiBFeHBlY3RlZE5hbWVkTWV0aG9kRXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi5uYW1lID09PSAnbWV0aG9kTmFtZScgJiYgZXhwcmVzc2lvbi5hcmdzWzBdID09PSAxKSlcbiAqIC5yZXR1cm5zKHZhbHVlKVxuICogLm9iamVjdCgpO1xuICpcbiAqIC8vIGhvdyB0byB1c2Ugd2l0aCB2ZXJpZnlcbiAqIG1vY2sudmVyaWZ5KGluc3RhbmNlID0+IGluc3RhbmNlLm1ldGhvZChJdC5JcyhhID0+IGEgPT09IDIpKSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEl0PFA+IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcHJlZGljYXRlOiBJUHJlZGljYXRlPFA+KSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZhY3RvcnkgbWV0aG9kIHJldHVybnMgYW4gZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgY3VzdG9tIGNhc2VzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpcbiAgICAgKiAgY29uc3QgdmFsdWUgPSAndmFsdWUnO1xuICAgICAqICBjb25zdCBvYmplY3QgPSBuZXcgTW9jazxGdW5jdGlvbj4oKVxuICAgICAqICAuc2V0dXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UoSXQuSXMocGFyYW0gPT4gcGFyYW0gPiAwICYmIHBhcmFtIDwgMikpXG4gICAgICogIC5yZXR1cm5zKHZhbHVlKVxuICAgICAqICAub2JqZWN0KCk7XG4gICAgICpcbiAgICAgKiAgY29uc3QgYWN0dWFsID0gb2JqZWN0KG9ubHlfdmFsdWVzX2JldHdlZW5fMF9hbmRfMl93aWxsX3RyaWdnZXJfdGhlX3NldHVwKTtcbiAgICAgKlxuICAgICAqICBleHBlY3QoYWN0dWFsKS50b0JlKHZhbHVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIElzPFQ+KHByZWRpY2F0ZTogSVByZWRpY2F0ZTxUPik6IEl0PFQ+IHwgYW55IHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdChwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmFjdG9yeSBtZXRob2QgcmV0dXJucyBhIHdpbGRjYXQgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW55IHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpcbiAgICAgKiAgY29uc3QgdmFsdWUgPSAndmFsdWUnO1xuICAgICAqICBjb25zdCBvYmplY3QgPSBuZXcgTW9jazxGdW5jdGlvbj4oKVxuICAgICAqICAuc2V0dXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UoSXQuSXNBbnkoKSlcbiAgICAgKiAgLnJldHVybnModmFsdWUpXG4gICAgICogIC5vYmplY3QoKTtcbiAgICAgKlxuICAgICAqICBjb25zdCBhY3R1YWwgPSBvYmplY3QoYW55X3ZhbHVlX3dpbGxfdHJpZ2dlcl90aGVfc2V0dXApO1xuICAgICAqXG4gICAgICogIGV4cGVjdChhY3R1YWwpLnRvQmUodmFsdWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgSXNBbnk8VD4oKTogSXQ8VD4gfCBhbnkge1xuICAgICAgICByZXR1cm4gbmV3IEl0KCgpID0+IHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdGVzdChpbnN0YW5jZT86IFApOiBib29sZWFuIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWUgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==