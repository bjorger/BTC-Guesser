(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('moq.ts', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.moq = global.moq || {}, global.moq.ts = {})));
}(this, (function (exports) { 'use strict';

    /**
     * A mock object exposes a symbol property to access to its Moq API.
     * This property is read only and trackable.
     * Since this property makes sense only in context of the moq library
     * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.
     *
     * @example
     * ```typescript
     *
     *  const mock = new Mock<() => void>()
     *  .object();
     *
     *  mock[MoqAPI]
     *  .setup(instance => instance())
     *  .returns(12);
     *
     *  const actual = mock();
     *
     *  expect(actual).toBe(12);
     * ```
     */
    var MoqAPI = Symbol("MoqAPI");

    /**
     * This class allows to express wide range of cases in an expression.
     * You can use it with setups or verifies methods.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(1))
     *  .returns(value)
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(1);
     *
     *  expect(actual).toBe(value);
     * ```
     *
     * This class could be used not only for args matching, but also for function names, property names and so on.
     *
     * @example
     * ```typescript
     *
     * const object = new Mock<ITestObject>()
     * // the expression dynamically checks the property name that is being read
     * .setup(instance => It.Is((expression: ExpectedGetPropertyExpression) => expression.name === 'property'))
     * .returns(value)
     * .object();
     *
     * const object = new Mock<ITestObject>()
     * //denis any write operation on the property
     * .setup(instance => { instance.property = It.IsAny()})
     * // true - allow, false - deny
     * .returns(false)
     * .object();
     *
     * const object = new Mock<ITestObject>()
     * .setup(instance => It.Is((expression: ExpectedNamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
     * .returns(value)
     * .object();
     *
     * // how to use with verify
     * mock.verify(instance => instance.method(It.Is(a => a === 2)));
     * ```
     */
    var It = /** @class */ (function () {
        function It(predicate) {
            this.predicate = predicate;
        }
        /**
         * This factory method returns an expression that matches custom cases.
         *
         * @example
         * ```typescript
         *
         *  const value = 'value';
         *  const object = new Mock<Function>()
         *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
         *  .returns(value)
         *  .object();
         *
         *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
         *
         *  expect(actual).toBe(value);
         * ```
         */
        It.Is = function (predicate) {
            return new It(predicate);
        };
        /**
         * This factory method returns a wildcat expression that matches any value.
         *
         * @example
         * ```typescript
         *
         *  const value = 'value';
         *  const object = new Mock<Function>()
         *  .setup(instance => instance(It.IsAny())
         *  .returns(value)
         *  .object();
         *
         *  const actual = object(any_value_will_trigger_the_setup);
         *
         *  expect(actual).toBe(value);
         * ```
         */
        It.IsAny = function () {
            return new It(function () { return true; });
        };
        /**
         * @hidden
         */
        It.prototype.test = function (instance) {
            try {
                var result = this.predicate(instance);
                return result === true || result === undefined;
            }
            catch (e) {
                return false;
            }
        };
        return It;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /*eslint-disable max-classes-per-file*/
    var Interaction = /** @class */ (function () {
        function Interaction(name, args) {
            this.name = name;
            this.args = args;
        }
        return Interaction;
    }());
    /**
     * This class represents an invocation of a named function.
     * It provides access to the name of function and list of parameters.
     */
    var NamedMethodInteraction = /** @class */ (function (_super) {
        __extends(NamedMethodInteraction, _super);
        function NamedMethodInteraction(name, args) {
            return _super.call(this, name, args) || this;
        }
        return NamedMethodInteraction;
    }(Interaction));
    /**
     * This class represents an invocation of a function.
     * It provides access to the list of parameters.
     */
    var MethodInteraction = /** @class */ (function (_super) {
        __extends(MethodInteraction, _super);
        function MethodInteraction(args) {
            return _super.call(this, undefined, args) || this;
        }
        return MethodInteraction;
    }(Interaction));
    /**
     * This class represents a property accessing.
     * It provides access to the name of property.
     */
    var GetPropertyInteraction = /** @class */ (function (_super) {
        __extends(GetPropertyInteraction, _super);
        function GetPropertyInteraction(name) {
            return _super.call(this, name, undefined) || this;
        }
        return GetPropertyInteraction;
    }(Interaction));
    /**
     * This class represents a property write interaction.
     * It provides access to the name of property and the value.
     */
    var SetPropertyInteraction = /** @class */ (function (_super) {
        __extends(SetPropertyInteraction, _super);
        function SetPropertyInteraction(name, value) {
            var _this = _super.call(this, name, [value]) || this;
            _this.value = value;
            return _this;
        }
        return SetPropertyInteraction;
    }(Interaction));
    /**
     * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
     * It provides access to the name of property.
     */
    var InOperatorInteraction = /** @class */ (function (_super) {
        __extends(InOperatorInteraction, _super);
        function InOperatorInteraction(name) {
            return _super.call(this, name, undefined) || this;
        }
        return InOperatorInteraction;
    }(Interaction));

    // todo: check if could be renamed in expressions
    /**
     * See {@link NamedMethodInteraction}
     */
    var ExpectedNamedMethodExpression = /** @class */ (function (_super) {
        __extends(ExpectedNamedMethodExpression, _super);
        function ExpectedNamedMethodExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExpectedNamedMethodExpression;
    }(NamedMethodInteraction));
    /**
     * See {@link MethodInteraction}
     */
    var ExpectedMethodExpression = /** @class */ (function (_super) {
        __extends(ExpectedMethodExpression, _super);
        function ExpectedMethodExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExpectedMethodExpression;
    }(MethodInteraction));
    /**
     * See {@link GetPropertyInteraction}
     */
    var ExpectedGetPropertyExpression = /** @class */ (function (_super) {
        __extends(ExpectedGetPropertyExpression, _super);
        function ExpectedGetPropertyExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExpectedGetPropertyExpression;
    }(GetPropertyInteraction));
    /**
     * See {@link SetPropertyInteraction}
     */
    var ExpectedSetPropertyExpression = /** @class */ (function (_super) {
        __extends(ExpectedSetPropertyExpression, _super);
        function ExpectedSetPropertyExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExpectedSetPropertyExpression;
    }(SetPropertyInteraction));
    /**
     * See {@link InOperatorInteraction}
     */
    var ExpectedInOperatorExpression = /** @class */ (function (_super) {
        __extends(ExpectedInOperatorExpression, _super);
        function ExpectedInOperatorExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExpectedInOperatorExpression;
    }(InOperatorInteraction));

    /**
     * This class reflects an expression to an expression tree representation.
     *
     * @example
     * ```typescript
     *
     * const arg = 'argument';
     * const reflector = new ExpectedExpressionReflector();
     * const actual = reflector.reflect<any>(instance => instance(arg));
     *
     * const expected = new ExpectedMethodExpression([arg]);
     * expect(actual).toEqual(expected);
     * ```
     *
     * For more examples check
     * [unit tests for this class]
     * (https://github.com/dvabuzyarov/moq.ts/blob/master/tests.unit/expected-expressions/expected-expression-reflector.UnitTests.ts)
     */
    var ExpectedExpressionReflector = /** @class */ (function () {
        function ExpectedExpressionReflector() {
        }
        /**
         * Reflects the provided code as an expression tree.
         */
        ExpectedExpressionReflector.prototype.reflect = function (expression) {
            this.reflectedInfo = undefined;
            var proxy = this.expressionProxy();
            var predicate = expression(proxy);
            return predicate instanceof It && (this.reflectedInfo instanceof ExpectedSetPropertyExpression) === false
                ? predicate : this.reflectedInfo;
        };
        ExpectedExpressionReflector.prototype.expressionProxy = function () {
            var _this = this;
            var options = {
                get: function (target, name) {
                    _this.reflectedInfo = new ExpectedGetPropertyExpression(name);
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this.reflectedInfo = new ExpectedNamedMethodExpression(name, args);
                    };
                },
                set: function (target, name, value) {
                    _this.reflectedInfo = new ExpectedSetPropertyExpression(name, value);
                    return true;
                },
                apply: function (target, thisArg, args) {
                    _this.reflectedInfo = new ExpectedMethodExpression(args);
                },
                has: function (target, name) {
                    _this.reflectedInfo = new ExpectedInOperatorExpression(name);
                    return true;
                }
            };
            return new Proxy(function () { return undefined; }, options);
        };
        return ExpectedExpressionReflector;
    }());

    /**
     * @hidden
     */
    var ProxyFactory = /** @class */ (function () {
        function ProxyFactory(options, getTrap, setTrap, hasTrap, applyTrap, getPrototypeOfTrap, setPrototypeOfTrap) {
            this.options = options;
            this.getTrap = getTrap;
            this.setTrap = setTrap;
            this.hasTrap = hasTrap;
            this.applyTrap = applyTrap;
            this.getPrototypeOfTrap = getPrototypeOfTrap;
            this.setPrototypeOfTrap = setPrototypeOfTrap;
        }
        ProxyFactory.prototype.object = function () {
            if (this._proxy === undefined) {
                this._proxy = this.createObject();
            }
            return this._proxy;
        };
        ProxyFactory.prototype.createObject = function () {
            var _this = this;
            var options = {
                get: function (target, name) { return _this.getTrap.intercept(name); },
                set: function (target, name, value) { return _this.setTrap.intercept(target, name, value); },
                has: function (target, name) { return _this.hasTrap.intercept(name); },
                apply: function (target, thisArg, args) { return _this.applyTrap.intercept(target, thisArg, args); },
                getPrototypeOf: function () { return _this.getPrototypeOfTrap.intercept(); },
                setPrototypeOf: function (target, prototype) { return _this.setPrototypeOfTrap.intercept(prototype); }
            };
            if (this.options.name) {
                options["mockName"] = this.options.name;
            }
            return new Proxy(this.options.target, options);
        };
        return ProxyFactory;
    }());

    /**
     * Sets the rules where bounds of a range are included or excluded from the range.
     * See {@link Times.Between}
     */
    (function (Range) {
        Range[Range["Exclusive"] = 0] = "Exclusive";
        Range[Range["Inclusive"] = 1] = "Inclusive";
    })(exports.Range || (exports.Range = {}));
    /**
     * This class expresses the expectation about amount of invocations.
     *
     * @example
     * ```typescript
     *
     * const times = new Times(expected => expected === 1, `Should be called once`);
     * const actual = times.test(2);
     *
     * expect(actual).toBe(false);
     * expect(times.message).toBe(`Should be called once`);
     * ```
     *
     * ```typescript
     *
     * const mockName = 'mock name';
     *const mock = new Mock<ITestObject>(mockName);
     *const object = mock.object();
     *
     *object.property;
     *
     *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
     *
     *expect(action).toThrow();
     * ```
     */
    var Times = /** @class */ (function () {
        /**
         *
         * @param evaluator It takes actual value and decides if it is expected or not.
         * Returns true or false accordingly.
         * @param message A message that describes the expectation.
         */
        function Times(evaluator, message) {
            this.evaluator = evaluator;
            this.message = message;
        }
        /**
         * It expects that the actual would be equal or bigger then the expected value.
         *
         * @param callCount The expected value.
         */
        Times.AtLeast = function (callCount) {
            return new Times(function (expected) { return expected >= callCount; }, "Should be called at least " + callCount + " time(s)");
        };
        /**
         * It expects that the actual would be equal or bigger then 1.
         */
        Times.AtLeastOnce = function () {
            return Times._atLeastOnce;
        };
        /**
         * It expects that the actual would be equal or smaller then the expected value.
         *
         * @param callCount The expected value.
         */
        Times.AtMost = function (callCount) {
            return new Times(function (expected) { return expected <= callCount; }, "Should be called at most " + callCount + " time(s)");
        };
        /**
         * It expects that the actual would be equal or less then 1.
         */
        Times.AtMostOnce = function () {
            return Times._atMostOnce;
        };
        /**
         * It expects that the actual would be in the expected range of values.
         *
         * @param callCountFrom The lowest bound of the range.
         * @param callCountTo The highest bound of the range.
         * @param range  Sets the rules where bounds of a range are included or excluded from the range.
         */
        Times.Between = function (callCountFrom, callCountTo, range) {
            if (range === exports.Range.Exclusive) {
                return new Times(function (expected) { return expected > callCountFrom && expected < callCountTo; }, "Should be called exclusively between " + callCountFrom + " and " + callCountTo);
            }
            return new Times(function (expected) { return expected >= callCountFrom && expected <= callCountTo; }, "Should be called inclusively between " + callCountFrom + " and " + callCountTo);
        };
        /**
         * It expects that the actual is equal to the expected value.
         *
         * @param callCount The expected value.
         */
        Times.Exactly = function (callCount) {
            return new Times(function (expected) { return expected === callCount; }, "Should be called exactly " + callCount + " time(s)");
        };
        /**
         * It expects that the actual is equal 0.
         */
        Times.Never = function () {
            return Times._never;
        };
        /**
         * It expects that the actual is equal 1.
         */
        Times.Once = function () {
            return Times._once;
        };
        /**
         * Evaluates the expectation against the actual value.
         *
         * @param callCount The actual value.
         */
        Times.prototype.test = function (callCount) {
            return this.evaluator(callCount);
        };
        return Times;
    }());
    Times._once = new Times(function (expected) { return expected === 1; }, "Should be called once");
    Times._never = new Times(function (expected) { return expected === 0; }, "Should be called never");
    Times._atMostOnce = new Times(function (expected) { return expected <= 1; }, "Should be called at most once");
    Times._atLeastOnce = new Times(function (expected) { return expected >= 1; }, "Should be called at least once");

    /**
     * This class records all interactions with a mocked object.
     */
    var Tracker = /** @class */ (function () {
        function Tracker(sequenceId) {
            this.sequenceId = sequenceId;
            this.log = [];
        }
        /**
         * @hidden
         */
        Tracker.prototype.add = function (action) {
            var record = { id: this.sequenceId.next(), expression: action };
            this.log.push(record);
        };
        /**
         * Returns recorded interactions.
         */
        Tracker.prototype.get = function () {
            return __spread(this.log);
        };
        return Tracker;
    }());

    var VerifyError = /** @class */ (function (_super) {
        __extends(VerifyError, _super);
        function VerifyError(message) {
            return _super.call(this, message) || this;
        }
        return VerifyError;
    }(Error));

    /**
     * @hidden
     */
    var Verifier = /** @class */ (function () {
        function Verifier(reflector, callCounter, verifyFormatter) {
            this.reflector = reflector;
            this.callCounter = callCounter;
            this.verifyFormatter = verifyFormatter;
        }
        Verifier.prototype.test = function (expected, times, expressions, mockName) {
            var expression = this.reflector.reflect(expected);
            var callCount = this.callCounter.count(expression, expressions);
            var passed = times.test(callCount);
            if (passed === false) {
                var message = this.verifyFormatter.format(expression, times.message, callCount, expressions, mockName);
                throw new VerifyError(message);
            }
        };
        return Verifier;
    }());

    /**
     * @hidden
     */
    var PrototypeStorage = /** @class */ (function () {
        function PrototypeStorage(mockTarget) {
            var _a;
            this.prototype = null;
            this.prototype = (_a = mockTarget === null || mockTarget === void 0 ? void 0 : mockTarget.prototype) !== null && _a !== void 0 ? _a : mockTarget;
        }
        PrototypeStorage.prototype.get = function () {
            return this.prototype;
        };
        PrototypeStorage.prototype.set = function (prototype) {
            this.prototype = prototype;
        };
        return PrototypeStorage;
    }());

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function stringify(token) {
        if (typeof token === "string") {
            return token;
        }
        if (Array.isArray(token)) {
            return "[" + token.map(stringify).join(", ") + "]";
        }
        if (token == null) {
            return "" + token;
        }
        if (token.overriddenName) {
            return "" + token.overriddenName;
        }
        if (token.name) {
            return "" + token.name;
        }
        var res = token.toString();
        if (res == null) {
            return "" + res;
        }
        var newLineIndex = res.indexOf("\n");
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getClosureSafeProperty(objWithPropertyToExtract) {
        for (var key in objWithPropertyToExtract) {
            if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
                return key;
            }
        }
        throw Error("Could not find renamed property on target object.");
    }

    /* eslint-disable */
    var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
     * a query is not yet defined.
     *
     * @usageNotes
     * ### Example
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * @publicApi
     */
    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        forwardRefFn.toString = function () {
            return stringify(this());
        };
        return forwardRefFn;
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * @usageNotes
     * ### Example
     *
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * @see `forwardRef`
     * @publicApi
     */
    function resolveForwardRef(type) {
        return isForwardRef(type) ? type() : type;
    }
    /** Checks whether a function is wrapped by a `forwardRef`. */
    function isForwardRef(fn) {
        return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) &&
            fn.__forward_ref__ === forwardRef;
    }

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var InjectionToken = /** @class */ (function () {
        function InjectionToken(desc) {
            this.desc = desc;
        }
        InjectionToken.prototype.toString = function () {
            return "InjectionToken " + this.desc;
        };
        return InjectionToken;
    }());

    /* eslint-disable */
    /**
     * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
     *
     * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
     * project.
     *
     * @publicApi
     */
    var INJECTOR = new InjectionToken("INJECTOR");
    var _THROW_IF_NOT_FOUND = {};
    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
    var NG_TOKEN_PATH = "ngTokenPath";
    var NEW_LINE = /\n/gm;
    var NO_NEW_LINE = "ɵ";
    var SOURCE = "__source";
    var ɵ0 = getClosureSafeProperty;
    var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 });
    var NullInjector = /** @class */ (function () {
        function NullInjector() {
        }
        NullInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            if (notFoundValue === THROW_IF_NOT_FOUND) {
                var error = new Error("NullInjectorError: No provider for " + stringify(token) + "!");
                error.name = "NullInjectorError";
                throw error;
            }
            return notFoundValue;
        };
        return NullInjector;
    }());
    function catchInjectorError(e, token, injectorErrorName, source) {
        var tokenPath = e[NG_TEMP_TOKEN_PATH];
        if (token[SOURCE]) {
            tokenPath.unshift(token[SOURCE]);
        }
        e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
        e[NG_TOKEN_PATH] = tokenPath;
        e[NG_TEMP_TOKEN_PATH] = null;
        throw e;
    }
    function formatError(text, obj, injectorErrorName, source) {
        if (source === void 0) { source = null; }
        text = text && text.charAt(0) === "\n" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;
        var context = stringify(obj);
        if (Array.isArray(obj)) {
            context = obj.map(stringify).join(" -> ");
        }
        else if (typeof obj === "object") {
            var parts = [];
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    var value = obj[key];
                    parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
                }
            }
            context = "{" + parts.join(", ") + "}";
        }
        return "" + injectorErrorName + (source ? "(" + source + ")" : "") + "[" + context + "]: " + text.replace(NEW_LINE, "\n  ");
    }

    /* eslint-disable */
    (function (InjectFlags) {
        // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
        /** Check self and check parent injector if needed */
        InjectFlags[InjectFlags["Default"] = 0] = "Default";
        /**
         * Specifies that an injector should retrieve a dependency from any injector until reaching the
         * host element of the current component. (Only used with Element Injector)
         */
        InjectFlags[InjectFlags["Host"] = 1] = "Host";
        /** Don't ascend to ancestors of the node requesting injection. */
        InjectFlags[InjectFlags["Self"] = 2] = "Self";
        /** Skip the node that is requesting injection. */
        InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
        /** Inject `defaultValue` instead if token not found. */
        InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
    })(exports.InjectFlags || (exports.InjectFlags = {}));

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Type of the Optional metadata.
     */
    var Optional = /** @class */ (function () {
        function Optional() {
        }
        return Optional;
    }());
    /**
     * Type of the Self metadata.
     */
    var Self = /** @class */ (function () {
        function Self() {
        }
        return Self;
    }());
    /**
     * Type of the SkipSelf metadata.
     */
    var SkipSelf = /** @class */ (function () {
        function SkipSelf() {
        }
        return SkipSelf;
    }());
    /**
     * Type of the Host metadata.
     */
    var Host = /** @class */ (function () {
        function Host() {
        }
        return Host;
    }());

    var INJECTOR_IMPL = function (providers, parent, name) { return new StaticInjector(providers, parent, name); };
    /**
     * Concrete injectors implement this interface. Injectors are configured
     * with [providers](guide/glossary#provider) that associate
     * dependencies of various types with [injection tokens](guide/glossary#di-token).
     *
     * @see ["DI Providers"](guide/dependency-injection-providers).
     * @see `StaticProvider`
     *
     * @usageNotes
     *
     *  The following example creates a service injector instance.
     *
     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     *
     * ### Usage example
     *
     * {@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     *
     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * @publicApi
     */
    var Injector = /** @class */ (function () {
        function Injector() {
        }
        Injector.create = function (options, parent) {
            if (Array.isArray(options)) {
                return INJECTOR_IMPL(options, parent, "");
            }
            else {
                return INJECTOR_IMPL(options.providers, options.parent, options.name || "");
            }
        };
        return Injector;
    }());
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    /**
     * @internal
     * @nocollapse
     */
    Injector.__NG_ELEMENT_ID__ = -1;
    var IDENT = function (value) {
        return value;
    };
    var ɵ0$1 = IDENT;
    var EMPTY = [];
    var CIRCULAR = IDENT;
    var MULTI_PROVIDER_FN = function () {
        return Array.prototype.slice.call(arguments);
    };
    var ɵ1 = MULTI_PROVIDER_FN;
    var StaticInjector = /** @class */ (function () {
        function StaticInjector(providers, parent, source) {
            if (parent === void 0) { parent = new NullInjector(); }
            if (source === void 0) { source = null; }
            this.parent = parent;
            this.source = source;
            var records = this._records = new Map();
            records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            this.scope = recursivelyProcessProviders(records, providers);
        }
        StaticInjector.prototype.get = function (token, notFoundValue, flags) {
            if (flags === void 0) { flags = exports.InjectFlags.Default; }
            var records = this._records;
            var record = records.get(token);
            if (record === undefined) {
                records.set(token, null);
            }
            try {
                return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
            }
            catch (e) {
                return catchInjectorError(e, token, "StaticInjectorError", this.source);
            }
        };
        StaticInjector.prototype.toString = function () {
            var tokens = [];
            var records = this._records;
            records.forEach(function (v, token) { return tokens.push(stringify(token)); });
            return "StaticInjector[" + tokens.join(", ") + "]";
        };
        return StaticInjector;
    }());
    function resolveProvider(provider) {
        var deps = computeDeps(provider);
        var fn = IDENT;
        var value = EMPTY;
        var useNew = false;
        var provide = resolveForwardRef(provider.provide);
        if (USE_VALUE in provider) {
            // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
            value = provider.useValue;
        }
        else if (provider.useFactory) {
            fn = provider.useFactory;
        }
        else if (provider.useExisting) {
            // Just use IDENT
        }
        else if (provider.useClass) {
            useNew = true;
            fn = resolveForwardRef(provider.useClass);
        }
        else if (typeof provide === "function") {
            useNew = true;
            fn = provide;
        }
        else {
            throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
        }
        return { deps: deps, fn: fn, useNew: useNew, value: value };
    }
    function multiProviderMixError(token) {
        return staticError("Cannot mix multi providers and regular providers", token);
    }
    function recursivelyProcessProviders(records, provider) {
        var scope = null;
        if (provider) {
            provider = resolveForwardRef(provider);
            if (Array.isArray(provider)) {
                // if we have an array recurse into the array
                for (var i = 0; i < provider.length; i++) {
                    scope = recursivelyProcessProviders(records, provider[i]) || scope;
                }
            }
            else if (typeof provider === "function") {
                // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
                // error messages
                throw staticError("Function/Class not supported", provider);
            }
            else if (provider && typeof provider === "object" && provider.provide) {
                // At this point we have what looks like a provider: {provide: ?, ....}
                var token = resolveForwardRef(provider.provide);
                var resolvedProvider = resolveProvider(provider);
                if (provider.multi === true) {
                    // This is a multi provider.
                    var multiProvider = records.get(token);
                    if (multiProvider) {
                        if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                            throw multiProviderMixError(token);
                        }
                    }
                    else {
                        // Create a placeholder factory which will look up the constituents of the multi provider.
                        records.set(token, multiProvider = {
                            token: provider.provide,
                            deps: [],
                            useNew: false,
                            fn: MULTI_PROVIDER_FN,
                            value: EMPTY
                        });
                    }
                    // Treat the provider as the token.
                    token = provider;
                    multiProvider.deps.push({ token: token, options: 6 /* Default */ });
                }
                var record = records.get(token);
                if (record && record.fn === MULTI_PROVIDER_FN) {
                    throw multiProviderMixError(token);
                }
                records.set(token, resolvedProvider);
            }
            else {
                throw staticError("Unexpected provider", provider);
            }
        }
        return scope;
    }
    function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
        try {
            return resolveToken(token, record, records, parent, notFoundValue, flags);
        }
        catch (e) {
            // ensure that 'e' is of type Error.
            if (!(e instanceof Error)) {
                e = new Error(e);
            }
            var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
            path.unshift(token);
            if (record && record.value === CIRCULAR) {
                // Reset the Circular flag.
                record.value = EMPTY;
            }
            throw e;
        }
    }
    function resolveToken(token, record, records, parent, notFoundValue, flags) {
        var value;
        // eslint-disable-next-line no-bitwise
        if (record && !(flags & exports.InjectFlags.SkipSelf)) {
            // If we don't have a record, this implies that we don't own the provider hence don't know how
            // to resolve it.
            value = record.value;
            if (value === CIRCULAR) {
                throw Error(NO_NEW_LINE + "Circular dependency");
            }
            else if (value === EMPTY) {
                record.value = CIRCULAR;
                var useNew = record.useNew, fn = record.fn, depRecords = record.deps;
                var deps = EMPTY;
                if (depRecords.length) {
                    deps = [];
                    for (var i = 0; i < depRecords.length; i++) {
                        var depRecord = depRecords[i];
                        var options = depRecord.options;
                        // eslint-disable-next-line no-bitwise
                        var childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                        deps.push(tryResolveToken(
                        // Current Token to resolve
                        depRecord.token, 
                        // A record which describes how to resolve the token.
                        // If undefined, this means we don't have such a record
                        childRecord, 
                        // Other records we know about.
                        records, 
                        // If we don't know how to resolve dependency and we should not check parent for it,
                        // than pass in Null injector.
                        // eslint-disable-next-line no-bitwise
                        !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, 
                        // eslint-disable-next-line no-bitwise
                        options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, exports.InjectFlags.Default));
                    }
                }
                record.value = value = useNew ? new (fn.bind.apply(fn, __spread([void 0], deps)))() : fn.apply(undefined, deps);
            }
            // eslint-disable-next-line no-bitwise
        }
        else if (!(flags & exports.InjectFlags.Self)) {
            value = parent.get(token, notFoundValue, exports.InjectFlags.Default);
            // eslint-disable-next-line no-bitwise
        }
        else if (!(flags & exports.InjectFlags.Optional)) {
            value = Injector.NULL.get(token, notFoundValue);
        }
        else {
            value = Injector.NULL.get(token, typeof notFoundValue !== "undefined" ? notFoundValue : null);
        }
        return value;
    }
    function computeDeps(provider) {
        var deps = EMPTY;
        var providerDeps = provider.deps;
        if (providerDeps && providerDeps.length) {
            deps = [];
            for (var i = 0; i < providerDeps.length; i++) {
                var options = 6 /* Default */;
                var token = resolveForwardRef(providerDeps[i]);
                if (Array.isArray(token)) {
                    for (var j = 0, annotations = token; j < annotations.length; j++) {
                        var annotation = annotations[j];
                        if (annotation instanceof Optional || annotation === Optional) {
                            // eslint-disable-next-line no-bitwise
                            options = options | 1 /* Optional */;
                        }
                        else if (annotation instanceof SkipSelf || annotation === SkipSelf) {
                            // eslint-disable-next-line no-bitwise
                            options = options & ~2 /* CheckSelf */;
                        }
                        else if (annotation instanceof Self || annotation === Self) {
                            // eslint-disable-next-line no-bitwise
                            options = options & ~4 /* CheckParent */;
                        }
                        else {
                            token = resolveForwardRef(annotation);
                        }
                    }
                }
                deps.push({ token: token, options: options });
            }
        }
        else if (provider.useExisting) {
            var token = resolveForwardRef(provider.useExisting);
            deps = [{ token: token, options: 6 /* Default */ }];
        }
        else if (!providerDeps && !(USE_VALUE in provider)) {
            // useValue & useExisting are the only ones which are exempt from deps all others need it.
            throw staticError("'deps' required", provider);
        }
        return deps;
    }
    function staticError(text, obj) {
        return new Error(formatError(text, obj, "StaticInjectorError"));
    }

    /**
     * Creates an angular based injector
     */
    function injectorFactory(options) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var injectorConfig = options.injectorConfig;
        if (injectorConfig) {
            return Injector.create({ providers: injectorConfig.get(options, providers) });
        }
        throw new Error("injectorConfig is not defined");
    }

    /**
     * @Hidden
     */
    var MOCK = new InjectionToken("IMock");

    /**
     * @hidden
     */
    var MOCK_OPTIONS = new InjectionToken("mock options");

    /**
     * @hidden
     */
    var PRESET_BUILDER_FACTORY = new InjectionToken("PRESET_BUILDER_FACTORY");

    /**
     * @hidden
     */
    var SequenceId = /** @class */ (function () {
        function SequenceId() {
            this.value = 0;
        }
        SequenceId.prototype.next = function () {
            return this.value++;
        };
        return SequenceId;
    }());

    /**
     * @hidden
     */
    var trackerProviders = [
        { provide: SequenceId, useClass: SequenceId, deps: [] },
        { provide: Tracker, useClass: Tracker, deps: [SequenceId] }
    ];

    /**
     * @hidden
     */
    var reflectorProviders = [
        { provide: ExpectedExpressionReflector, useClass: ExpectedExpressionReflector, deps: [] }
    ];

    var MimicsPreset = /** @class */ (function () {
        function MimicsPreset(playable, target, origin) {
            this.playable = playable;
            this.target = target;
            this.origin = origin;
        }
        return MimicsPreset;
    }());

    var ReturnsPreset = /** @class */ (function () {
        function ReturnsPreset(playable, target, value) {
            this.playable = playable;
            this.target = target;
            this.value = value;
        }
        return ReturnsPreset;
    }());

    var ThrowsPreset = /** @class */ (function () {
        function ThrowsPreset(playable, target, exception) {
            this.playable = playable;
            this.target = target;
            this.exception = exception;
        }
        return ThrowsPreset;
    }());

    var CallbacksPreset = /** @class */ (function () {
        function CallbacksPreset(playable, target, callback) {
            this.playable = playable;
            this.target = target;
            this.callback = callback;
        }
        return CallbacksPreset;
    }());

    /**
     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
     */
    var PlayableExactly = /** @class */ (function () {
        function PlayableExactly(count) {
            var _this = this;
            this.count = count;
            this.invoked = 0;
            this.update = function (reason) {
                if (reason === 0 /* OwnSetupWouldBePlayed */) {
                    _this.invoked++;
                }
            };
            this.isPlayable = function () { return _this.invoked <= _this.count; };
        }
        return PlayableExactly;
    }());

    /**
     * The configured setup will be never applied to invocations.
     */
    var PlayableNever = /** @class */ (function () {
        function PlayableNever() {
            this.update = function () { return undefined; };
            this.isPlayable = function () { return false; };
        }
        return PlayableNever;
    }());

    /**
     * The configured setup will be applied only to the first invocation.
     */
    var PlayableOnce = /** @class */ (function () {
        function PlayableOnce() {
            var _this = this;
            this.played = false;
            this.update = function (reason) {
                if (reason === 0 /* OwnSetupWouldBePlayed */) {
                    _this.played = true;
                }
            };
            this.isPlayable = function () { return _this.played === false; };
        }
        return PlayableOnce;
    }());

    /**
     * The configured setup will be always applied to invocations.
     */
    var PlayableAlways = /** @class */ (function () {
        function PlayableAlways() {
            this.isPlayable = function () { return true; };
            this.update = function () { return undefined; };
        }
        return PlayableAlways;
    }());

    /**
     * The configured setup will be applied or not accordingly to the value in the sequence.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Sequence([false, true]))
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(undefined);
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    var PlayableSequence = /** @class */ (function () {
        function PlayableSequence(sequence) {
            var _this = this;
            this.sequence = sequence;
            this.index = 0;
            this.update = function () {
                _this.index++;
            };
            this.isPlayable = function () {
                if (_this.index >= _this.sequence.length)
                    return false;
                return _this.sequence[_this.index];
            };
        }
        return PlayableSequence;
    }());

    /**
     * This class sets rules when a configured setup should be applied to the target invocation or not.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Once())
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    var PlayTimes = /** @class */ (function () {
        function PlayTimes() {
        }
        /**
         * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
         */
        PlayTimes.Exactly = function (count) {
            return new PlayableExactly(count);
        };
        /**
         * The configured setup will be always applied to invocations.
         */
        PlayTimes.Always = function () {
            return PlayTimes.always;
        };
        /**
         * The configured setup will be never applied to invocations.
         */
        PlayTimes.Never = function () {
            return PlayTimes.never;
        };
        /**
         * The configured setup will be applied only to the first invocation.
         */
        PlayTimes.Once = function () {
            return new PlayableOnce();
        };
        /**
         * The configured setup will be applied or not accordingly to the value in the sequence.
         *
         * @example
         * ```typescript
         *
         * const value = 'value';
         * const object = new Mock<Function>()
         * .setup(instance => instance(1))
         * .play(PlayTimes.Sequence([false, true]))
         * .returns(value)
         * .object();
         *
         * expect(object(1).toBe(undefined);
         * expect(object(1).toBe(value);
         * expect(object(1).toBe(undefined);
         * ```
         */
        PlayTimes.Sequence = function (sequence) {
            return new PlayableSequence(sequence);
        };
        return PlayTimes;
    }());
    PlayTimes.always = new PlayableAlways();
    PlayTimes.never = new PlayableNever();

    /**
     * The default implementation of {@link IPresetBuilder} interface.
     * Is it not intended to be used outside of the moq library.
     *
     * @hidden
     */
    var PresetBuilder = /** @class */ (function () {
        function PresetBuilder(mock, set, target, playable) {
            if (playable === void 0) { playable = PlayTimes.Always(); }
            this.mock = mock;
            this.set = set;
            this.target = target;
            this.playable = playable;
        }
        PresetBuilder.prototype.mimics = function (origin) {
            var preset = new MimicsPreset(this.playable, this.target, origin);
            this.set(preset);
            return this.mock;
        };
        PresetBuilder.prototype.returns = function (value) {
            var preset = new ReturnsPreset(this.playable, this.target, value);
            this.set(preset);
            return this.mock;
        };
        PresetBuilder.prototype.throws = function (exception) {
            var preset = new ThrowsPreset(this.playable, this.target, exception);
            this.set(preset);
            return this.mock;
        };
        PresetBuilder.prototype.callback = function (callback) {
            var preset = new CallbacksPreset(this.playable, this.target, callback);
            this.set(preset);
            return this.mock;
        };
        PresetBuilder.prototype.play = function (playable) {
            this.playable = playable;
            return this;
        };
        return PresetBuilder;
    }());

    /**
     * @hidden
     */
    var Presets = /** @class */ (function () {
        function Presets() {
            this.presets = [];
        }
        Presets.prototype.add = function (preset) {
            this.presets.unshift(preset);
        };
        Presets.prototype.get = function () {
            return __spread(this.presets);
        };
        return Presets;
    }());

    var ɵ0$2 = function (mock, presets) { return function (target) { return new PresetBuilder(mock, function (preset) { return presets.add(preset); }, target); }; };
    /**
     * @hidden
     */
    var presetsProviders = [
        { provide: Presets, useClass: Presets, deps: [] },
        {
            provide: PRESET_BUILDER_FACTORY,
            useFactory: ɵ0$2,
            deps: [MOCK, Presets]
        }
    ];

    /**
     * @hidden
     */
    var CallCounter = /** @class */ (function () {
        function CallCounter(expressionMatcher) {
            this.expressionMatcher = expressionMatcher;
        }
        CallCounter.prototype.count = function (expected, expressions) {
            var e_1, _a;
            var count = 0;
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var expression = expressions_1_1.value;
                    if (this.expressionMatcher.matched(expression, expected) === true) {
                        count += 1;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return count;
        };
        return CallCounter;
    }());

    /**
     * @hidden
     */
    var VerifyFormatter = /** @class */ (function () {
        function VerifyFormatter(expectedExpressionFormatter, trackedExpressionsFormatter) {
            this.expectedExpressionFormatter = expectedExpressionFormatter;
            this.trackedExpressionsFormatter = trackedExpressionsFormatter;
        }
        VerifyFormatter.prototype.format = function (expected, timesMessage, haveBeenCalledTimes, trackedExpressions, mockName) {
            var expectedExpressionMessage = this.expectedExpressionFormatter.format(expected, timesMessage, haveBeenCalledTimes, mockName);
            var trackedExpressionsMessage = this.trackedExpressionsFormatter.format(trackedExpressions);
            var delimiter = "-------------------------------------";
            return expectedExpressionMessage + "\n" + delimiter + "\nTracked calls:\n" + trackedExpressionsMessage + "\n" + delimiter + "\n";
        };
        return VerifyFormatter;
    }());

    /**
     * @hidden
     */
    var ExpressionMatcher = /** @class */ (function () {
        function ExpressionMatcher(getPropertyExpressionMatcher, setPropertyExpressionMatcher, methodExpressionMatcher, namedMethodExpressionMatcher, inOperatorExpressionMatcher) {
            this.getPropertyExpressionMatcher = getPropertyExpressionMatcher;
            this.setPropertyExpressionMatcher = setPropertyExpressionMatcher;
            this.methodExpressionMatcher = methodExpressionMatcher;
            this.namedMethodExpressionMatcher = namedMethodExpressionMatcher;
            this.inOperatorExpressionMatcher = inOperatorExpressionMatcher;
        }
        ExpressionMatcher.prototype.matched = function (left, right) {
            if (left === right)
                return true;
            if (right === undefined)
                return true;
            if (left instanceof GetPropertyInteraction && (right instanceof ExpectedGetPropertyExpression || right instanceof It)) {
                return this.getPropertyExpressionMatcher.matched(left, right);
            }
            if (left instanceof SetPropertyInteraction && (right instanceof ExpectedSetPropertyExpression || right instanceof It)) {
                return this.setPropertyExpressionMatcher.matched(left, right);
            }
            if (left instanceof InOperatorInteraction && (right instanceof ExpectedInOperatorExpression || right instanceof It)) {
                return this.inOperatorExpressionMatcher.matched(left, right);
            }
            if (left instanceof MethodInteraction && (right instanceof ExpectedMethodExpression || right instanceof It)) {
                return this.methodExpressionMatcher.matched(left, right);
            }
            if (left instanceof NamedMethodInteraction && (right instanceof ExpectedNamedMethodExpression || right instanceof It)) {
                return this.namedMethodExpressionMatcher.matched(left, right);
            }
            return false;
        };
        return ExpressionMatcher;
    }());

    /**
     * @hidden
     */
    var verificationProviders = [
        { provide: Verifier, useClass: Verifier, deps: [ExpectedExpressionReflector, CallCounter, VerifyFormatter] },
        { provide: CallCounter, useClass: CallCounter, deps: [ExpressionMatcher] },
    ];

    /**
     * @hidden
     */
    var ApplyTrap = /** @class */ (function () {
        function ApplyTrap(tracker, interactionPlayer) {
            this.tracker = tracker;
            this.interactionPlayer = interactionPlayer;
        }
        ApplyTrap.prototype.intercept = function (target, thisArg, argArray) {
            var expression = new MethodInteraction(argArray);
            this.tracker.add(expression);
            return this.interactionPlayer.play(expression);
        };
        return ApplyTrap;
    }());

    /**
     * @hidden
     */
    var InteractionPlayer = /** @class */ (function () {
        function InteractionPlayer(playablePresetProvider, presetPlayablesUpdater, presetPlayer) {
            this.playablePresetProvider = playablePresetProvider;
            this.presetPlayablesUpdater = presetPlayablesUpdater;
            this.presetPlayer = presetPlayer;
        }
        InteractionPlayer.prototype.play = function (interaction) {
            var preset = this.playablePresetProvider.get(interaction);
            this.presetPlayablesUpdater.update(interaction, preset);
            if (preset === undefined)
                return undefined;
            return this.presetPlayer.play(preset, interaction);
        };
        return InteractionPlayer;
    }());

    /**
     * @hidden
     */
    var GetTrap = /** @class */ (function () {
        function GetTrap(mock, tracker, propertiesValueStorage, interactionPlayer, hasPropertyExplorer, hasMethodExplorer, spyFunctionProvider) {
            this.mock = mock;
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.hasPropertyExplorer = hasPropertyExplorer;
            this.hasMethodExplorer = hasMethodExplorer;
            this.spyFunctionProvider = spyFunctionProvider;
        }
        GetTrap.prototype.intercept = function (property) {
            var interaction = new GetPropertyInteraction(property);
            this.tracker.add(interaction);
            if (property === MoqAPI) {
                return this.mock;
            }
            if (this.propertiesValueStorage.has(property)) {
                return this.propertiesValueStorage.get(property);
            }
            if (this.hasPropertyExplorer.has(property)) {
                return this.interactionPlayer.play(interaction);
            }
            if (this.hasMethodExplorer.has(property)) {
                return this.spyFunctionProvider.get(property);
            }
            return this.interactionPlayer.play(interaction);
        };
        return GetTrap;
    }());

    var PropertiesValueStorage = /** @class */ (function () {
        function PropertiesValueStorage() {
            this.storage = new Map();
        }
        PropertiesValueStorage.prototype.has = function (property) {
            return this.storage.has(property);
        };
        PropertiesValueStorage.prototype.get = function (property) {
            return this.storage.get(property);
        };
        PropertiesValueStorage.prototype.set = function (property, value) {
            this.storage.set(property, value);
        };
        return PropertiesValueStorage;
    }());

    /**
     * @hidden
     */
    var HasPropertyExplorer = /** @class */ (function () {
        function HasPropertyExplorer(presets, membersExplorer, explorer) {
            this.presets = presets;
            this.membersExplorer = membersExplorer;
            this.explorer = explorer;
        }
        HasPropertyExplorer.prototype.has = function (name) {
            var _this = this;
            if (this.membersExplorer.hasProperty(name)) {
                return true;
            }
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return HasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var HasMethodExplorer = /** @class */ (function () {
        function HasMethodExplorer(presets, membersExplorer, explorer) {
            this.presets = presets;
            this.membersExplorer = membersExplorer;
            this.explorer = explorer;
        }
        HasMethodExplorer.prototype.has = function (name) {
            var _this = this;
            if (this.membersExplorer.hasMethod(name)) {
                return true;
            }
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return HasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var SpyFunctionProvider = /** @class */ (function () {
        function SpyFunctionProvider(tracker, interactionPlayer) {
            this.tracker = tracker;
            this.interactionPlayer = interactionPlayer;
            this.map = new Map();
        }
        SpyFunctionProvider.prototype.get = function (property) {
            var _this = this;
            if (this.map.has(property) === false) {
                this.map.set(property, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var interaction = new NamedMethodInteraction(property, args);
                    _this.tracker.add(interaction);
                    return _this.interactionPlayer.play(interaction);
                });
            }
            return this.map.get(property);
        };
        return SpyFunctionProvider;
    }());

    /**
     * @hidden
     */
    var GetPrototypeOfTrap = /** @class */ (function () {
        function GetPrototypeOfTrap(prototypeStorage) {
            this.prototypeStorage = prototypeStorage;
        }
        GetPrototypeOfTrap.prototype.intercept = function () {
            return this.prototypeStorage.get();
        };
        return GetPrototypeOfTrap;
    }());

    /**
     * @hidden
     */
    var HasTrap = /** @class */ (function () {
        function HasTrap(tracker, propertiesValueStorage, interactionPlayer, inOperatorInteractionExplorer, hasPropertyExplorer, hasMethodExplorer, presetPlayablesUpdater) {
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.inOperatorInteractionExplorer = inOperatorInteractionExplorer;
            this.hasPropertyExplorer = hasPropertyExplorer;
            this.hasMethodExplorer = hasMethodExplorer;
            this.presetPlayablesUpdater = presetPlayablesUpdater;
        }
        HasTrap.prototype.intercept = function (property) {
            var interaction = new InOperatorInteraction(property);
            this.tracker.add(interaction);
            if (this.propertiesValueStorage.has(property)) {
                return true;
            }
            if (this.inOperatorInteractionExplorer.has(property)) {
                return this.interactionPlayer.play(interaction);
            }
            this.presetPlayablesUpdater.update(interaction, undefined);
            if (this.hasPropertyExplorer.has(property)) {
                return true;
            }
            if (this.hasMethodExplorer.has(property)) {
                return true;
            }
            return false;
        };
        return HasTrap;
    }());

    /**
     * @hidden
     */
    var InOperatorInteractionExplorer = /** @class */ (function () {
        function InOperatorInteractionExplorer(presets, explorer) {
            this.presets = presets;
            this.explorer = explorer;
        }
        InOperatorInteractionExplorer.prototype.has = function (name) {
            var _this = this;
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return InOperatorInteractionExplorer;
    }());

    /**
     * @hidden
     */
    var PresetPlayablesUpdater = /** @class */ (function () {
        function PresetPlayablesUpdater(presets, matcher) {
            this.presets = presets;
            this.matcher = matcher;
        }
        PresetPlayablesUpdater.prototype.update = function (interaction, playable) {
            var e_1, _a;
            try {
                for (var _b = __values(this.presets.get()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var preset = _c.value;
                    var target = preset.target, update = preset.playable.update;
                    if (this.matcher.matched(interaction, target)) {
                        var reason = preset === playable ?
                            0 /* OwnSetupWouldBePlayed */ :
                            1 /* OtherSetupWouldBePlayed */;
                        update(reason);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return PresetPlayablesUpdater;
    }());

    /**
     * @hidden
     */
    var SetTrap = /** @class */ (function () {
        function SetTrap(tracker, propertiesValueStorage, interactionPlayer, propertyIsReadOnlyTester) {
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.propertyIsReadOnlyTester = propertyIsReadOnlyTester;
        }
        SetTrap.prototype.intercept = function (target, property, value) {
            var expression = new SetPropertyInteraction(property, value);
            this.tracker.add(expression);
            if (property === MoqAPI) {
                return false;
            }
            if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {
                return false;
            }
            var accepted = this.interactionPlayer.play(expression);
            if (accepted === true || accepted === undefined) {
                this.propertiesValueStorage.set(property, value);
            }
            return accepted === undefined ? true : accepted;
        };
        return SetTrap;
    }());

    /**
     * @hidden
     */
    var SetPrototypeOfTrap = /** @class */ (function () {
        function SetPrototypeOfTrap(prototypeStorage) {
            this.prototypeStorage = prototypeStorage;
        }
        SetPrototypeOfTrap.prototype.intercept = function (prototype) {
            if (prototype !== undefined) {
                this.prototypeStorage.set(prototype);
                return true;
            }
            return false;
        };
        return SetPrototypeOfTrap;
    }());

    /**
     * @hidden
     */
    var PropertyIsReadOnlyTester = /** @class */ (function () {
        function PropertyIsReadOnlyTester(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        PropertyIsReadOnlyTester.prototype.isReadOnly = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.get instanceof Function && descriptor.set === undefined || descriptor.writable === false;
            }
            return false;
        };
        return PropertyIsReadOnlyTester;
    }());

    var ɵ0$3 = function (_a) {
        var target = _a.target;
        return new PrototypeStorage(target);
    };
    /**
     * @hidden
     */
    var interceptorsProviders = [
        {
            provide: ProxyFactory, useClass: ProxyFactory, deps: [
                MOCK_OPTIONS,
                GetTrap,
                SetTrap,
                HasTrap,
                ApplyTrap,
                GetPrototypeOfTrap,
                SetPrototypeOfTrap
            ]
        },
        { provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer] },
        {
            provide: GetTrap, useClass: GetTrap, deps: [
                MOCK,
                Tracker,
                PropertiesValueStorage,
                InteractionPlayer,
                HasPropertyExplorer,
                HasMethodExplorer,
                SpyFunctionProvider
            ]
        },
        { provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage] },
        {
            provide: HasTrap, useClass: HasTrap, deps: [
                Tracker,
                PropertiesValueStorage,
                InteractionPlayer,
                InOperatorInteractionExplorer,
                HasPropertyExplorer,
                HasMethodExplorer,
                PresetPlayablesUpdater
            ]
        },
        { provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: [] },
        { provide: PrototypeStorage, useFactory: ɵ0$3, deps: [MOCK_OPTIONS] },
        { provide: SetTrap, useClass: SetTrap, deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester] },
        { provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage] },
        { provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer] },
    ];

    /**
     * @hidden
     */
    var playablesProviders = [
        { provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionMatcher] }
    ];

    /**
     * @hidden
     */
    var PresetPlayer = /** @class */ (function () {
        function PresetPlayer(callbackPresetPlayer, mimicsPresetPlayer) {
            this.callbackPresetPlayer = callbackPresetPlayer;
            this.mimicsPresetPlayer = mimicsPresetPlayer;
        }
        PresetPlayer.prototype.play = function (preset, interaction) {
            if (preset instanceof ReturnsPreset) {
                return preset.value;
            }
            if (preset instanceof CallbacksPreset) {
                return this.callbackPresetPlayer.play(preset.callback, interaction);
            }
            if (preset instanceof MimicsPreset) {
                return this.mimicsPresetPlayer.play(preset.origin, interaction);
            }
            if (preset instanceof ThrowsPreset) {
                throw preset.exception;
            }
        };
        return PresetPlayer;
    }());

    /**
     * @hidden
     */
    var CallbackPresetPlayer = /** @class */ (function () {
        function CallbackPresetPlayer() {
        }
        CallbackPresetPlayer.prototype.play = function (callback, interaction) {
            return callback.apply(undefined, [interaction]);
        };
        return CallbackPresetPlayer;
    }());

    /**
     * @hidden
     */
    var MimicsPresetPlayer = /** @class */ (function () {
        function MimicsPresetPlayer(apply) {
            this.apply = apply;
        }
        MimicsPresetPlayer.prototype.play = function (origin, interaction) {
            if (interaction instanceof GetPropertyInteraction) {
                return origin[interaction.name];
            }
            if (interaction instanceof SetPropertyInteraction) {
                origin[interaction.name] = interaction.value;
                return true;
            }
            if (interaction instanceof NamedMethodInteraction) {
                var method = origin[interaction.name];
                return this.apply(method, origin, interaction.args);
            }
            if (interaction instanceof MethodInteraction) {
                return this.apply(origin, undefined, interaction.args);
            }
            if (interaction instanceof InOperatorInteraction) {
                return interaction.name in origin;
            }
        };
        return MimicsPresetPlayer;
    }());

    /**
     * @hidden
     */
    var PlayablePresetProvider = /** @class */ (function () {
        function PlayablePresetProvider(presets, matcher) {
            this.presets = presets;
            this.matcher = matcher;
        }
        PlayablePresetProvider.prototype.get = function (interaction) {
            var e_1, _a;
            try {
                for (var _b = __values(this.presets.get()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var preset = _c.value;
                    var target = preset.target, isPlayable = preset.playable.isPlayable;
                    if (this.matcher.matched(interaction, target) && isPlayable() === true) {
                        return preset;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return PlayablePresetProvider;
    }());

    /**
     * @hidden
     */
    var REFLECT_APPLY = new InjectionToken("Reflect Apply");

    var ɵ0$4 = Reflect.apply;
    /**
     * @hidden
     */
    var interactionPlayersProviders = [
        { provide: REFLECT_APPLY, useValue: ɵ0$4, deps: [] },
        { provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer] },
        { provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionMatcher] },
        { provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY] },
        {
            provide: InteractionPlayer,
            useClass: InteractionPlayer,
            deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]
        },
        { provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: [] },
    ];

    /**
     * @hidden
     */
    var ExpectedExpressionFormatter = /** @class */ (function () {
        function ExpectedExpressionFormatter(expressionFormatter) {
            this.expressionFormatter = expressionFormatter;
        }
        ExpectedExpressionFormatter.prototype.format = function (expected, timesMessage, haveBeenCalledTimes, mockName) {
            var expressionDescription = this.expressionFormatter.format(expected);
            var mockDescription = mockName !== undefined ? " of " + mockName : "";
            return "" + expressionDescription + mockDescription + " " + timesMessage.toLowerCase() + ", but was called " + haveBeenCalledTimes + " time(s)";
        };
        return ExpectedExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var TrackedExpressionsFormatter = /** @class */ (function () {
        function TrackedExpressionsFormatter(expressionFormatter) {
            this.expressionFormatter = expressionFormatter;
        }
        TrackedExpressionsFormatter.prototype.format = function (trackedExpressions) {
            var e_1, _a;
            var result = "";
            try {
                for (var trackedExpressions_1 = __values(trackedExpressions), trackedExpressions_1_1 = trackedExpressions_1.next(); !trackedExpressions_1_1.done; trackedExpressions_1_1 = trackedExpressions_1.next()) {
                    var expression = trackedExpressions_1_1.value;
                    result += this.expressionFormatter.format(expression) + "\n";
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (trackedExpressions_1_1 && !trackedExpressions_1_1.done && (_a = trackedExpressions_1.return)) _a.call(trackedExpressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result.substr(0, result.length - 1);
        };
        return TrackedExpressionsFormatter;
    }());

    /**
     * @hidden
     */
    var ExpressionFormatter = /** @class */ (function () {
        function ExpressionFormatter(getPropertyFormatter, setPropertyFormatter, methodFormatter, namedMethodFormatter, constantFormatter, inOperatorFormatter) {
            this.getPropertyFormatter = getPropertyFormatter;
            this.setPropertyFormatter = setPropertyFormatter;
            this.methodFormatter = methodFormatter;
            this.namedMethodFormatter = namedMethodFormatter;
            this.constantFormatter = constantFormatter;
            this.inOperatorFormatter = inOperatorFormatter;
        }
        ExpressionFormatter.prototype.format = function (expression) {
            if (expression instanceof GetPropertyInteraction)
                return this.getPropertyFormatter.format(expression);
            if (expression instanceof SetPropertyInteraction)
                return this.setPropertyFormatter.format(expression);
            if (expression instanceof InOperatorInteraction)
                return this.inOperatorFormatter.format(expression);
            if (expression instanceof MethodInteraction)
                return this.methodFormatter.format(expression);
            if (expression instanceof NamedMethodInteraction)
                return this.namedMethodFormatter.format(expression);
            if (expression instanceof It)
                return this.constantFormatter.format(expression);
            return undefined;
        };
        return ExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var SetPropertyExpressionFormatter = /** @class */ (function () {
        function SetPropertyExpressionFormatter(constantFormatter, propertyKeyFormatter) {
            this.constantFormatter = constantFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        SetPropertyExpressionFormatter.prototype.format = function (expression) {
            var value = this.constantFormatter.format(expression.value);
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return "Assignment of " + value + " to property '" + propertyKey + "'";
        };
        return SetPropertyExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var ConstantFormatter = /** @class */ (function () {
        function ConstantFormatter() {
        }
        ConstantFormatter.prototype.format = function (object) {
            var e_1, _a;
            if (object instanceof It)
                return "It.Is(" + object.predicate + ")";
            if (object instanceof String || typeof object === "string")
                return "'" + object + "'";
            if (object instanceof Array) {
                var description = [];
                try {
                    for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var index = _c.value;
                        description.push(new ConstantFormatter().format(object[index]));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return "[" + description + "]";
            }
            return "" + object;
        };
        return ConstantFormatter;
    }());

    /**
     * @hidden
     */
    var PropertyKeyFormatter = /** @class */ (function () {
        function PropertyKeyFormatter() {
        }
        PropertyKeyFormatter.prototype.format = function (property) {
            return String(property);
        };
        return PropertyKeyFormatter;
    }());

    /**
     * @hidden
     */
    var NamedMethodExpressionFormatter = /** @class */ (function () {
        function NamedMethodExpressionFormatter(constantFormatter, propertyKeyFormatter) {
            this.constantFormatter = constantFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        NamedMethodExpressionFormatter.prototype.format = function (expression) {
            var _this = this;
            var formatted = [];
            expression.args.forEach(function (arg) {
                formatted.push(_this.constantFormatter.format(arg));
            });
            var value = formatted.join(", ");
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return propertyKey + "(" + value + ")";
        };
        return NamedMethodExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var MethodExpressionFormatter = /** @class */ (function () {
        function MethodExpressionFormatter(constantFormatter) {
            this.constantFormatter = constantFormatter;
        }
        MethodExpressionFormatter.prototype.format = function (expression) {
            var value = this.constantFormatter.format(expression.args);
            return "(" + value + ")";
        };
        return MethodExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var InOperatorFormatter = /** @class */ (function () {
        function InOperatorFormatter(propertyKeyFormatter) {
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        InOperatorFormatter.prototype.format = function (expression) {
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return "In operator for '" + propertyKey + "'";
        };
        return InOperatorFormatter;
    }());

    /**
     * @hidden
     */
    var GetPropertyExpressionFormatter = /** @class */ (function () {
        function GetPropertyExpressionFormatter(propertyKeyFormatter) {
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        GetPropertyExpressionFormatter.prototype.format = function (expression) {
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return "Getter of '" + propertyKey + "'";
        };
        return GetPropertyExpressionFormatter;
    }());

    /**
     * @hidden
     */
    var formattersProviders = [
        {
            provide: VerifyFormatter,
            useClass: VerifyFormatter,
            deps: [ExpectedExpressionFormatter, TrackedExpressionsFormatter]
        },
        { provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [ExpressionFormatter] },
        {
            provide: SetPropertyExpressionFormatter,
            useClass: SetPropertyExpressionFormatter,
            deps: [ConstantFormatter, PropertyKeyFormatter]
        },
        { provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: [] },
        {
            provide: NamedMethodExpressionFormatter,
            useClass: NamedMethodExpressionFormatter,
            deps: [ConstantFormatter, PropertyKeyFormatter]
        },
        { provide: MethodExpressionFormatter, useClass: MethodExpressionFormatter, deps: [ConstantFormatter] },
        { provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter] },
        { provide: GetPropertyExpressionFormatter, useClass: GetPropertyExpressionFormatter, deps: [PropertyKeyFormatter] },
        {
            provide: ExpressionFormatter,
            useClass: ExpressionFormatter,
            deps: [
                GetPropertyExpressionFormatter,
                SetPropertyExpressionFormatter,
                MethodExpressionFormatter,
                NamedMethodExpressionFormatter,
                ConstantFormatter,
                InOperatorFormatter
            ]
        },
        { provide: ExpectedExpressionFormatter, useClass: ExpectedExpressionFormatter, deps: [ExpressionFormatter] },
        { provide: ConstantFormatter, useClass: ConstantFormatter, deps: [] },
    ];

    /**
     * @hidden
     */
    var SetPropertyExpressionMatcher = /** @class */ (function () {
        function SetPropertyExpressionMatcher(constantMatcher) {
            this.constantMatcher = constantMatcher;
        }
        SetPropertyExpressionMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            var rightExpression = right;
            if (left.name === rightExpression.name && this.constantMatcher.matched(left.value, rightExpression.value))
                return true;
            return false;
        };
        return SetPropertyExpressionMatcher;
    }());

    /**
     * @hidden
     */
    var ConstantMatcher = /** @class */ (function () {
        function ConstantMatcher() {
        }
        ConstantMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            return left === right;
        };
        return ConstantMatcher;
    }());

    /**
     * @hidden
     */
    var NamedMethodExpressionMatcher = /** @class */ (function () {
        function NamedMethodExpressionMatcher(argumentsMatcher) {
            this.argumentsMatcher = argumentsMatcher;
        }
        NamedMethodExpressionMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            var rightExpression = right;
            if (left.name === rightExpression.name) {
                return this.argumentsMatcher.matched(left.args, rightExpression.args);
            }
            return false;
        };
        return NamedMethodExpressionMatcher;
    }());

    /**
     * @hidden
     */
    var ArgumentsMatcher = /** @class */ (function () {
        function ArgumentsMatcher(constantMatcher) {
            this.constantMatcher = constantMatcher;
        }
        ArgumentsMatcher.prototype.matched = function (left, right) {
            if (left === right)
                return true;
            if (left.length !== right.length)
                return false;
            for (var i = 0; i < left.length; i++) {
                var lvalue = left[i];
                var rvalue = right[i];
                if (this.constantMatcher.matched(lvalue, rvalue) === false) {
                    return false;
                }
            }
            return true;
        };
        return ArgumentsMatcher;
    }());

    /**
     * @hidden
     */
    var MethodExpressionMatcher = /** @class */ (function () {
        function MethodExpressionMatcher(argumentsMatcher) {
            this.argumentsMatcher = argumentsMatcher;
        }
        MethodExpressionMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            var rightExpression = right;
            return this.argumentsMatcher.matched(left.args, rightExpression.args);
        };
        return MethodExpressionMatcher;
    }());

    /**
     * @hidden
     */
    var InOperatorMatcher = /** @class */ (function () {
        function InOperatorMatcher() {
        }
        InOperatorMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            var rightExpression = right;
            if (left.name === rightExpression.name)
                return true;
            return false;
        };
        return InOperatorMatcher;
    }());

    /**
     * @hidden
     */
    var GetPropertyExpressionMatcher = /** @class */ (function () {
        function GetPropertyExpressionMatcher() {
        }
        GetPropertyExpressionMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            var rightExpression = right;
            if (left.name === rightExpression.name)
                return true;
            return false;
        };
        return GetPropertyExpressionMatcher;
    }());

    /**
     * @hidden
     */
    var expressionMatchersProviders = [
        {
            provide: ExpressionMatcher,
            useClass: ExpressionMatcher,
            deps: [
                GetPropertyExpressionMatcher,
                SetPropertyExpressionMatcher,
                MethodExpressionMatcher,
                NamedMethodExpressionMatcher,
                InOperatorMatcher
            ]
        },
        { provide: SetPropertyExpressionMatcher, useClass: SetPropertyExpressionMatcher, deps: [ConstantMatcher] },
        { provide: NamedMethodExpressionMatcher, useClass: NamedMethodExpressionMatcher, deps: [ArgumentsMatcher] },
        { provide: MethodExpressionMatcher, useClass: MethodExpressionMatcher, deps: [ArgumentsMatcher] },
        { provide: InOperatorMatcher, useClass: InOperatorMatcher, deps: [] },
        { provide: GetPropertyExpressionMatcher, useClass: GetPropertyExpressionMatcher, deps: [] },
        { provide: ConstantMatcher, useClass: ConstantMatcher, deps: [] },
        { provide: ArgumentsMatcher, useClass: ArgumentsMatcher, deps: [ConstantMatcher] },
    ];

    /**
     * @hidden
     */
    var ExpressionHasMethodExplorer = /** @class */ (function () {
        function ExpressionHasMethodExplorer() {
        }
        ExpressionHasMethodExplorer.prototype.has = function (name, expression) {
            if (expression instanceof ExpectedNamedMethodExpression) {
                return expression.name === name;
            }
            return false;
        };
        return ExpressionHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var MembersMethodExplorer = /** @class */ (function () {
        function MembersMethodExplorer(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        MembersMethodExplorer.prototype.hasMethod = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.value instanceof Function;
            }
            return false;
        };
        return MembersMethodExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasMethodExplorer = /** @class */ (function () {
        function PresetHasMethodExplorer(expressionHasMethodExplorer, objectHasMethodExplorer) {
            this.expressionHasMethodExplorer = expressionHasMethodExplorer;
            this.objectHasMethodExplorer = objectHasMethodExplorer;
        }
        PresetHasMethodExplorer.prototype.has = function (name, preset) {
            if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {
                return true;
            }
            return this.expressionHasMethodExplorer.has(name, preset.target);
        };
        return PresetHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var ObjectHasMethodExplorer = /** @class */ (function () {
        function ObjectHasMethodExplorer() {
        }
        ObjectHasMethodExplorer.prototype.has = function (name, target) {
            return target[name] instanceof Function;
        };
        return ObjectHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var ExpressionHasPropertyExplorer = /** @class */ (function () {
        function ExpressionHasPropertyExplorer() {
        }
        ExpressionHasPropertyExplorer.prototype.has = function (name, expression) {
            if (expression instanceof It
                || expression instanceof ExpectedMethodExpression
                || expression instanceof ExpectedNamedMethodExpression
                || expression instanceof ExpectedInOperatorExpression) {
                return false;
            }
            return expression.name === name;
        };
        return ExpressionHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var MembersPropertyExplorer = /** @class */ (function () {
        function MembersPropertyExplorer(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        MembersPropertyExplorer.prototype.hasProperty = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.get !== undefined || (descriptor.value instanceof Function) === false;
            }
            return false;
        };
        return MembersPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasPropertyExplorer = /** @class */ (function () {
        function PresetHasPropertyExplorer(expressionHasPropertyExplorer, objectHasPropertyExplorer) {
            this.expressionHasPropertyExplorer = expressionHasPropertyExplorer;
            this.objectHasPropertyExplorer = objectHasPropertyExplorer;
        }
        PresetHasPropertyExplorer.prototype.has = function (name, preset) {
            if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {
                return true;
            }
            return this.expressionHasPropertyExplorer.has(name, preset.target);
        };
        return PresetHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var ObjectHasPropertyExplorer = /** @class */ (function () {
        function ObjectHasPropertyExplorer() {
        }
        ObjectHasPropertyExplorer.prototype.has = function (name, target) {
            return Reflect.has(target, name) && (target[name] instanceof Function) === false;
        };
        return ObjectHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasInOperatorExplorer = /** @class */ (function () {
        function PresetHasInOperatorExplorer() {
        }
        PresetHasInOperatorExplorer.prototype.has = function (name, preset) {
            var isPlayable = preset.playable.isPlayable;
            if (isPlayable() === false) {
                return false;
            }
            if (preset.target instanceof ExpectedInOperatorExpression) {
                return preset.target.name === name;
            }
            if (preset.target instanceof It) {
                return preset.target.test(new InOperatorInteraction(name));
            }
            return false;
        };
        return PresetHasInOperatorExplorer;
    }());

    /**
     * @hidden
     */
    var PropertyDescriptorProvider = /** @class */ (function () {
        function PropertyDescriptorProvider() {
        }
        PropertyDescriptorProvider.prototype.get = function (target, name) {
            var prototype = target;
            while (prototype !== null) {
                var descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);
                if (descriptor !== undefined)
                    return descriptor;
                prototype = Reflect.getPrototypeOf(prototype);
            }
        };
        return PropertyDescriptorProvider;
    }());

    /**
     * @hidden
     */
    var REFLECT_HAS = new InjectionToken("Reflect has");

    var ɵ0$5 = Reflect.has;
    /**
     * @hidden
     */
    var typeExplorersProviders = [
        { provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: [] },
        {
            provide: HasMethodExplorer,
            useClass: HasMethodExplorer,
            deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]
        },
        { provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: [] },
        {
            provide: PresetHasMethodExplorer,
            useClass: PresetHasMethodExplorer,
            deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]
        },
        { provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: [] },
        {
            provide: HasPropertyExplorer,
            useClass: HasPropertyExplorer,
            deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]
        },
        { provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: [] },
        {
            provide: PresetHasPropertyExplorer,
            useClass: PresetHasPropertyExplorer,
            deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]
        },
        {
            provide: InOperatorInteractionExplorer,
            useClass: InOperatorInteractionExplorer,
            deps: [Presets, PresetHasInOperatorExplorer]
        },
        { provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: [] },
        {
            provide: MembersMethodExplorer,
            useClass: MembersMethodExplorer,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        {
            provide: PropertyIsReadOnlyTester,
            useClass: PropertyIsReadOnlyTester,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        {
            provide: MembersPropertyExplorer,
            useClass: MembersPropertyExplorer,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        { provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: [] },
        { provide: REFLECT_HAS, useValue: ɵ0$5, deps: [] },
    ];

    /**
     * @hidden
     */
    var MockOptionsBuilder = /** @class */ (function () {
        function MockOptionsBuilder() {
        }
        MockOptionsBuilder.prototype.build = function (options) {
            var target = (function () { return undefined; });
            return Object.assign({ target: target }, options);
        };
        return MockOptionsBuilder;
    }());

    /**
     * @hidden
     */
    function mockOptionsProviders(options) {
        return [
            { provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: [] },
            { provide: MOCK_OPTIONS, useFactory: function (builder) { return builder.build(options); }, deps: [MockOptionsBuilder] },
        ];
    }

    /**
     * Provides the default configuration for an angular based injector that would be used internally by {@link Mock} instance.
     */
    var DefaultInjectorConfig = /** @class */ (function () {
        function DefaultInjectorConfig() {
        }
        DefaultInjectorConfig.prototype.get = function (options, providers) {
            return __spread(providers, mockOptionsProviders(options), trackerProviders, reflectorProviders, presetsProviders, verificationProviders, interceptorsProviders, playablesProviders, interactionPlayersProviders, formattersProviders, expressionMatchersProviders, typeExplorersProviders);
        };
        return DefaultInjectorConfig;
    }());

    /**
     * The default implementation of {@link IMock} interface.
     */
    var Mock = /** @class */ (function () {
        function Mock(options) {
            if (options === void 0) { options = {}; }
            this.options = options;
            var preOptions = Object.assign(Object.assign({}, Mock.options), options);
            var provider = { provide: MOCK, useValue: this, deps: [] };
            var injector = injectorFactory(preOptions, provider);
            this.options = injector.get(MOCK_OPTIONS);
            this.tracker = injector.get(Tracker);
            this.expressionReflector = injector.get(ExpectedExpressionReflector);
            this.interceptor = injector.get(ProxyFactory);
            this.setupFactory = injector.get(PRESET_BUILDER_FACTORY);
            this.verifier = injector.get(Verifier);
            this.prototypeStorage = injector.get(PrototypeStorage);
        }
        Object.defineProperty(Mock, "options", {
            /**
             * The default mock options that would applied to all instantiating Mock objects.
             * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
             * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
             * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
             */
            get: function () {
                if (Mock.Options === undefined) {
                    Mock.Options = {
                        target: function () { return undefined; },
                        injectorConfig: new DefaultInjectorConfig()
                    };
                }
                return Mock.Options;
            },
            /**
             * The default mock options that would applied to all instantiating Mock objects.
             * If an options are passed as constructor parameter they will override the default options.
             */
            set: function (options) {
                Mock.Options = options;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mock.prototype, "name", {
            get: function () {
                return this.options.name;
            },
            enumerable: false,
            configurable: true
        });
        Mock.prototype.setup = function (expression) {
            var expectedExpression = this.expressionReflector.reflect(expression);
            return this.setupFactory(expectedExpression);
        };
        Mock.prototype.verify = function (expression, times) {
            times = times === undefined ? Times.Once() : times;
            var expressions = this.tracker.get().map(function (record) { return record.expression; });
            this.verifier.test(expression, times, expressions, this.name);
            return this;
        };
        Mock.prototype.object = function () {
            return this.interceptor.object();
        };
        Mock.prototype.prototypeof = function (prototype) {
            this.prototypeStorage.set(prototype);
            return this;
        };
        /**
         * @experimental
         */
        Mock.prototype.insequence = function (sequence, expression) {
            sequence.add(this, expression);
            return this;
        };
        return Mock;
    }());
    Mock.Options = undefined;

    /**
     * This function dumps into console.log all interactions with the mocked object
     */
    function dump(mock, writer) {
        if (writer === void 0) { writer = console; }
        var injector = injectorFactory(mock.options, { provide: MOCK, useValue: mock, deps: [] });
        var formatter = injector.get(TrackedExpressionsFormatter);
        var expressions = mock.tracker.get().map(function (record) { return record.expression; });
        var output = formatter.format(expressions);
        var delimiter = "-------------------------------";
        writer.log("Dump of " + (mock.name === undefined ? "noname mock" : mock.name));
        writer.log(delimiter);
        writer.log("\n" + output);
        writer.log(delimiter);
    }

    /**
     * @hidden
     */
    var EqualMatcher = /** @class */ (function () {
        function EqualMatcher(typesMatcher, commonTypeProvider, primitiveMatcher, objectMatcher, functionMatcher) {
            this.typesMatcher = typesMatcher;
            this.commonTypeProvider = commonTypeProvider;
            this.primitiveMatcher = primitiveMatcher;
            this.objectMatcher = objectMatcher;
            this.functionMatcher = functionMatcher;
        }
        EqualMatcher.prototype.matched = function (left, right) {
            if (this.typesMatcher.matched(left, right) === false) {
                return false;
            }
            switch (this.commonTypeProvider.ofType(left, right)) {
                case "undefined":
                    return this.primitiveMatcher.matched(left, right);
                case "object":
                    return this.objectMatcher.matched(left, right);
                case "boolean":
                    return this.primitiveMatcher.matched(left, right);
                case "number":
                    return this.primitiveMatcher.matched(left, right);
                case "string":
                    return this.primitiveMatcher.matched(left, right);
                case "function":
                    return this.functionMatcher.matched(left, right);
                case "symbol":
                    return this.primitiveMatcher.matched(left, right);
                case "bigint":
                    return this.primitiveMatcher.matched(left, right);
            }
        };
        return EqualMatcher;
    }());

    /**
     * @hidden
     */
    var EqualConstantMatcher = /** @class */ (function () {
        function EqualConstantMatcher(equalMatcher) {
            this.equalMatcher = equalMatcher;
        }
        EqualConstantMatcher.prototype.matched = function (left, right) {
            if (right instanceof It) {
                return right.test(left);
            }
            return this.equalMatcher.matched(left, right);
        };
        return EqualConstantMatcher;
    }());

    /**
     * @hidden
     */
    var CommonTypeProvider = /** @class */ (function () {
        function CommonTypeProvider() {
        }
        CommonTypeProvider.prototype.ofType = function (left, right) {
            return typeof left && typeof right;
        };
        return CommonTypeProvider;
    }());

    /**
     * @hidden
     */
    var TypesMatcher = /** @class */ (function () {
        function TypesMatcher() {
        }
        TypesMatcher.prototype.matched = function (left, right) {
            return typeof left === typeof right;
        };
        return TypesMatcher;
    }());

    /**
     * @hidden
     */
    var PrimitiveMatcher = /** @class */ (function () {
        function PrimitiveMatcher() {
        }
        PrimitiveMatcher.prototype.matched = function (left, right) {
            return left === right;
        };
        return PrimitiveMatcher;
    }());

    /**
     * @hidden
     */
    var ObjectMatcher = /** @class */ (function () {
        function ObjectMatcher(matchers) {
            this.matchers = matchers;
        }
        ObjectMatcher.prototype.matched = function (left, right) {
            var e_1, _a;
            if (left === null && right === null)
                return true;
            if (left === right)
                return true;
            try {
                for (var _b = __values(this.matchers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var matcher = _c.value;
                    var matched = matcher.matched(left, right);
                    if (matched === undefined) {
                        continue;
                    }
                    return matched;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        return ObjectMatcher;
    }());

    /**
     * @hidden
     */
    var FunctionMatcher = /** @class */ (function () {
        function FunctionMatcher() {
        }
        FunctionMatcher.prototype.matched = function (left, right) {
            return left === right;
        };
        return FunctionMatcher;
    }());

    /**
     * @hidden
     */
    var IterableTester = /** @class */ (function () {
        function IterableTester() {
        }
        IterableTester.prototype.verify = function (left, right) {
            return typeof left[Symbol.iterator] === "function" && typeof right[Symbol.iterator] === "function";
        };
        return IterableTester;
    }());

    /**
     * Matches objects that support Iterable protocol
     */
    var IteratorMatcher = /** @class */ (function () {
        function IteratorMatcher(injector, iterableTester) {
            this.injector = injector;
            this.iterableTester = iterableTester;
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        IteratorMatcher.prototype.matched = function (left, right) {
            if (this.iterableTester.verify(left, right) === true) {
                var leftIterator = __spread(left[Symbol.iterator]());
                var rightIterator = __spread(right[Symbol.iterator]());
                if (leftIterator.length !== rightIterator.length)
                    return false;
                var constantMatcher = this.injector.get(ConstantMatcher);
                for (var i = 0; i < leftIterator.length; i++) {
                    var leftValue = leftIterator[i];
                    var rightValue = rightIterator[i];
                    if (constantMatcher.matched(leftValue, rightValue) === false) {
                        return false;
                    }
                }
                return true;
            }
            return undefined;
        };
        return IteratorMatcher;
    }());

    var OBJECT_MATCHERS = new InjectionToken("OBJECT_MATCHERS");

    /**
     * Matches objects as POJO
     */
    var POJOMatcher = /** @class */ (function () {
        function POJOMatcher(mapMatcher, objectMapProvider) {
            this.mapMatcher = mapMatcher;
            this.objectMapProvider = objectMapProvider;
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        POJOMatcher.prototype.matched = function (left, right) {
            var leftProps = this.objectMapProvider.get(left);
            var rightProps = this.objectMapProvider.get(right);
            return this.mapMatcher.matched(leftProps, rightProps);
        };
        return POJOMatcher;
    }());

    /**
     * @hidden
     */
    var ObjectMapProvider = /** @class */ (function () {
        function ObjectMapProvider() {
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        ObjectMapProvider.prototype.get = function (object) {
            var e_1, _a;
            var props = this.getProps(object, []);
            var keys = __spread(new Set(props));
            var map = new Map();
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    map.set(key, object[key]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return map;
        };
        ObjectMapProvider.prototype.getProps = function (object, props) {
            if (object === null)
                return props;
            if (object === Object.prototype)
                return props;
            props = __spread(props, Object.getOwnPropertyNames(object), Object.getOwnPropertySymbols(object));
            return this.getProps(Object.getPrototypeOf(object), props);
        };
        return ObjectMapProvider;
    }());

    /**
     * Matches Map objects
     */
    var MapMatcher = /** @class */ (function () {
        function MapMatcher(injector) {
            this.injector = injector;
        }
        MapMatcher.prototype.matched = function (left, right) {
            var e_1, _a;
            if (left instanceof Map && right instanceof Map) {
                if (left.size !== right.size)
                    return false;
                var constantMatcher = this.injector.get(ConstantMatcher);
                try {
                    for (var left_1 = __values(left), left_1_1 = left_1.next(); !left_1_1.done; left_1_1 = left_1.next()) {
                        var _b = __read(left_1_1.value, 2), key = _b[0], value = _b[1];
                        if (right.has(key) === false)
                            return false;
                        if (constantMatcher.matched(value, right.get(key)) === false)
                            return false;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (left_1_1 && !left_1_1.done && (_a = left_1.return)) _a.call(left_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return true;
            }
            return undefined;
        };
        return MapMatcher;
    }());

    /**
     * @hidden
     */
    var equalMatchersProviders = [
        { provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: [] },
        { provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [EqualMatcher] },
        { provide: ConstantMatcher, useExisting: EqualConstantMatcher },
        {
            provide: EqualMatcher, useClass: EqualMatcher, deps: [
                TypesMatcher,
                CommonTypeProvider,
                PrimitiveMatcher,
                ObjectMatcher,
                FunctionMatcher
            ]
        },
        { provide: FunctionMatcher, useClass: FunctionMatcher, deps: [] },
        { provide: IterableTester, useClass: IterableTester, deps: [] },
        {
            provide: IteratorMatcher, useClass: IteratorMatcher, deps: [
                Injector,
                IterableTester
            ]
        },
        { provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS] },
        { provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider] },
        { provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: [] },
        { provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: [] },
        { provide: TypesMatcher, useClass: TypesMatcher, deps: [] },
        { provide: MapMatcher, useClass: MapMatcher, deps: [Injector] },
    ];

    /**
     * Matches Date objects
     */
    var DateMatcher = /** @class */ (function () {
        function DateMatcher() {
        }
        DateMatcher.prototype.matched = function (left, right) {
            if (left instanceof Date && right instanceof Date) {
                return left.valueOf() === right.valueOf();
            }
            return undefined;
        };
        return DateMatcher;
    }());

    /**
     * Provides the configuration for Angular based injector that would use equal logic for matching values.
     * By default, all values are matched with
     * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
     * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
     * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
     * and introduce deep equal comparison logic as well as an extension point for custom matchers.
     *
     * ```typescript
     *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
     *
     *  const mock = new Mock<(args: number[]) => number>()
     *  .setup(instance => instance([2, 1]))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object([2, 1]);
     *
     *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
     *  expect(actual).toBe(undefined);
     *  ```
     *  and compare with
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
     *
     *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
     *  .setup(instance => instance([2, 1]))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object([2, 1]);
     *
     *  expect(actual).toBe(2);
     *  ```
     *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
     *
     *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
     *  then more general matchers would be invoked.
     *
     *  The library comes with the following matchers:
     *  0. Custom matchers
     *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
     *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
     *  3. IteratorMatcher - matches objects that supports
     *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
     *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
     *
     *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
     *  import { isMoment, utc } from "moment";
     *
     *  class MomentDateMatcher implements IObjectMatcher {
     *     matched<T extends object>(left: T, right: T): boolean | undefined {
     *         if (left instanceof Date && isMoment(right)) {
     *             return left.valueOf() === right.valueOf();
     *         }
     *         return undefined;
     *     }
     * }
     *
     *  const moment = utc(1);
     *  const injectorConfig = new EqualMatchingInjectorConfig([{
     *     provide: OBJECT_MATCHERS,
     *     useClass: MomentDateMatcher,
     *     multi: true,
     *     deps: []
     * }]);
     *
     *  const mock = new Mock<(args: any) => number>({injectorConfig})
     *  .setup(instance => instance(moment))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object(new Date(1));
     *
     *  expect(actual).toBe(2);
     *  ```
     *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
     *  So you can do a partial comparision.
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
     *
     *  const func = () => undefined;
     *
     *  const injectorConfig = new EqualMatchingInjectorConfig();
     *  const mock = new Mock<(args: any) => number>({injectorConfig})
     *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object({func});
     *
     *  expect(actual).toBe(2);
     *  ```
     */
    var EqualMatchingInjectorConfig = /** @class */ (function (_super) {
        __extends(EqualMatchingInjectorConfig, _super);
        function EqualMatchingInjectorConfig(matchers) {
            if (matchers === void 0) { matchers = []; }
            var _this = _super.call(this) || this;
            _this.matchers = matchers;
            return _this;
        }
        EqualMatchingInjectorConfig.prototype.get = function (options, providers) {
            return __spread(_super.prototype.get.call(this, options, providers), equalMatchersProviders, this.matchers, [
                { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] },
            ]);
        };
        return EqualMatchingInjectorConfig;
    }(DefaultInjectorConfig));

    /*
     * Public API Surface of moq.ts
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DefaultInjectorConfig = DefaultInjectorConfig;
    exports.EqualMatchingInjectorConfig = EqualMatchingInjectorConfig;
    exports.ExpectedGetPropertyExpression = ExpectedGetPropertyExpression;
    exports.ExpectedInOperatorExpression = ExpectedInOperatorExpression;
    exports.ExpectedMethodExpression = ExpectedMethodExpression;
    exports.ExpectedNamedMethodExpression = ExpectedNamedMethodExpression;
    exports.ExpectedSetPropertyExpression = ExpectedSetPropertyExpression;
    exports.GetPropertyInteraction = GetPropertyInteraction;
    exports.Host = Host;
    exports.INJECTOR = INJECTOR;
    exports.InOperatorInteraction = InOperatorInteraction;
    exports.InjectionToken = InjectionToken;
    exports.Injector = Injector;
    exports.Interaction = Interaction;
    exports.It = It;
    exports.MOCK = MOCK;
    exports.MOCK_OPTIONS = MOCK_OPTIONS;
    exports.MethodInteraction = MethodInteraction;
    exports.Mock = Mock;
    exports.MoqAPI = MoqAPI;
    exports.NamedMethodInteraction = NamedMethodInteraction;
    exports.NullInjector = NullInjector;
    exports.OBJECT_MATCHERS = OBJECT_MATCHERS;
    exports.Optional = Optional;
    exports.PlayTimes = PlayTimes;
    exports.PlayableAlways = PlayableAlways;
    exports.PlayableExactly = PlayableExactly;
    exports.PlayableNever = PlayableNever;
    exports.PlayableOnce = PlayableOnce;
    exports.PlayableSequence = PlayableSequence;
    exports.Self = Self;
    exports.SetPropertyInteraction = SetPropertyInteraction;
    exports.SkipSelf = SkipSelf;
    exports.Times = Times;
    exports.dump = dump;
    exports.forwardRef = forwardRef;
    exports.getClosureSafeProperty = getClosureSafeProperty;
    exports.injectorFactory = injectorFactory;
    exports.isForwardRef = isForwardRef;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=moq.ts.umd.js.map
