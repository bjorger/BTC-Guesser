{"version":3,"sources":["../../projects/moq/src/lib/equal-matchers/common-type.provider.ts","../../projects/moq/src/lib/equal-matchers/date.matcher.ts","../../projects/moq/src/lib/expected-expressions/expression-predicates.ts","../../projects/moq/src/lib/equal-matchers/equal-constant.matcher.ts","../../projects/moq/src/lib/equal-matchers/equal.matcher.ts","../../projects/moq/src/lib/equal-matchers/types.matcher.ts","../../projects/moq/src/lib/equal-matchers/primitive.matcher.ts","../../../node_modules/tslib/tslib.es6.js","../../projects/moq/src/lib/equal-matchers/object.matcher.ts","../../projects/moq/src/lib/equal-matchers/function.matcher.ts","../../projects/moq/src/lib/equal-matchers/iterable.tester.ts","../../projects/moq/src/lib/expression-matchers/constant.matcher.ts","../../projects/moq/src/lib/equal-matchers/iterator.matcher.ts","../../projects/moq/src/lib/static.injector/injection_token.ts","../../projects/moq/src/lib/equal-matchers/object-matchers.injection-token.ts","../../projects/moq/src/lib/equal-matchers/pojo.matcher.ts","../../projects/moq/src/lib/equal-matchers/object-map.provider.ts","../../projects/moq/src/lib/equal-matchers/map.matcher.ts","../../projects/moq/src/lib/static.injector/stringify.ts","../../projects/moq/src/lib/static.injector/property.ts","../../projects/moq/src/lib/static.injector/forward_ref.ts","../../projects/moq/src/lib/static.injector/injector_compatibility.ts","../projects/moq/src/lib/static.injector/interface/injector.ts","../../projects/moq/src/lib/static.injector/metadata.ts","../../projects/moq/src/lib/static.injector/injector.ts","../../projects/moq/src/lib/equal-matchers/equal-matchers.providers.ts","../../../projects/moq/src/lib/interactions.ts","../../projects/moq/src/lib/expected-expressions/expected-expressions.ts","../../projects/moq/src/lib/expected-expressions/expected-expression-reflector.ts","../../projects/moq/src/lib/expected-expressions/reflector.providers.ts","../../projects/moq/src/lib/explorers/reflect-has.injection-token.ts","../projects/moq/src/lib/explorers/has-method.explorer/expression.has-method.explorer.ts","../projects/moq/src/lib/explorers/has-method.explorer/has-method.explorer.ts","../../projects/moq/src/lib/presets/presets.ts","../projects/moq/src/lib/explorers/members.explorer/members-method.explorer.ts","../projects/moq/src/lib/presets/presets/mimics.preset.ts","../projects/moq/src/lib/explorers/has-method.explorer/preset.has-method.explorer.ts","../projects/moq/src/lib/explorers/has-method.explorer/object.has-method.explorer.ts","../projects/moq/src/lib/explorers/has-property.explorer/expression-has-property.explorer.ts","../projects/moq/src/lib/explorers/has-property.explorer/has-property.explorer.ts","../projects/moq/src/lib/explorers/members.explorer/members-property.explorer.ts","../projects/moq/src/lib/explorers/has-property.explorer/preset-has-property.explorer.ts","../projects/moq/src/lib/explorers/has-property.explorer/object-has-property.explorer.ts","../projects/moq/src/lib/explorers/in-operator-interaction.explorer/in-operator-interaction.explorer.ts","../projects/moq/src/lib/explorers/in-operator-interaction.explorer/preset.has-in-operator.explorer.ts","../../projects/moq/src/lib/interceptors/prototype.storage.ts","../projects/moq/src/lib/explorers/members.explorer/property-descriptor.provider.ts","../projects/moq/src/lib/explorers/has-property.explorer/property-is-read-only.tester.ts","../../projects/moq/src/lib/explorers/type-explorers.providers.ts","../../projects/moq/src/lib/expression-matchers/arguments.matcher.ts","../../projects/moq/src/lib/expression-matchers/set-property.matcher.ts","../../projects/moq/src/lib/expression-matchers/instance-method.matcher.ts","../../projects/moq/src/lib/expression-matchers/method.matcher.ts","../../projects/moq/src/lib/expression-matchers/in-operator.matcher.ts","../../projects/moq/src/lib/expression-matchers/get-property.matcher.ts","../../projects/moq/src/lib/expression-matchers/expression.matcher.ts","../../projects/moq/src/lib/expression-matchers/expression-matchers.providers.ts","../../projects/moq/src/lib/formatters/constant-formatter.ts","../../projects/moq/src/lib/formatters/expected-expression-formatter.ts","../../projects/moq/src/lib/formatters/expression-formatter.ts","../../projects/moq/src/lib/formatters/verify-formatter.ts","../../projects/moq/src/lib/formatters/tracked-expressions-formatter.ts","../../projects/moq/src/lib/formatters/set.property-formatter.ts","../../projects/moq/src/lib/formatters/property-key.formatter.ts","../../projects/moq/src/lib/formatters/named.method-formatter.ts","../../projects/moq/src/lib/formatters/method-formatter.ts","../../projects/moq/src/lib/formatters/in-operator.formatter.ts","../../projects/moq/src/lib/formatters/get.property-formatter.ts","../../projects/moq/src/lib/formatters/formatters.providers.ts","../../projects/moq/src/lib/interaction-players/callback-preset.player.ts","../projects/moq/src/lib/presets/presets/returns.preset.ts","../projects/moq/src/lib/presets/presets/callbacks.preset.ts","../projects/moq/src/lib/presets/presets/throws.preset.ts","../../projects/moq/src/lib/interaction-players/preset.player.ts","../../projects/moq/src/lib/interaction-players/mimics-preset.player.ts","../../projects/moq/src/lib/interaction-players/playable-preset.provider.ts","../../projects/moq/src/lib/interaction-players/interaction.player.ts","../../projects/moq/src/lib/playables/preset-playables.updater.ts","../../projects/moq/src/lib/interaction-players/reflect-apply.injection-token.ts","../../projects/moq/src/lib/interaction-players/interaction-players.providers.ts","../../projects/moq/src/lib/interceptors/apply.trap.ts","../../projects/moq/src/lib/interceptors/get-prototype-of.trap.ts","../../../projects/moq/src/lib/moq.ts","../../projects/moq/src/lib/interceptors/get.trap.ts","../../projects/moq/src/lib/interceptors/has.trap.ts","../../projects/moq/src/lib/tracker/tracker.ts","../../projects/moq/src/lib/interceptors/properties-value.storage.ts","../../projects/moq/src/lib/interceptors/spy-function.provider.ts","../../projects/moq/src/lib/interceptors/set.trap.ts","../../projects/moq/src/lib/interceptors/set-prototype-of.trap.ts","../../projects/moq/src/lib/interceptors/proxy.factory.ts","../../projects/moq/src/lib/injector/moq.injection-token.ts","../../projects/moq/src/lib/mock-options/mock-options.injection-token.ts","../../projects/moq/src/lib/interceptors/interceptors.providers.ts","../../projects/moq/src/lib/mock-options/mock-options.builder.ts","../../projects/moq/src/lib/playables/playables.providers.ts","../../projects/moq/src/lib/presets/preset-builder-factory.injection-token.ts","../../projects/moq/src/lib/playables/playable-exactly.ts","../../projects/moq/src/lib/playables/playable-never.ts","../../projects/moq/src/lib/playables/playable-once.ts","../../projects/moq/src/lib/playables/playable-always.ts","../../projects/moq/src/lib/playables/playable-sequence.ts","../../projects/moq/src/lib/playables/play-times.ts","../../projects/moq/src/lib/presets/preset-builder.ts","../../projects/moq/src/lib/presets/presets.providers.ts","../../projects/moq/src/lib/static.injector/type.ts","../../projects/moq/src/lib/tracker/sequence-id.ts","../../projects/moq/src/lib/tracker/tracker.providers.ts","../../projects/moq/src/lib/verification/call-counter.ts","../../projects/moq/src/lib/verification/verify-error.ts","../../projects/moq/src/lib/verification/verifier.ts","../../projects/moq/src/lib/verification/verification.providers.ts","../../projects/moq/src/lib/mock-options/mock-options.providers.ts"],"names":["CommonTypeProvider","prototype","ofType","left","right","DateMatcher","matched","Date","valueOf","It","predicate","this","Is","IsAny","test","instance","result","undefined","e","EqualConstantMatcher","equalMatcher","EqualMatcher","typesMatcher","commonTypeProvider","primitiveMatcher","objectMatcher","functionMatcher","TypesMatcher","PrimitiveMatcher","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","__extends","__","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","__read","n","r","ar","push","error","__spread","arguments","concat","ObjectMatcher","matchers","_b","_c","FunctionMatcher","IterableTester","verify","ConstantMatcher","IteratorMatcher","injector","iterableTester","leftIterator","rightIterator","constantMatcher","get","leftValue","rightValue","InjectionToken","desc","toString","OBJECT_MATCHERS","POJOMatcher","mapMatcher","objectMapProvider","leftProps","rightProps","ObjectMapProvider","object","props","getProps","keys","Set","map","Map","keys_1","keys_1_1","key","set","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","MapMatcher","size","left_1","left_1_1","has","stringify","token","isArray","join","overriddenName","name","res","newLineIndex","indexOf","substring","getClosureSafeProperty","objWithPropertyToExtract","Error","__forward_ref__","forwardRef","forwardRefFn","resolveForwardRef","type","fn","InjectFlags","INJECTOR","THROW_IF_NOT_FOUND","NEW_LINE","SOURCE","USE_VALUE","provide","String","useValue","NullInjector","notFoundValue","formatError","text","obj","injectorErrorName","source","charAt","substr","context","parts","JSON","replace","Optional","Self","SkipSelf","INJECTOR_IMPL","providers","parent","StaticInjector","Injector","options","NULL","__NG_ELEMENT_ID__","IDENT","EMPTY","CIRCULAR","MULTI_PROVIDER_FN","slice","records","_records","deps","useNew","scope","recursivelyProcessProviders","flags","Default","record","tryResolveToken","tokenPath","unshift","message","catchInjectorError","tokens","forEach","v","resolveProvider","provider","providerDeps","j","annotations","annotation","useExisting","staticError","computeDeps","useFactory","useClass","multiProviderMixError","resolvedProvider","multi","multiProvider","NO_NEW_LINE","depRecords","depRecord","childRecord","bind","apply","resolveToken","equalMatchersProviders","Interaction","args","NamedMethodInteraction","_super","MethodInteraction","GetPropertyInteraction","SetPropertyInteraction","_this","InOperatorInteraction","ExpectedNamedMethodExpression","ExpectedMethodExpression","ExpectedGetPropertyExpression","ExpectedSetPropertyExpression","ExpectedInOperatorExpression","ExpectedExpressionReflector","reflect","expression","reflectedInfo","expressionProxy","Proxy","target","_i","thisArg","reflectorProviders","REFLECT_HAS","ExpressionHasMethodExplorer","HasMethodExplorer","presets","membersExplorer","explorer","hasMethod","find","preset","Presets","add","MembersMethodExplorer","storage","propertyDescriptorProvider","Function","playable","origin","PresetHasMethodExplorer","expressionHasMethodExplorer","objectHasMethodExplorer","MimicsPreset","ObjectHasMethodExplorer","ExpressionHasPropertyExplorer","HasPropertyExplorer","hasProperty","MembersPropertyExplorer","descriptor","PresetHasPropertyExplorer","expressionHasPropertyExplorer","objectHasPropertyExplorer","ObjectHasPropertyExplorer","Reflect","InOperatorInteractionExplorer","PresetHasInOperatorExplorer","isPlayable","PrototypeStorage","mockTarget","_a","PropertyDescriptorProvider","getOwnPropertyDescriptor","PropertyIsReadOnlyTester","isReadOnly","writable","typeExplorersProviders","ɵ0$2","ArgumentsMatcher","lvalue","rvalue","SetPropertyExpressionMatcher","rightExpression","NamedMethodExpressionMatcher","argumentsMatcher","MethodExpressionMatcher","InOperatorMatcher","GetPropertyExpressionMatcher","ExpressionMatcher","getPropertyExpressionMatcher","setPropertyExpressionMatcher","methodExpressionMatcher","namedMethodExpressionMatcher","inOperatorExpressionMatcher","expressionMatchersProviders","ConstantFormatter","format","description","index","ExpectedExpressionFormatter","expressionFormatter","expected","timesMessage","haveBeenCalledTimes","mockName","toLowerCase","ExpressionFormatter","getPropertyFormatter","setPropertyFormatter","methodFormatter","namedMethodFormatter","constantFormatter","inOperatorFormatter","VerifyFormatter","expectedExpressionFormatter","trackedExpressionsFormatter","trackedExpressions","delimiter","TrackedExpressionsFormatter","trackedExpressions_1","trackedExpressions_1_1","SetPropertyExpressionFormatter","propertyKeyFormatter","PropertyKeyFormatter","property","NamedMethodExpressionFormatter","formatted","arg","MethodExpressionFormatter","InOperatorFormatter","GetPropertyExpressionFormatter","formattersProviders","CallbackPresetPlayer","play","callback","interaction","exception","PresetPlayer","callbackPresetPlayer","mimicsPresetPlayer","ReturnsPreset","CallbacksPreset","ThrowsPreset","MimicsPresetPlayer","method","PlayablePresetProvider","matcher","InteractionPlayer","playablePresetProvider","presetPlayablesUpdater","presetPlayer","update","PresetPlayablesUpdater","REFLECT_APPLY","interactionPlayersProviders","ApplyTrap","tracker","interactionPlayer","intercept","argArray","GetPrototypeOfTrap","prototypeStorage","MoqAPI","GetTrap","mock","propertiesValueStorage","hasPropertyExplorer","hasMethodExplorer","spyFunctionProvider","HasTrap","inOperatorInteractionExplorer","Tracker","sequenceId","log","action","id","PropertiesValueStorage","SpyFunctionProvider","SetTrap","propertyIsReadOnlyTester","accepted","SetPrototypeOfTrap","ProxyFactory","getTrap","setTrap","hasTrap","applyTrap","getPrototypeOfTrap","setPrototypeOfTrap","_proxy","createObject","MOCK","MOCK_OPTIONS","interceptorsProviders","MockOptionsBuilder","build","assign","playablesProviders","PRESET_BUILDER_FACTORY","PlayableExactly","count","invoked","reason","PlayableNever","PlayableOnce","played","PlayableAlways","PlayableSequence","sequence","PlayTimes","Exactly","Always","always","Never","never","Once","Sequence","PresetBuilder","mimics","returns","throws","presetsProviders","Type","SequenceId","trackerProviders","CallCounter","expressionMatcher","expressions","expressions_1","expressions_1_1","VerifyError","Verifier","reflector","callCounter","verifyFormatter","times","callCount","verificationProviders","builder"],"mappings":"kUAGA,SAAAA,YACWA,EAAAC,UAAAC,OAAA,SAAOC,EAAeC,GACzB,cAAcD,UAAeC,qBCArC,SAAAC,YACWA,EAAAJ,UAAAK,QAAA,SAAkBH,EAASC,GAC9B,GAAID,aAAgBI,MAAQH,aAAiBG,KACzC,OAAOJ,EAAKK,YAAcJ,EAAMI,gBC4C5CC,EAAA,WACI,SAAAA,EAAmBC,GAAAC,KAAAD,UAAAA,SAqBLD,EAAAG,GAAP,SAAaF,GAChB,OAAO,IAAID,EAAGC,IAoBJD,EAAAI,MAAP,WACH,OAAO,IAAIJ,GAAG,WAAM,OAAA,MAMjBA,EAAAR,UAAAa,KAAA,SAAKC,GACR,IACI,IAAMC,EAASL,KAAKD,UAAUK,GAC9B,OAAkB,IAAXC,QAA8BC,IAAXD,EAC5B,MAAOE,GACL,OAAO,MAvDnB,gBC7CI,SAAAC,EAAoBC,GAAAT,KAAAS,aAAAA,SAGbD,EAAAlB,UAAAK,QAAA,SAAQH,EAAWC,GACtB,OAAIA,aAAiBK,EACTL,EAAkBU,KAAKX,GAE5BQ,KAAKS,aAAad,QAAQH,EAAMC,sBCH3C,SAAAiB,EACYC,EACAC,EACAC,EACAC,EACAC,GAJAf,KAAAW,aAAAA,EACAX,KAAAY,mBAAAA,EACAZ,KAAAa,iBAAAA,EACAb,KAAAc,cAAAA,EACAd,KAAAe,gBAAAA,SAGLL,EAAApB,UAAAK,QAAA,SAAQH,EAAWC,GACtB,IAA+C,IAA3CO,KAAKW,aAAahB,QAAQH,EAAMC,GAChC,OAAO,EAGX,OAAQO,KAAKY,mBAAmBrB,OAAOC,EAAMC,IACzC,IAAK,YACD,OAAOO,KAAKa,iBAAiBlB,QAAQH,EAAMC,GAC/C,IAAK,SACD,OAAOO,KAAKc,cAAcnB,QAAQH,EAAMC,GAC5C,IAAK,UAEL,IAAK,SAEL,IAAK,SACD,OAAOO,KAAKa,iBAAiBlB,QAAQH,EAAMC,GAC/C,IAAK,WACD,OAAOO,KAAKe,gBAAgBpB,QAAQH,EAAMC,GAC9C,IAAK,SAEL,IAAK,SACD,OAAOO,KAAKa,iBAAiBlB,QAAQH,EAAMC,uBCrC3D,SAAAuB,YAEWA,EAAA1B,UAAAK,QAAA,SAAQH,EAAeC,GAC1B,cAAcD,UAAgBC,qBCHtC,SAAAwB,YAEWA,EAAA3B,UAAAK,QAAA,SAAiEH,EAASC,GAC7E,OAAOD,IAASC,QCUpByB,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAO/B,UAAUoC,eAAeC,KAAKP,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,MAC3EN,EAAGC,aAGZQ,EAAUT,EAAGC,GAEzB,SAASS,IAAO7B,KAAK8B,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAE7B,UAAkB,OAAN8B,EAAaC,OAAOU,OAAOX,IAAMS,EAAGvC,UAAY8B,EAAE9B,UAAW,IAAIuC,GA+EtDR,OAAOU,gBAYpBC,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBA,OAAOC,SAAUC,EAAIH,GAAKD,EAAEC,GAAII,EAAI,EAC5E,GAAID,EAAG,OAAOA,EAAEV,KAAKM,GACrB,GAAIA,GAAyB,iBAAbA,EAAEM,OAAqB,MAAO,CAC1CC,KAAM,WAEF,OADIP,GAAKK,GAAKL,EAAEM,SAAQN,OAAI,GACrB,CAAEQ,MAAOR,GAAKA,EAAEK,KAAMI,MAAOT,KAG5C,MAAM,IAAIU,UAAUT,EAAI,0BAA4B,4CAGxCU,EAAOX,EAAGY,GACtB,IAAIR,EAAsB,mBAAXF,QAAyBF,EAAEE,OAAOC,UACjD,IAAKC,EAAG,OAAOJ,EACf,IAAmBa,EAAYvC,EAA3B+B,EAAID,EAAEV,KAAKM,GAAOc,EAAK,GAC3B,IACI,WAAc,IAANF,GAAgBA,KAAM,MAAQC,EAAIR,EAAEE,QAAQE,MAAMK,EAAGC,KAAKF,EAAEL,OAExE,MAAOQ,GAAS1C,EAAI,CAAE0C,MAAOA,WAEzB,IACQH,IAAMA,EAAEJ,OAASL,EAAIC,EAAU,SAAID,EAAEV,KAAKW,WAExC,GAAI/B,EAAG,MAAMA,EAAE0C,OAE7B,OAAOF,WAGKG,IACZ,IAAK,IAAIH,EAAK,GAAIT,EAAI,EAAGA,EAAIa,UAAUZ,OAAQD,IAC3CS,EAAKA,EAAGK,OAAOR,EAAOO,UAAUb,KACpC,OAAOS,EA8Cc1B,OAAOU,wBC3L5B,SAAAsB,EACYC,GAAAtD,KAAAsD,SAAAA,SAGLD,EAAA/D,UAAAK,QAAA,SAA2CH,EAASC,WACvD,GAAa,OAATD,GAA2B,OAAVC,EAAgB,OAAO,EAC5C,GAAID,IAASC,EAAO,OAAO,MAC3B,IAAsB,IAAA8D,EAAAvB,EAAAhC,KAAKsD,UAAQE,EAAAD,EAAAf,QAAAgB,EAAAd,KAAAc,EAAAD,EAAAf,OAAE,CAAhC,IACK7C,EADQ6D,EAAAf,MACU9C,QAAQH,EAAMC,GACtC,QAAgBa,IAAZX,EAGJ,OAAOA,oGAGX,OAAO,qBCpBf,SAAA8D,YAEWA,EAAAnE,UAAAK,QAAA,SAAwCH,EAASC,GACpD,OAAOD,IAASC,qBCHxB,SAAAiE,YAEWA,EAAApE,UAAAqE,OAAA,SAAOnE,EAAeC,GACzB,MAAwC,mBAA1BD,EAAK2C,OAAOC,WAA8D,mBAA3B3C,EAAM0C,OAAOC,6BCDlF,SAAAwB,YACWA,EAAAtE,UAAAK,QAAA,SAAQH,EAAWC,GACtB,OAAIA,aAAiBK,EACTL,EAAkBU,KAAKX,GAE5BA,IAASC,qBCApB,SAAAoE,EACYC,EACAC,GADA/D,KAAA8D,SAAAA,EACA9D,KAAA+D,eAAAA,SAILF,EAAAvE,UAAAK,QAAA,SAA0BH,EAASC,GACtC,IAAgD,IAA5CO,KAAK+D,eAAeJ,OAAOnE,EAAMC,GAAiB,CAClD,IAAMuE,EAAYd,EAAO1D,EAAK2C,OAAOC,aAC/B6B,EAAaf,EAAOzD,EAAM0C,OAAOC,aACvC,GAAI4B,EAAazB,SAAW0B,EAAc1B,OAAQ,OAAO,EAGzD,IADA,IAAM2B,EAAkBlE,KAAK8D,SAASK,IAAIP,GACjCtB,EAAI,EAAGA,EAAI0B,EAAazB,OAAQD,IAAK,CAC1C,IAAM8B,EAAYJ,EAAa1B,GACzB+B,EAAaJ,EAAc3B,GACjC,IAAuD,IAAnD4B,EAAgBvE,QAAQyE,EAAWC,GACnC,OAAO,EAIf,OAAO,sBCtBf,SAAAC,EAAsBC,GAAAvE,KAAAuE,KAAAA,SAGtBD,EAAAhF,UAAAkF,SAAA,WACI,MAAO,kBAAkBxE,KAAKuE,WCVzBE,EAAkB,IAAIH,EAAiC,gCCKhE,SAAAI,EACYC,EACAC,GADA5E,KAAA2E,WAAAA,EACA3E,KAAA4E,kBAAAA,SAILF,EAAApF,UAAAK,QAAA,SAA0BH,EAASC,GACtC,IAAMoF,EAAY7E,KAAK4E,kBAAkBT,IAAI3E,GACvCsF,EAAa9E,KAAK4E,kBAAkBT,IAAI1E,GAC9C,OAAOO,KAAK2E,WAAWhF,QAAQkF,EAAWC,sBCdlD,SAAAC,YAEIA,EAAAzF,UAAA6E,IAAA,SAAIa,WACMC,EAAQjF,KAAKkF,SAASF,EAAQ,IAC9BG,EAAIjC,EAAO,IAAIkC,IAAiBH,IAChCI,EAAM,IAAIC,QAChB,IAAkB,IAAAC,EAAAvD,EAAAmD,GAAIK,EAAAD,EAAA/C,QAAAgD,EAAA9C,KAAA8C,EAAAD,EAAA/C,OAAE,CAAnB,IAAMiD,EAAGD,EAAA/C,MACV4C,EAAIK,IAAID,EAAKT,EAAOS,sGAGxB,OAAOJ,GAGHN,EAAAzF,UAAA4F,SAAA,SAASF,EAAQC,GACrB,OAAe,OAAXD,GACAA,IAAW3D,OAAO/B,UADM2F,GAE5BA,EAAK/B,EAAO+B,EAAU5D,OAAOsE,oBAAoBX,GAAY3D,OAAOuE,sBAAsBZ,IACnFhF,KAAKkF,SAAS7D,OAAOwE,eAAeb,GAASC,uBCZxD,SAAAa,EAAoBhC,GAAA9D,KAAA8D,SAAAA,SAGbgC,EAAAxG,UAAAK,QAAA,SAAmCH,EAASC,WAC/C,GAAID,aAAgB8F,KAAO7F,aAAiB6F,IAAK,CAC7C,GAAI9F,EAAKuG,OAAStG,EAAMsG,KAAM,OAAO,EACrC,IAAM7B,EAAkBlE,KAAK8D,SAASK,IAAIP,OAC1C,IAA2B,IAAAoC,EAAAhE,EAAAxC,GAAIyG,EAAAD,EAAAxD,QAAAyD,EAAAvD,KAAAuD,EAAAD,EAAAxD,OAAE,CAAtB,IAAAe,EAAAX,EAAAqD,EAAAxD,MAAA,GAACgD,EAAGlC,EAAA,GAAEd,EAAKc,EAAA,GAClB,IAAuB,IAAnB9D,EAAMyG,IAAIT,GAAgB,OAAO,EACrC,IAAuD,IAAnDvB,EAAgBvE,QAAQ8C,EAAOhD,EAAM0E,IAAIsB,IAAiB,OAAO,oGAEzE,OAAO;;;;;;;;SCXHU,EAAUC,GACtB,GAAqB,iBAAVA,EACP,OAAOA,EAGX,GAAI5E,MAAM6E,QAAQD,GACd,MAAO,IAAIA,EAAMf,IAAIc,GAAWG,KAAK,MAAK,IAG9C,GAAa,MAATF,EACA,MAAO,GAAKA,EAGhB,GAAIA,EAAMG,eACN,MAAO,GAAGH,EAAMG,eAGpB,GAAIH,EAAMI,KACN,MAAO,GAAGJ,EAAMI,KAGpB,IAAMC,EAAML,EAAM5B,WAElB,GAAW,MAAPiC,EACA,MAAO,GAAKA,EAGhB,IAAMC,EAAeD,EAAIE,QAAQ,MACjC,OAAyB,IAAlBD,EAAsBD,EAAMA,EAAIG,UAAU,EAAGF;;;;;;;gBC5BxCG,EAA0BC,GACxC,IAAK,IAAMrB,KAAOqB,EAChB,GAAIA,EAAyBrB,KAASoB,EACpC,OAAOpB,EAGX,MAAMsB,MAAM,qDCYd,IAAMC,EAAkBH,EAAuB,CAACG,gBAAiBH,aAcjDI,EAAWC,GAKvB,OAJMA,EAAcF,gBAAkBC,EAChCC,EAAc1C,SAAW,WAC3B,OAAO2B,EAAUnG,SAEGkH,WAgBZC,EAAqBC,GACjC,MAKqB,mBADIC,EAJLD,IAKeC,EAAG3F,eAAesF,IACjDK,EAAGL,kBAAoBC,EANCG,IAASA,MAIZC,EC3CtB,ICTKC,EDSCC,EAAW,IAAIjD,EACxB,YAISkD,EADe,GAKtBC,EAAW,OAEJC,EAAS,WAETC,EACTd,EAAsC,CAACe,QAASC,OAAQC,SAAUjB,iBAEtE,SAAAkB,YACIA,EAAAzI,UAAA6E,IAAA,SAAIiC,EAAY4B,GACZ,QADY,IAAAA,IAAAA,EAAAR,GACRQ,IAAkBR,EAAoB,CACtC,IAAMvE,EAAQ,IAAI8D,MAAM,sCAAsCZ,EAAUC,GAAM,KAE9E,MADAnD,EAAMuD,KAAO,oBACPvD,EAEV,OAAO+E,iBAiBCC,EACZC,EAAcC,EAAUC,EAA2BC,QAAA,IAAAA,IAAAA,EAAA,MACnDH,EAAOA,GAA2B,OAAnBA,EAAKI,OAAO,IAhCJ,MAgCmBJ,EAAKI,OAAO,GAAqBJ,EAAKK,OAAO,GAAKL,EAC5F,IAAIM,EAAUrC,EAAUgC,GACxB,GAAI3G,MAAM6E,QAAQ8B,GACdK,EAAUL,EAAI9C,IAAIc,GAAWG,KAAK,aAC/B,GAAmB,iBAAR6B,EAAkB,CAChC,IAAMM,EAAkB,GACxB,IAAK,IAAMhD,KAAO0C,EACd,GAAIA,EAAIzG,eAAe+D,GAAM,CACzB,IAAMhD,EAAQ0F,EAAI1C,GAClBgD,EAAMzF,KACCyC,EAAG,KAAqB,iBAAVhD,EAAqBiG,KAAKvC,UAAU1D,GAAS0D,EAAU1D,KAGpF+F,EAAU,IAAIC,EAAMnC,KAAK,MAAK,IAElC,OAAU8B,GAAoBC,EAAS,IAAIA,EAAM,IAAM,IAAE,IAAIG,EAAO,MAChEN,EAAKS,QAAQlB,EAAU;;;;;;;QCnE/B,SAAYH,GAIRA,EAAAA,EAAA,QAAA,GAAA,UAKAA,EAAAA,EAAA,KAAA,GAAA,OAEAA,EAAAA,EAAA,KAAA,GAAA,OAEAA,EAAAA,EAAA,SAAA,GAAA,WAEAA,EAAAA,EAAA,SAAA,GAAA,WAfJ,CAAYA,IAAAA,EAAW;;;;;;;;ACDvB,IAAAsB,EAAA,aAOAC,EAAA,aAOAC,EAAA,aCMaC,EAAgB,SACzBC,EAA6BC,EAA8BzC,GAAiB,OAAA,IAAI0C,EAAeF,EAAWC,EAAQzC,iBA0BtH,SAAA2C,YAuBWA,EAAApH,OAAP,SACIqH,EACAH,GACA,OAAIzH,MAAM6E,QAAQ+C,GACPL,EAAcK,EAASH,EAAQ,IAE/BF,EAAcK,EAAQJ,UAAWI,EAAQH,OAAQG,EAAQ5C,MAAQ,UA5BzE2C,EAAA3B,mBAAqBA,EACrB2B,EAAAE,KAAiB,IAAItB,EAKrBoB,EAAAG,mBAAqB,EAqChC,IAAMC,EAAQ,SAAa9G,GACvB,OAAOA,GAEL+G,EAAe,GACfC,EAAWF,EACXG,EAAoB,WACtB,OAAOlI,MAAMlC,UAAUqK,MAAMhI,KAAKwB,YAWtC+F,EAAA,WAOI,SAAAA,EACIF,EAA6BC,EAA6BZ,QAA7B,IAAAY,IAAAA,EAAA,IAAalB,QAAgB,IAAAM,IAAAA,EAAA,MAC1DrI,KAAKiJ,OAASA,EACdjJ,KAAKqI,OAASA,EACd,IAAMuB,EAAU5J,KAAK6J,SAAW,IAAIvE,IACpCsE,EAAQlE,IAAIyD,EAAkB,CAAC/C,MAAO+C,EAAU9B,GAAIkC,EAAOO,KAAMN,EAAO/G,MAAOzC,KAAM+J,QAAQ,IAC7FH,EAAQlE,IAAI6B,EAAkB,CAACnB,MAAOmB,EAAUF,GAAIkC,EAAOO,KAAMN,EAAO/G,MAAOzC,KAAM+J,QAAQ,IAC7F/J,KAAKgK,MAAQC,EAA4BL,EAASZ,UAKtDE,EAAA5J,UAAA6E,IAAA,SAAIiC,EAAY4B,EAAqBkC,QAAA,IAAAA,IAAAA,EAAqB5C,EAAY6C,SAClE,IAAMP,EAAU5J,KAAK6J,SACfO,EAASR,EAAQzF,IAAIiC,QACZ9F,IAAX8J,GACAR,EAAQlE,IAAIU,EAAO,MAEvB,IACI,OAAOiE,EAAgBjE,EAAOgE,EAAQR,EAAS5J,KAAKiJ,OAAQjB,EAAekC,GAC7E,MAAO3J,GACL,gBHjGRA,EAAQ6F,EAAYgC,EAA2BC,GAC/C,IAAMiC,EAAmB/J,EAAoB,gBAO7C,MANI6F,EAAMsB,IACN4C,EAAUC,QAAQnE,EAAMsB,IAE5BnH,EAAEiK,QAAUvC,EAAY,KAAK1H,EAAEiK,QAAWF,EAAWlC,EAAmBC,GACxE9H,EAAe,YAAI+J,EACnB/J,EAAoB,gBAAI,KAClBA,EGyFSkK,CAAmBlK,EAAG6F,EAAO,sBAAuBpG,KAAKqI,UAIxEa,EAAA5J,UAAAkF,SAAA,WACI,IAAMkG,EAAmB,GAEzB,OAF6C1K,KAAK6J,SAC1Cc,SAAQ,SAACC,EAAGxE,GAAU,OAAAsE,EAAO1H,KAAKmD,EAAUC,OAC7C,kBAAkBsE,EAAOpE,KAAK,MAAK,OAnClD,GAsDA,SAASuE,EAAgBC,GACrB,IAAMhB,EA0JV,SAAqBgB,GACjB,IAAIhB,EAA2BN,EACzBuB,EACDD,EAA0EhB,KAC/E,GAAIiB,GAAgBA,EAAaxI,OAAQ,CACrCuH,EAAO,GACP,IAAK,IAAIxH,EAAI,EAAGA,EAAIyI,EAAaxI,OAAQD,IAAK,CAC1C,IAAI8G,EAAO,EACPhD,EAAQe,EAAkB4D,EAAazI,IAC3C,GAAId,MAAM6E,QAAQD,GACd,IAAK,IAAI4E,EAAI,EAAGC,EAAc7E,EAAO4E,EAAIC,EAAY1I,OAAQyI,IAAK,CAC9D,IAAME,EAAaD,EAAYD,GAC3BE,aAAsBtC,GAAYsC,IAAetC,EAEjDQ,GAAiB,EACV8B,aAAsBpC,GAAYoC,IAAepC,EAExDM,IAAoB,EACb8B,aAAsBrC,GAAQqC,IAAerC,EAEpDO,IAAoB,EAEpBhD,EAAQe,EAAkB+D,GAItCpB,EAAK9G,KAAK,CAACoD,MAAKA,EAAEgD,QAAOA,UAE1B,GAAK0B,EAA8BK,YAAa,CAEnDrB,EAAO,CAAC,CAAC1D,MADHA,EAAQe,EAAmB2D,EAA8BK,aAC/C/B,QAAO,SACpB,IAAK2B,KAAkBpD,KAAamD,GAEvC,MAAMM,EAAY,kBAAmBN,GAEzC,OAAOhB,EA7LMuB,CAAYP,GACrBzD,EAAekC,EACf9G,EAAa+G,EACbO,GAAS,EACPnC,EAAUT,EAAkB2D,EAASlD,SAC3C,GAAID,KAAamD,EAEbrI,EAASqI,EAA2BhD,cACjC,GAAKgD,EAA6BQ,WACrCjE,EAAMyD,EAA6BQ,gBAChC,GAAKR,EAA8BK,kBAEnC,GAAKL,EAAiCS,SACzCxB,GAAS,EACT1C,EAAKF,EAAmB2D,EAAiCS,cACtD,CAAA,GAAuB,mBAAZ3D,EAId,MAAMwD,EACF,sGACAN,GALJf,GAAS,EACT1C,EAAKO,EAMT,MAAO,CAACkC,KAAIA,EAAEzC,GAAEA,EAAE0C,OAAMA,EAAEtH,MAAKA,GAGnC,SAAS+I,EAAsBpF,GAC3B,OAAOgF,EAAY,mDAAoDhF,GAG3E,SAAS6D,EAA4BL,EAA2BkB,GAE5D,IAAId,EAAuB,KAC3B,GAAIc,EAEA,GADAA,EAAW3D,EAAkB2D,GACzBtJ,MAAM6E,QAAQyE,GAEd,IAAK,IAAIxI,EAAI,EAAGA,EAAIwI,EAASvI,OAAQD,IACjC0H,EAAQC,EAA4BL,EAASkB,EAASxI,KAAO0H,MAE9D,CAAA,GAAwB,mBAAbc,EAGd,MAAMM,EAAY,+BAAgCN,GAC/C,IAAIA,GAAgC,iBAAbA,IAAyBA,EAASlD,QA+B5D,MAAMwD,EAAY,sBAAuBN,GA7BzC,IAAI1E,EAAQe,EAAkB2D,EAASlD,SACjC6D,EAAmBZ,EAAgBC,GACzC,IAAuB,IAAnBA,EAASY,MAAgB,CAEzB,IAAIC,EAAoC/B,EAAQzF,IAAIiC,GACpD,GAAIuF,GACA,GAAIA,EAActE,KAAOqC,EACrB,MAAM8B,EAAsBpF,QAIhCwD,EAAQlE,IAAIU,EAAOuF,EAAwB,CACvCvF,MAAO0E,EAASlD,QAChBkC,KAAM,GACNC,QAAQ,EACR1C,GAAIqC,EACJjH,MAAO+G,IAIfpD,EAAQ0E,EACRa,EAAc7B,KAAK9G,KAAK,CAACoD,MAAKA,EAAEgD,QAAO,IAE3C,IAAMgB,EAASR,EAAQzF,IAAIiC,GAC3B,GAAIgE,GAAUA,EAAO/C,KAAOqC,EACxB,MAAM8B,EAAsBpF,GAEhCwD,EAAQlE,IAAIU,EAAOqF,GAK3B,OAAOzB,EAGX,SAASK,EACLjE,EAAYgE,EAAmCR,EAAkCX,EACjFjB,EAAoBkC,GACpB,IACI,OAgBR,SACI9D,EAAYgE,EAAmCR,EAAkCX,EACjFjB,EAAoBkC,GACpB,IAAIzH,EAEJ,IAAI2H,GAAYF,EAAQ5C,EAAYwB,SA2ChCrG,EANSyH,EAAQ5C,EAAYuB,KAGpBqB,EAAQ5C,EAAYsB,SAGrBO,EAASE,KAAKlF,IAAIiC,OAAgC,IAAlB4B,EAAgCA,EAAgB,MAFhFmB,EAASE,KAAKlF,IAAIiC,EAAO4B,GAHzBiB,EAAO9E,IAAIiC,EAAO4B,EAAeV,EAAY6C,aAtCV,CAI3C,IADA1H,EAAQ2H,EAAO3H,SACDgH,EACV,MAAM1C,MAAS6E,wBACZ,GAAInJ,IAAU+G,EAAO,CACxBY,EAAO3H,MAAQgH,EACR,IAAAM,EAAgCK,EAAML,OAA9B1C,EAAwB+C,EAAM/C,GAApBwE,EAAczB,EAAMN,KACzCA,EAAON,EACX,GAAIqC,EAAWtJ,OAAQ,CACnBuH,EAAO,GACP,IAAK,IAAIxH,EAAI,EAAGA,EAAIuJ,EAAWtJ,OAAQD,IAAK,CACxC,IAAMwJ,EAA8BD,EAAWvJ,GACzC8G,EAAU0C,EAAU1C,QAEpB2C,EAAqB,EAAP3C,EAAkCQ,EAAQzF,IAAI2H,EAAU1F,YAAS9F,EACrFwJ,EAAK9G,KAAKqH,EAENyB,EAAU1F,MAGV2F,EAEAnC,EAICmC,GAAwB,EAAP3C,EAAqDH,EAAhBE,EAASE,KAEzD,EAAPD,EAAiC,KAAOD,EAAS3B,mBACjDF,EAAY6C,WAGxBC,EAAO3H,MAAQA,EAAQsH,EAAM,IAAQ1C,EAAU2E,KAAAC,MAAV5E,EAAUnE,EAAA,MAAA,GAAI4G,KAAQzC,EAAG4E,WAAM3L,EAAWwJ,IAWvF,OAAOrH,EAlEIyJ,CAAa9F,EAAOgE,EAAQR,EAASX,EAAQjB,EAAekC,GACrE,MAAO3J,GAWL,MATMA,aAAawG,QACfxG,EAAI,IAAIwG,MAAMxG,KAEEA,EAAoB,gBAAIA,EAAoB,iBAAK,IAChEgK,QAAQnE,GACTgE,GAAUA,EAAO3H,QAAUgH,IAE3BW,EAAO3H,MAAQ+G,GAEbjJ,GA+Fd,SAAS6K,EAAYlD,EAAcC,GAC/B,OAAO,IAAIpB,MAAMkB,EAAYC,EAAMC,EAAK,4BC9V/BgE,EAAyB,CAClC,CAACvE,QAASvI,EAAoBkM,SAAUlM,EAAoByK,KAAM,IAClE,CAAClC,QAASpH,EAAsB+K,SAAU/K,EAAsBsJ,KAAM,CAACpJ,IACvE,CAACkH,QAAShE,EAAiBuH,YAAa3K,GACxC,CACIoH,QAASlH,EAAc6K,SAAU7K,EAAcoJ,KAAM,CACjD9I,EACA3B,EACA4B,EACAoC,EACAI,IAGR,CAACmE,QAASnE,EAAiB8H,SAAU9H,EAAiBqG,KAAM,IAC5D,CAAClC,QAASlE,EAAgB6H,SAAU7H,EAAgBoG,KAAM,IAC1D,CACIlC,QAAS/D,EAAiB0H,SAAU1H,EAAiBiG,KAAM,CACvDX,EACAzF,IAGR,CAACkE,QAASvE,EAAekI,SAAUlI,EAAeyG,KAAM,CAACrF,IACzD,CAACmD,QAASlD,EAAa6G,SAAU7G,EAAaoF,KAAM,CAAChE,EAAYf,IACjE,CAAC6C,QAAS3G,EAAkBsK,SAAUtK,EAAkB6I,KAAM,IAC9D,CAAClC,QAAS7C,EAAmBwG,SAAUxG,EAAmB+E,KAAM,IAChE,CAAClC,QAAS5G,EAAcuK,SAAUvK,EAAc8I,KAAM,IACtD,CAAClC,QAAS9B,EAAYyF,SAAUzF,EAAYgE,KAAM,CAACX,KC5CvDiD,EACI,SACoB5F,EACA6F,GADArM,KAAAwG,KAAAA,EACAxG,KAAAqM,KAAAA,GASxBC,EAAA,SAAAC,GACI,SAAAD,EAAY9F,EACA6F,UACRE,EAAA5K,KAAA3B,KAAMwG,EAAM6F,IAAKrM,YAHmB4B,EAAA0K,EAAAC,KAA5C,CAA4CH,GAW5CI,GAAA,SAAAD,GACI,SAAAC,EAAYH,UACRE,EAAA5K,KAAA3B,UAAMM,EAAW+L,IAAKrM,YAFS4B,EAAA4K,EAAAD,KAAvC,CAAuCH,GAUvCK,GAAA,SAAAF,GACI,SAAAE,EAAYjG,UACR+F,EAAA5K,KAAA3B,KAAMwG,OAAMlG,IAAUN,YAFc4B,EAAA6K,EAAAF,KAA5C,CAA4CH,GAU5CM,GAAA,SAAAH,GACI,SAAAG,EAAYlG,EACgB/D,GAD5B,IAAAkK,EAEIJ,EAAA5K,KAAA3B,KAAMwG,EAAM,CAAC/D,KAAOzC,YADI2M,EAAAlK,MAAAA,WAFYb,EAAA8K,EAAAH,KAA5C,CAA4CH,GAW5CQ,GAAA,SAAAL,GACI,SAAAK,EAAYpG,UACR+F,EAAA5K,KAAA3B,KAAMwG,OAAMlG,IAAUN,YAFa4B,EAAAgL,EAAAL,KAA3C,CAA2CH,GCzC3CS,GAAA,SAAAN,GAAA,SAAAM,0DAAmDjL,EAAAiL,EAAAN,KAAnD,CAAmDD,GAOnDQ,GAAA,SAAAP,GAAA,SAAAO,0DAA8ClL,EAAAkL,EAAAP,KAA9C,CAA8CC,IAO9CO,GAAA,SAAAR,GAAA,SAAAQ,0DAAmDnL,EAAAmL,EAAAR,KAAnD,CAAmDE,IAOnDO,GAAA,SAAAT,GAAA,SAAAS,0DAAmDpL,EAAAoL,EAAAT,KAAnD,CAAmDG,IAOnDO,GAAA,SAAAV,GAAA,SAAAU,0DAAkDrL,EAAAqL,EAAAV,KAAlD,CAAkDK,kBCPlD,SAAAM,YAOWA,EAAA5N,UAAA6N,QAAA,SAAWC,GACdpN,KAAKqN,mBAAgB/M,EAErB,IACMP,EAAYqN,EADJpN,KAAKsN,mBAGnB,OAAOvN,aAAqBD,GAAOE,KAAKqN,yBAAyBL,KAAmC,EAC9FjN,EAAYC,KAAKqN,eAGnBH,EAAA5N,UAAAgO,gBAAA,WAAA,IAAAX,EAAA3M,KAyBJ,OAAO,IAAIuN,OAAM,cAvBD,CACZpJ,IAAK,SAACqJ,EAAQhH,GAEV,OADAmG,EAAKU,cAAgB,IAAIN,GAA8BvG,GAChD,eAAC,IAAA6F,EAAA,GAAAoB,EAAA,EAAAA,EAAAtK,UAAAZ,OAAAkL,IAAApB,EAAAoB,GAAAtK,UAAAsK,GACJd,EAAKU,cAAgB,IAAIR,GAA8BrG,EAAM6F,KAIrE3G,IAAK,SAAC8H,EAAQhH,EAAM/D,GAEhB,OADAkK,EAAKU,cAAgB,IAAIL,GAA8BxG,EAAM/D,IACtD,GAGXwJ,MAAO,SAACuB,EAAQE,EAASrB,GACrBM,EAAKU,cAAgB,IAAIP,GAAyBT,IAGtDnG,IAAK,SAACsH,EAAQhH,GAEV,OADAmG,EAAKU,cAAgB,IAAIJ,GAA6BzG,IAC/C,WCpEVmH,GAAqB,CAC9B,CAAC/F,QAASsF,GAA6B3B,SAAU2B,GAA6BpD,KAAM,KCD3E8D,GAAc,IAAItJ,EAAmC,6BCAlE,SAAAuJ,YACWA,EAAAvO,UAAA4G,IAAA,SAAIM,EAAmB4G,GAC1B,OAAIA,aAAsBP,IACfO,EAAW5G,OAASA,sBCAnC,SAAAsH,EACYC,EACAC,EACAC,GAFAjO,KAAA+N,QAAAA,EACA/N,KAAAgO,gBAAAA,EACAhO,KAAAiO,SAAAA,SAILH,EAAAxO,UAAA4G,IAAA,SAAIM,GAAJ,IAAAmG,EAAA3M,KACH,QAAIA,KAAKgO,gBAAgBE,UAAU1H,SAMsBlG,IAFlDN,KAAK+N,QACP5J,MACAgK,MAAK,SAAAC,GAAU,OAAAzB,EAAKsB,SAAS/H,IAAIM,EAAM4H,0BCjBpD,SAAAC,IACYrO,KAAA+N,QAAwB,UAEzBM,EAAA/O,UAAAgP,IAAA,SAAIF,GACPpO,KAAK+N,QAAQxD,QAAQ6D,IAGlBC,EAAA/O,UAAA6E,IAAA,WACH,OAAAjB,EAAWlD,KAAK+N,6BCJpB,SAAAQ,EACYC,EACAC,EACAvI,GAFAlG,KAAAwO,QAAAA,EACAxO,KAAAyO,2BAAAA,EACAzO,KAAAkG,IAAAA,SAILqI,EAAAjP,UAAA4O,UAAA,SAAU1H,GACb,IAAMlH,EAAYU,KAAKwO,QAAQrK,MAC/B,SAAI7E,IAAaU,KAAKkG,IAAI5G,EAAWkH,KACdxG,KAAKyO,2BAA2BtK,IAAI7E,EAAWkH,GAChD/D,iBAAiBiM,kBCf3C,SACoBC,EACAnB,EACAoB,GAFA5O,KAAA2O,SAAAA,EACA3O,KAAAwN,OAAAA,EACAxN,KAAA4O,OAAAA,iBCCpB,SAAAC,EAAoBC,EACAC,GADA/O,KAAA8O,4BAAAA,EACA9O,KAAA+O,wBAAAA,SAIbF,EAAAvP,UAAA4G,IAAA,SAAIM,EAAmB4H,GAC1B,SAAIA,aAAkBY,IAAgBhP,KAAK+O,wBAAwB7I,IAAIM,EAAM4H,EAAOQ,UAG7E5O,KAAK8O,4BAA4B5I,IAAIM,EAAM4H,EAAOZ,4BCfjE,SAAAyB,YACWA,EAAA3P,UAAA4G,IAAA,SAAIM,EAAmBgH,GAC1B,OAAOA,EAAOhH,aAAiBkI,6BCMvC,SAAAQ,YACWA,EAAA5P,UAAA4G,IAAA,SAAIM,EAAmB4G,GAC1B,QAAIA,aAAsBtN,GACnBsN,aAAsBN,IACtBM,aAAsBP,IACtBO,aAAsBH,KAItBG,EAAW5G,OAASA,sBCZ/B,SAAA2I,EACYpB,EACAC,EACAC,GAFAjO,KAAA+N,QAAAA,EACA/N,KAAAgO,gBAAAA,EACAhO,KAAAiO,SAAAA,SAILkB,EAAA7P,UAAA4G,IAAA,SAAIM,GAAJ,IAAAmG,EAAA3M,KACH,QAAIA,KAAKgO,gBAAgBoB,YAAY5I,SAKoBlG,IAFlDN,KAAK+N,QACP5J,MACAgK,MAAK,SAAAC,GAAU,OAAAzB,EAAKsB,SAAS/H,IAAIM,EAAM4H,0BCZhD,SAAAiB,EACYb,EACAC,EACAvI,GAFAlG,KAAAwO,QAAAA,EACAxO,KAAAyO,2BAAAA,EACAzO,KAAAkG,IAAAA,SAILmJ,EAAA/P,UAAA8P,YAAA,SAAY5I,GACf,IAAMlH,EAAYU,KAAKwO,QAAQrK,MAC/B,GAAI7E,GAAaU,KAAKkG,IAAI5G,EAAWkH,GAAO,CACxC,IAAM8I,EAAatP,KAAKyO,2BAA2BtK,IAAI7E,EAAWkH,GAClE,YAA0BlG,IAAnBgP,EAAWnL,KAAsBmL,EAAW7M,iBAAiBiM,WAAc,EAEtF,OAAO,sBCbX,SAAAa,EAAoBC,EACAC,GADAzP,KAAAwP,8BAAAA,EACAxP,KAAAyP,0BAAAA,SAIbF,EAAAjQ,UAAA4G,IAAA,SAAIM,EAAmB4H,GAC1B,SAAIA,aAAkBY,IAAgBhP,KAAKyP,0BAA0BvJ,IAAIM,EAAM4H,EAAOQ,UAG/E5O,KAAKwP,8BAA8BtJ,IAAIM,EAAM4H,EAAOZ,4BCfnE,SAAAkC,YACWA,EAAApQ,UAAA4G,IAAA,SAAIM,EAAmBgH,GAC1B,OAAOmC,QAAQzJ,IAAIsH,EAAQhH,IAAUgH,EAAOhH,aAAiBkI,WAAc,sBCE/E,SAAAkB,EACY7B,EACAE,GADAjO,KAAA+N,QAAAA,EACA/N,KAAAiO,SAAAA,SAIL2B,EAAAtQ,UAAA4G,IAAA,SAAIM,GAAJ,IAAAmG,EAAA3M,KACH,YAEyDM,IAFlDN,KAAK+N,QACP5J,MACAgK,MAAK,SAAAC,GAAU,OAAAzB,EAAKsB,SAAS/H,IAAIM,EAAM4H,0BCRpD,SAAAyB,YACWA,EAAAvQ,UAAA4G,IAAA,SAAIM,EAAmB4H,GAG1B,OAAqB,KAAjB0B,EAF6B1B,EAAMO,SAAAmB,gBAMnC1B,EAAOZ,kBAAkBP,GAClBmB,EAAOZ,OAAOhH,OAASA,EAG9B4H,EAAOZ,kBAAkB1N,GAClBsO,EAAOZ,OAAOrN,KAAK,IAAIyM,GAAsBpG,yBCd5D,SAAAuJ,EAAYC,SAFJhQ,KAAAV,UAAiB,KAGrBU,KAAKV,UAAiC,QAAxB2Q,EAAGD,MAAAA,OAAU,EAAVA,EAAY1Q,iBAAS,IAAA2Q,EAAAA,EAAID,SAGvCD,EAAAzQ,UAAA6E,IAAA,WACH,OAAOnE,KAAKV,WAGTyQ,EAAAzQ,UAAAoG,IAAA,SAAIpG,GACPU,KAAKV,UAAYA,sBCbzB,SAAA4Q,YACIA,EAAA5Q,UAAA6E,IAAA,SAAIqJ,EAAahH,GAEb,IADA,IAAIlH,EAAYkO,EACK,OAAdlO,GAAoB,CACvB,IAAMgQ,EAAaK,QAAQQ,yBAAyB7Q,EAAWkH,GAC/D,QAAmBlG,IAAfgP,EAA0B,OAAOA,EACrChQ,EAAYqQ,QAAQ9J,eAAevG,wBCA3C,SAAA8Q,EACY5B,EACAC,EACAvI,GAFAlG,KAAAwO,QAAAA,EACAxO,KAAAyO,2BAAAA,EACAzO,KAAAkG,IAAAA,SAILkK,EAAA9Q,UAAA+Q,WAAA,SAAW7J,GACd,IAAMlH,EAAYU,KAAKwO,QAAQrK,MAC/B,GAAI7E,GAAaU,KAAKkG,IAAI5G,EAAWkH,GAAO,CACxC,IAAM8I,EAAatP,KAAKyO,2BAA2BtK,IAAI7E,EAAWkH,GAClE,OAAO8I,EAAWnL,eAAeuK,eAA+BpO,IAAnBgP,EAAW5J,MAA6C,IAAxB4J,EAAWgB,SAE5F,OAAO,WC8CsBX,QAAQzJ,IA/ChCqK,GAAyB,CAClC,CAAC3I,QAASiG,GAA6BtC,SAAUsC,GAA6B/D,KAAM,IACpF,CACIlC,QAASkG,GACTvC,SAAUuC,GACVhE,KAAM,CAACuE,GAASE,GAAuBM,KAE3C,CAACjH,QAASqH,GAAyB1D,SAAU0D,GAAyBnF,KAAM,IAC5E,CACIlC,QAASiH,GACTtD,SAAUsD,GACV/E,KAAM,CAAC+D,GAA6BoB,KAExC,CAACrH,QAASsH,GAA+B3D,SAAU2D,GAA+BpF,KAAM,IACxF,CACIlC,QAASuH,GACT5D,SAAU4D,GACVrF,KAAM,CAACuE,GAASgB,GAAyBE,KAE7C,CAAC3H,QAAS8H,GAA2BnE,SAAUmE,GAA2B5F,KAAM,IAChF,CACIlC,QAAS2H,GACThE,SAAUgE,GACVzF,KAAM,CAACoF,GAA+BQ,KAE1C,CACI9H,QAASgI,GACTrE,SAAUqE,GACV9F,KAAM,CAACuE,GAASwB,KAEpB,CAACjI,QAASiI,GAA6BtE,SAAUsE,GAA6B/F,KAAM,IACpF,CACIlC,QAAS2G,GACThD,SAAUgD,GACVzE,KAAM,CAACiG,GAAkBG,GAA4BtC,KAEzD,CACIhG,QAASwI,GACT7E,SAAU6E,GACVtG,KAAM,CAACiG,GAAkBG,GAA4BtC,KAEzD,CACIhG,QAASyH,GACT9D,SAAU8D,GACVvF,KAAM,CAACiG,GAAkBG,GAA4BtC,KAEzD,CAAChG,QAASsI,GAA4B3E,SAAU2E,GAA4BpG,KAAM,IAClF,CAAClC,QAASgG,GAAa9F,SAAQ0I,GAAe1G,KAAM,mBC7DpD,SAAA2G,EAAoBvM,GAAAlE,KAAAkE,gBAAAA,SAIbuM,EAAAnR,UAAAK,QAAA,SAAQH,EAAaC,GACxB,GAAID,IAASC,EAAO,OAAO,EAC3B,GAAID,EAAK+C,SAAW9C,EAAM8C,OAAQ,OAAO,EAEzC,IAAK,IAAID,EAAI,EAAGA,EAAI9C,EAAK+C,OAAQD,IAAK,CAClC,IAAMoO,EAASlR,EAAK8C,GACdqO,EAASlR,EAAM6C,GACrB,IAAqD,IAAjDtC,KAAKkE,gBAAgBvE,QAAQ+Q,EAAQC,GACrC,OAAO,EAIf,OAAO,sBCbX,SAAAC,EAAoB1M,GAAAlE,KAAAkE,gBAAAA,SAIb0M,EAAAtR,UAAAK,QAAA,SAAQH,EAA8BC,GACzC,GAAIA,aAAiBK,EACjB,OAAQL,EAAkBU,KAAKX,GAGnC,IAAMqR,EAAkBpR,EACxB,QAAID,EAAKgH,OAASqK,EAAgBrK,OAAQxG,KAAKkE,gBAAgBvE,QAAQH,EAAKiD,MAAOoO,EAAgBpO,4BCVvG,SAAAqO,EAAoBC,GAAA/Q,KAAA+Q,iBAAAA,SAIbD,EAAAxR,UAAAK,QAAA,SAAQH,EAA8BC,GACzC,GAAIA,aAAiBK,EACjB,OAAQL,EAAkBU,KAAKX,GAGnC,IAAMqR,EAAkBpR,EACxB,OAAID,EAAKgH,OAASqK,EAAgBrK,MACvBxG,KAAK+Q,iBAAiBpR,QAAQH,EAAK6M,KAAMwE,EAAgBxE,0BCXxE,SAAA2E,EAAoBD,GAAA/Q,KAAA+Q,iBAAAA,SAIbC,EAAA1R,UAAAK,QAAA,SAAQH,EAAyBC,GACpC,GAAIA,aAAiBK,EACjB,OAAQL,EAAkBU,KAAKX,GAGnC,IAAMqR,EAAkBpR,EACxB,OAAOO,KAAK+Q,iBAAiBpR,QAAQH,EAAK6M,KAAMwE,EAAgBxE,0BCbxE,SAAA4E,YAEWA,EAAA3R,UAAAK,QAAA,SAAQH,EAA6BC,GACxC,GAAIA,aAAiBK,EACjB,OAAQL,EAAkBU,KAAKX,GAGnC,IAAMqR,EAAkBpR,EACxB,OAAID,EAAKgH,OAASqK,EAAgBrK,yBCR1C,SAAA0K,YAEWA,EAAA5R,UAAAK,QAAA,SAAQH,EAA8BC,GACzC,GAAIA,aAAiBK,EACjB,OAAQL,EAAkBU,KAAKX,GAGnC,IAAMqR,EAAkBpR,EACxB,OAAID,EAAKgH,OAASqK,EAAgBrK,yBCatC,SAAA2K,EAAoBC,EACAC,EACAC,EACAC,EACAC,GAJAxR,KAAAoR,6BAAAA,EACApR,KAAAqR,6BAAAA,EACArR,KAAAsR,wBAAAA,EACAtR,KAAAuR,6BAAAA,EACAvR,KAAAwR,4BAAAA,SAIbL,EAAA7R,UAAAK,QAAA,SAAQH,EAAmBC,GAE9B,OAAID,IAASC,SACCa,IAAVb,IAEAD,aAAgBiN,KAA2BhN,aAAiBsN,IAAiCtN,aAAiBK,GACvGE,KAAKoR,6BAA6BzR,QAAQH,EAAMC,GAEvDD,aAAgBkN,KAA2BjN,aAAiBuN,IAAiCvN,aAAiBK,GACvGE,KAAKqR,6BAA6B1R,QAAQH,EAAMC,GAEvDD,aAAgBoN,KAA0BnN,aAAiBwN,IAAgCxN,aAAiBK,GACrGE,KAAKwR,4BAA4B7R,QAAQH,EAAMC,GAEtDD,aAAgBgN,KAAsB/M,aAAiBqN,IAA4BrN,aAAiBK,GAC7FE,KAAKsR,wBAAwB3R,QAAQH,EAAMC,GAElDD,aAAgB8M,IAA2B7M,aAAiBoN,IAAiCpN,aAAiBK,IACvGE,KAAKuR,6BAA6B5R,QAAQH,EAAMC,WC1CtDgS,GAA8B,CACvC,CACI7J,QAASuJ,GACT5F,SAAU4F,GACVrH,KAAM,CACFoH,GACAN,GACAI,GACAF,GACAG,KAGR,CAACrJ,QAASgJ,GAA8BrF,SAAUqF,GAA8B9G,KAAM,CAAClG,IACvF,CAACgE,QAASkJ,GAA8BvF,SAAUuF,GAA8BhH,KAAM,CAAC2G,KACvF,CAAC7I,QAASoJ,GAAyBzF,SAAUyF,GAAyBlH,KAAM,CAAC2G,KAC7E,CAAC7I,QAASqJ,GAAmB1F,SAAU0F,GAAmBnH,KAAM,IAChE,CAAClC,QAASsJ,GAA8B3F,SAAU2F,GAA8BpH,KAAM,IACtF,CAAClC,QAAShE,EAAiB2H,SAAU3H,EAAiBkG,KAAM,IAC5D,CAAClC,QAAS6I,GAAkBlF,SAAUkF,GAAkB3G,KAAM,CAAClG,mBCzBnE,SAAA8N,YAEWA,EAAApS,UAAAqS,OAAA,SAAO3M,WACV,GAAIA,aAAkBlF,EAAI,MAAO,SAAUkF,EAAmBjF,UAAS,IACvE,GAAIiF,aAAkB6C,QAA4B,iBAAX7C,EAAqB,MAAO,IAAKA,EAAM,IAC9E,GAAIA,aAAkBxD,MAAO,CACzB,IAAMoQ,EAAc,OACpB,IAAoB,IAAArO,EAAAvB,EAAAX,OAAO8D,KAAKH,IAAOxB,EAAAD,EAAAf,QAAAgB,EAAAd,KAAAc,EAAAD,EAAAf,OAAE,CAApC,IAAMqP,EAAKrO,EAAAf,MACZmP,EAAY5O,MAAK,IAAI0O,GAAoBC,OAAO3M,EAAO6M,uGAG3D,MAAO,IAAID,EAAW,IAE1B,MAAO,GAAG5M,sBCVd,SAAA8M,EAAoBC,GAAA/R,KAAA+R,oBAAAA,SAIbD,EAAAxS,UAAAqS,OAAA,SAAOK,EAAoCC,EAAsBC,EAA6BC,GAGjG,MAAO,GAFuBnS,KAAK+R,oBAAoBJ,OAAOK,SACzB1R,IAAb6R,EAAyB,OAAOA,EAAa,IACpB,IAAIF,EAAaG,cAAa,oBAAoBF,EAAmB,+BCM1H,SAAAG,EAAoBC,EACAC,EACAC,EACAC,EACAC,EACAC,GALA3S,KAAAsS,qBAAAA,EACAtS,KAAAuS,qBAAAA,EACAvS,KAAAwS,gBAAAA,EACAxS,KAAAyS,qBAAAA,EACAzS,KAAA0S,kBAAAA,EACA1S,KAAA2S,oBAAAA,SAIbN,EAAA/S,UAAAqS,OAAA,SAAOvE,GACV,OAAIA,aAAsBX,GAA+BzM,KAAKsS,qBAAqBX,OAAOvE,GACtFA,aAAsBV,GAA+B1M,KAAKuS,qBAAqBZ,OAAOvE,GACtFA,aAAsBR,GAA8B5M,KAAK2S,oBAAoBhB,OAAOvE,GACpFA,aAAsBZ,GAA0BxM,KAAKwS,gBAAgBb,OAAOvE,GAC5EA,aAAsBd,EAA+BtM,KAAKyS,qBAAqBd,OAAOvE,GACtFA,aAAsBtN,EAAWE,KAAK0S,kBAAkBf,OAAOvE,QAAnE,sBC1BJ,SAAAwF,EACYC,EACAC,GADA9S,KAAA6S,4BAAAA,EACA7S,KAAA8S,4BAAAA,SAGLF,EAAAtT,UAAAqS,OAAA,SACHK,EACAC,EACAC,EACAa,EACAZ,GACA,IAEMa,EAAY,wCAClB,OAHkChT,KAAK6S,4BAA4BlB,OAAOK,EAAUC,EAAcC,EAAqBC,GAGpF,KAAKa,EAAS,qBAFfhT,KAAK8S,4BAA4BnB,OAAOoB,GAEqB,KAAKC,EAAS,yBChBjH,SAAAC,EAAoBlB,GAAA/R,KAAA+R,oBAAAA,SAIbkB,EAAA3T,UAAAqS,OAAA,SAAOoB,WACN1S,EAAS,OACb,IAAyB,IAAA6S,EAAAlR,EAAA+Q,GAAkBI,EAAAD,EAAA1Q,QAAA2Q,EAAAzQ,KAAAyQ,EAAAD,EAAA1Q,OAAE,CAAxC,IAAM4K,EAAU+F,EAAA1Q,MACjBpC,GAAaL,KAAK+R,oBAAoBJ,OAAOvE,GAAW,uGAG5D,OAAO/M,EAAOkI,OAAO,EAAGlI,EAAOkC,OAAS,uBCT5C,SAAA6Q,EAAoBV,EACAW,GADArT,KAAA0S,kBAAAA,EACA1S,KAAAqT,qBAAAA,SAIbD,EAAA9T,UAAAqS,OAAA,SAAOvE,GAGV,MAAO,iBAFOpN,KAAK0S,kBAAkBf,OAAOvE,EAAW3K,OAE1B,iBADTzC,KAAKqT,qBAAqB1B,OAAOvE,EAAW5G,MACN,wBCdlE,SAAA8M,YACWA,EAAAhU,UAAAqS,OAAA,SAAO4B,GACV,OAAO1L,OAAO0L,uBCIlB,SAAAC,EAAoBd,EACAW,GADArT,KAAA0S,kBAAAA,EACA1S,KAAAqT,qBAAAA,SAIbG,EAAAlU,UAAAqS,OAAA,SAAOvE,GAAP,IAAAT,EAAA3M,KACGyT,EAAsB,GAE5BrG,EAAWf,KAAK1B,SAAQ,SAAA+I,GACpBD,EAAUzQ,KAAK2J,EAAK+F,kBAAkBf,OAAO+B,OAGjD,IAAMjR,EAAQgR,EAAUnN,KAAK,MAE7B,OADoBtG,KAAKqT,qBAAqB1B,OAAOvE,EAAW5G,MAC3C,IAAI/D,EAAK,wBCflC,SAAAkR,EAAoBjB,GAAA1S,KAAA0S,kBAAAA,SAIbiB,EAAArU,UAAAqS,OAAA,SAAOvE,GAEV,MAAO,IADOpN,KAAK0S,kBAAkBf,OAAOvE,EAAWf,MACvC,wBCPpB,SAAAuH,EAAoBP,GAAArT,KAAAqT,qBAAAA,SAIbO,EAAAtU,UAAAqS,OAAA,SAAOvE,GAEV,MAAO,oBADapN,KAAKqT,qBAAqB1B,OAAOvE,EAAW5G,MACzB,wBCN3C,SAAAqN,EAAoBR,GAAArT,KAAAqT,qBAAAA,SAIbQ,EAAAvU,UAAAqS,OAAA,SAAOvE,GAEV,MAAO,cADapN,KAAKqT,qBAAqB1B,OAAOvE,EAAW5G,MAC/B,UCE5BsN,GAAsB,CAC/B,CACIlM,QAASgL,GACTrH,SAAUqH,GACV9I,KAAM,CAACgI,GAA6BmB,KAExC,CAACrL,QAASqL,GAA6B1H,SAAU0H,GAA6BnJ,KAAM,CAACuI,KACrF,CACIzK,QAASwL,GACT7H,SAAU6H,GACVtJ,KAAM,CAAC4H,GAAmB4B,KAE9B,CAAC1L,QAAS0L,GAAsB/H,SAAU+H,GAAsBxJ,KAAM,IACtE,CACIlC,QAAS4L,GACTjI,SAAUiI,GACV1J,KAAM,CAAC4H,GAAmB4B,KAE9B,CAAC1L,QAAS+L,GAA2BpI,SAAUoI,GAA2B7J,KAAM,CAAC4H,KACjF,CAAC9J,QAASgM,GAAqBrI,SAAUqI,GAAqB9J,KAAM,CAACwJ,KACrE,CAAC1L,QAASiM,GAAgCtI,SAAUsI,GAAgC/J,KAAM,CAACwJ,KAC3F,CACI1L,QAASyK,GACT9G,SAAU8G,GACVvI,KAAM,CACF+J,GACAT,GACAO,GACAH,GACA9B,GACAkC,KAGR,CAAChM,QAASkK,GAA6BvG,SAAUuG,GAA6BhI,KAAM,CAACuI,KACrF,CAACzK,QAAS8J,GAAmBnG,SAAUmG,GAAmB5H,KAAM,mBC5CpE,SAAAiK,YACWA,EAAAzU,UAAA0U,KAAA,SAAaC,EAAgDC,GAChE,OAAOD,EAAShI,WAAM3L,EAAW,CAAC4T,aCFtC,SACoBvF,EACAnB,EACA/K,GAFAzC,KAAA2O,SAAAA,EACA3O,KAAAwN,OAAAA,EACAxN,KAAAyC,MAAAA,MCFpB,SACoBkM,EACAnB,EACAyG,GAFAjU,KAAA2O,SAAAA,EACA3O,KAAAwN,OAAAA,EACAxN,KAAAiU,SAAAA,MCJpB,SACoBtF,EACAnB,EACA2G,GAFAnU,KAAA2O,SAAAA,EACA3O,KAAAwN,OAAAA,EACAxN,KAAAmU,UAAAA,iBCKpB,SAAAC,EACYC,EACAC,GADAtU,KAAAqU,qBAAAA,EACArU,KAAAsU,mBAAAA,SAILF,EAAA9U,UAAA0U,KAAA,SAAQ5F,EAAoB8F,GAC/B,GAAI9F,aAAkBmG,GAClB,OAAOnG,EAAO3L,MAElB,GAAI2L,aAAkBoG,GAClB,OAAOxU,KAAKqU,qBAAqBL,KAAK5F,EAAO6F,SAAUC,GAE3D,GAAI9F,aAAkBY,GAClB,OAAOhP,KAAKsU,mBAAmBN,KAAK5F,EAAOQ,OAAQsF,GAEvD,GAAI9F,aAAkBqG,GAClB,MAAMrG,EAAO+F,8BCfrB,SAAAO,EACYzI,GAAAjM,KAAAiM,MAAAA,SAILyI,EAAApV,UAAA0U,KAAA,SAAKpF,EAAasF,GACrB,GAAIA,aAAuBzH,GACvB,OAAOmC,EAAOsF,EAAY1N,MAE9B,GAAI0N,aAAuBxH,GAEvB,OADAkC,EAAOsF,EAAY1N,MAAQ0N,EAAYzR,OAChC,EAEX,GAAIyR,aAAuB5H,EAAwB,CAC/C,IAAMqI,EAAS/F,EAAOsF,EAAY1N,MAClC,OAAOxG,KAAKiM,MAAM0I,EAAQ/F,EAAQsF,EAAY7H,MAElD,OAAI6H,aAAuB1H,GAChBxM,KAAKiM,MAAM2C,OAAQtO,EAAW4T,EAAY7H,MAEjD6H,aAAuBtH,GAChBsH,EAAY1N,QAAQoI,OAD/B,sBCzBJ,SAAAgG,EACY7G,EACA8G,GADA7U,KAAA+N,QAAAA,EACA/N,KAAA6U,QAAAA,SAILD,EAAAtV,UAAA6E,IAAA,SAAI+P,eACP,IAAqB,IAAA3Q,EAAAvB,EAAAhC,KAAK+N,QAAQ5J,OAAKX,EAAAD,EAAAf,QAAAgB,EAAAd,KAAAc,EAAAD,EAAAf,OAAE,CAApC,IAAM4L,EAAM5K,EAAAf,MACN+K,EAAkCY,EAAMZ,OAArBsC,EAAe1B,EAAMO,SAAAmB,WAC/C,GAAI9P,KAAK6U,QAAQlV,QAAQuU,EAAa1G,KAA4B,IAAjBsC,IAC7C,OAAO1B,yHCXnB,SAAA0G,EACYC,EACAC,EACAC,GAFAjV,KAAA+U,uBAAAA,EACA/U,KAAAgV,uBAAAA,EACAhV,KAAAiV,aAAAA,SAILH,EAAAxV,UAAA0U,KAAA,SAAKE,GACR,IAAM9F,EAASpO,KAAK+U,uBAAuB5Q,IAAI+P,GAE/C,GADAlU,KAAKgV,uBAAuBE,OAAOhB,EAAa9F,QACjC9N,IAAX8N,EACJ,OAAOpO,KAAKiV,aAAajB,KAAK5F,EAAQ8F,uBCT1C,SAAAiB,EACYpH,EACA8G,GADA7U,KAAA+N,QAAAA,EACA/N,KAAA6U,QAAAA,SAILM,EAAA7V,UAAA4V,OAAA,SAAOhB,EAA0BvF,eACpC,IAAqB,IAAApL,EAAAvB,EAAAhC,KAAK+N,QAAQ5J,OAAKX,EAAAD,EAAAf,QAAAgB,EAAAd,KAAAc,EAAAD,EAAAf,OAAE,CAApC,IAAM4L,EAAM5K,EAAAf,MACN+K,EAA8BY,EAAMZ,OAAjB0H,EAAW9G,EAAMO,SAAAuG,OAC3C,GAAIlV,KAAK6U,QAAQlV,QAAQuU,EAAa1G,GAIlC0H,EAHe9G,IAAWO,gHChB7ByG,GAAgB,IAAI9Q,EAAqC,iBCQzD+Q,GAA8B,CACvC,CAACzN,QAASwN,GAAetN,SAAU6H,QAAQ1D,MAAOnC,KAAM,IACxD,CAAClC,QAASwM,GAAc7I,SAAU6I,GAActK,KAAM,CAACiK,GAAsBW,KAC7E,CAAC9M,QAASgN,GAAwBrJ,SAAUqJ,GAAwB9K,KAAM,CAACuE,GAAS8C,KACpF,CAACvJ,QAAS8M,GAAoBnJ,SAAUmJ,GAAoB5K,KAAM,CAACsL,KACnE,CACIxN,QAASkN,GACTvJ,SAAUuJ,GACVhL,KAAM,CAAC8K,GAAwBO,GAAwBf,KAE3D,CAACxM,QAASmM,GAAsBxI,SAAUwI,GAAsBjK,KAAM,mBCftE,SAAAwL,EACYC,EACAC,GADAxV,KAAAuV,QAAAA,EACAvV,KAAAwV,kBAAAA,SAILF,EAAAhW,UAAAmW,UAAA,SAAUjI,EAAaE,EAAcgI,GACxC,IAAMtI,EAAa,IAAIZ,GAAkBkJ,GAIzC,OAFA1V,KAAKuV,QAAQjH,IAAIlB,GAEVpN,KAAKwV,kBAAkBxB,KAAK5G,uBCbvC,SAAAuI,EACYC,GAAA5V,KAAA4V,iBAAAA,SAILD,EAAArW,UAAAmW,UAAA,WACH,OAAOzV,KAAK4V,iBAAiBzR,YC6QxB0R,GAAS1T,OAAO,wBC1QzB,SAAA2T,EACYC,EACAR,EACAS,EACAR,EACAS,EACAC,EACAC,GANAnW,KAAA+V,KAAAA,EACA/V,KAAAuV,QAAAA,EACAvV,KAAAgW,uBAAAA,EACAhW,KAAAwV,kBAAAA,EACAxV,KAAAiW,oBAAAA,EACAjW,KAAAkW,kBAAAA,EACAlW,KAAAmW,oBAAAA,SAILL,EAAAxW,UAAAmW,UAAA,SAAUlC,GACb,IAAMW,EAAc,IAAIzH,GAAuB8G,GAI/C,OAFAvT,KAAKuV,QAAQjH,IAAI4F,GAEbX,IAAasC,GACN7V,KAAK+V,KAGZ/V,KAAKgW,uBAAuB9P,IAAIqN,GACzBvT,KAAKgW,uBAAuB7R,IAAIoP,GAGvCvT,KAAKiW,oBAAoB/P,IAAIqN,GACtBvT,KAAKwV,kBAAkBxB,KAAKE,GAGnClU,KAAKkW,kBAAkBhQ,IAAIqN,GACpBvT,KAAKmW,oBAAoBhS,IAAIoP,GAGjCvT,KAAKwV,kBAAkBxB,KAAKE,uBClCvC,SAAAkC,EACYb,EACAS,EACAR,EACAa,EACAJ,EACAC,EACAlB,GANAhV,KAAAuV,QAAAA,EACAvV,KAAAgW,uBAAAA,EACAhW,KAAAwV,kBAAAA,EACAxV,KAAAqW,8BAAAA,EACArW,KAAAiW,oBAAAA,EACAjW,KAAAkW,kBAAAA,EACAlW,KAAAgV,uBAAAA,SAILoB,EAAA9W,UAAAmW,UAAA,SAAUlC,GACb,IAAMW,EAAc,IAAItH,GAAsB2G,GAG9C,OAFAvT,KAAKuV,QAAQjH,IAAI4F,KAEblU,KAAKgW,uBAAuB9P,IAAIqN,KAIhCvT,KAAKqW,8BAA8BnQ,IAAIqN,GAChCvT,KAAKwV,kBAAkBxB,KAAKE,IAGvClU,KAAKgV,uBAAuBE,OAAOhB,OAAa5T,KAE5CN,KAAKiW,oBAAoB/P,IAAIqN,MAI7BvT,KAAKkW,kBAAkBhQ,IAAIqN,yBCzBnC,SAAA+C,EAAoBC,GAAAvW,KAAAuW,WAAAA,EAFZvW,KAAAwW,IAAuB,UASxBF,EAAAhX,UAAAgP,IAAA,SAAImI,GACP,IAAMrM,EAAS,CAACsM,GAAI1W,KAAKuW,WAAW/T,OAAQ4K,WAAYqJ,GACxDzW,KAAKwW,IAAIxT,KAAKoH,IAMXkM,EAAAhX,UAAA6E,IAAA,WACH,OAAAjB,EAAWlD,KAAKwW,yBCjCxB,SAAAG,IACY3W,KAAAwO,QAAU,IAAIlJ,WAEfqR,EAAArX,UAAA4G,IAAA,SAAIqN,GACP,OAAOvT,KAAKwO,QAAQtI,IAAIqN,IAGrBoD,EAAArX,UAAA6E,IAAA,SAAIoP,GACP,OAAOvT,KAAKwO,QAAQrK,IAAIoP,IAGrBoD,EAAArX,UAAAoG,IAAA,SAAI6N,EAAuB9Q,GAC9BzC,KAAKwO,QAAQ9I,IAAI6N,EAAU9Q,uBCF/B,SAAAmU,EACYrB,EACAC,GADAxV,KAAAuV,QAAAA,EACAvV,KAAAwV,kBAAAA,EAJJxV,KAAAqF,IAAM,IAAIC,WAQXsR,EAAAtX,UAAA6E,IAAA,SAAIoP,GAAJ,IAAA5G,EAAA3M,KAQH,OAP+B,IAA3BA,KAAKqF,IAAIa,IAAIqN,IACbvT,KAAKqF,IAAIK,IAAI6N,GAAU,eAAC,IAAAlH,EAAA,GAAAoB,EAAA,EAAAA,EAAAtK,UAAAZ,OAAAkL,IAAApB,EAAAoB,GAAAtK,UAAAsK,GACpB,IAAMyG,EAAc,IAAI5H,EAAuBiH,EAAUlH,GAEzD,OADAM,EAAK4I,QAAQjH,IAAI4F,GACVvH,EAAK6I,kBAAkBxB,KAAKE,MAGpClU,KAAKqF,IAAIlB,IAAIoP,uBCbxB,SAAAsD,EACYtB,EACAS,EACAR,EACAsB,GAHA9W,KAAAuV,QAAAA,EACAvV,KAAAgW,uBAAAA,EACAhW,KAAAwV,kBAAAA,EACAxV,KAAA8W,yBAAAA,SAILD,EAAAvX,UAAAmW,UAAA,SAAUjI,EAAa+F,EAAuB9Q,GACjD,IAAM2K,EAAa,IAAIV,GAAuB6G,EAAU9Q,GAIxD,GAFAzC,KAAKuV,QAAQjH,IAAIlB,GAEbmG,IAAasC,GACb,OAAO,EAGX,IAA2D,IAAvD7V,KAAK8W,yBAAyBzG,WAAWkD,GACzC,OAAO,EAGX,IAAMwD,EAAW/W,KAAKwV,kBAAkBxB,KAAK5G,GAK7C,OAJiB,IAAb2J,QAAkCzW,IAAbyW,GACrB/W,KAAKgW,uBAAuBtQ,IAAI6N,EAAU9Q,QAG1BnC,IAAbyW,GAAgCA,sBC/B3C,SAAAC,EACYpB,GAAA5V,KAAA4V,iBAAAA,SAILoB,EAAA1X,UAAAmW,UAAA,SAAUnW,GACb,YAAkBgB,IAAdhB,IACAU,KAAK4V,iBAAiBlQ,IAAIpG,IACnB,uBCCf,SAAA2X,EAAoB7N,EACA8N,EACAC,EACAC,EACAC,EACAC,EACAC,GANAvX,KAAAoJ,QAAAA,EACApJ,KAAAkX,QAAAA,EACAlX,KAAAmX,QAAAA,EACAnX,KAAAoX,QAAAA,EACApX,KAAAqX,UAAAA,EACArX,KAAAsX,mBAAAA,EACAtX,KAAAuX,mBAAAA,SAGbN,EAAA3X,UAAA0F,OAAA,WAKH,YAJoB1E,IAAhBN,KAAKwX,SACLxX,KAAKwX,OAASxX,KAAKyX,gBAGhBzX,KAAKwX,QAGRP,EAAA3X,UAAAmY,aAAA,WAAA,IAAA9K,EAAA3M,KACEoJ,EAAU,CACZjF,IAAK,SAACqJ,EAAQhH,GAAS,OAAAmG,EAAKuK,QAAQzB,UAAUjP,IAC9Cd,IAAK,SAAC8H,EAAQhH,EAAM/D,GAAU,OAAAkK,EAAKwK,QAAQ1B,UAAUjI,EAAQhH,EAAM/D,IACnEyD,IAAK,SAACsH,EAAQhH,GAAS,OAAAmG,EAAKyK,QAAQ3B,UAAUjP,IAC9CyF,MAAO,SAACuB,EAAQE,EAASrB,GAAS,OAAAM,EAAK0K,UAAU5B,UAAUjI,EAAQE,EAASrB,IAC5ExG,eAAgB,WAAM,OAAA8G,EAAK2K,mBAAmB7B,aAC9CnU,eAAgB,SAACkM,EAAQlO,GAAc,OAAAqN,EAAK4K,mBAAmB9B,UAAUnW,KAO7E,OAJIU,KAAKoJ,QAAQ5C,OACb4C,EAAkB,SAAIpJ,KAAKoJ,QAAQ5C,MAGhC,IAAI+G,MAAMvN,KAAKoJ,QAAQoE,OAAQpE,SCxCjCsO,GAAO,IAAIpT,EAA+B,SCA1CqT,GAAe,IAAIrT,EAAkC,gBCiBrDsT,GAAwB,CACjC,CACIhQ,QAASqP,GAAc1L,SAAU0L,GAAcnN,KAAM,CACjD6N,GACA7B,GACAe,GACAT,GACAd,GACAK,GACAqB,KAGR,CAACpP,QAAS0N,GAAW/J,SAAU+J,GAAWxL,KAAM,CAACwM,GAASxB,KAC1D,CACIlN,QAASkO,GAASvK,SAAUuK,GAAShM,KAAM,CACvC4N,GACApB,GACAK,GACA7B,GACA3F,GACArB,GACA8I,KAGR,CAAChP,QAAS+N,GAAoBpK,SAAUoK,GAAoB7L,KAAM,CAACiG,KACnE,CACInI,QAASwO,GAAS7K,SAAU6K,GAAStM,KAAM,CACvCwM,GACAK,GACA7B,GACAlF,GACAT,GACArB,GACAqH,KAGR,CAACvN,QAAS+O,GAAwBpL,SAAUoL,GAAwB7M,KAAM,IAC1E,CAAClC,QAASmI,GAAkBzE,WAAY,SAAC2E,OAACzC,EAAMyC,EAAAzC,OAAM,OAAA,IAAIuC,GAAiBvC,IAAS1D,KAAM,CAAC6N,KAC3F,CAAC/P,QAASiP,GAAStL,SAAUsL,GAAS/M,KAAM,CAACwM,GAASK,GAAwB7B,GAAmB1E,KACjG,CAACxI,QAASoP,GAAoBzL,SAAUyL,GAAoBlN,KAAM,CAACiG,KACnE,CAACnI,QAASgP,GAAqBrL,SAAUqL,GAAqB9M,KAAM,CAACwM,GAASxB,oBC1DlF,SAAA+C,YACIA,EAAAvY,UAAAwY,MAAA,SAAS1O,GAEL,OAAA/H,OAAA0W,OAAA,CAAQvK,OADI,cACOpE,aCDd4O,GAAqB,CAC9B,CAACpQ,QAASuN,GAAwB5J,SAAU4J,GAAwBrL,KAAM,CAACuE,GAAS8C,MCD3E8G,GAAyB,IAAI3T,EAAwE,0BCFlH4T,GAGI,SAAoBC,GAApB,IAAAxL,EAAA3M,KAAoBA,KAAAmY,MAAAA,EAFZnY,KAAAoY,QAAU,EAKTpY,KAAAkV,OAAS,SAACmD,GACL,IAANA,GACA1L,EAAKyL,WAIJpY,KAAA8P,WAAa,WAAM,OAAAnD,EAAKyL,SAAWzL,EAAKwL,QCZrDG,GAAA,WACatY,KAAAkV,OAAS,aACTlV,KAAA8P,WAAa,WAAM,OAAA,ICFhCyI,GAAA,WAAA,IAAA5L,EAAA3M,KACYA,KAAAwY,QAAS,EAERxY,KAAAkV,OAAS,SAACmD,GACL,IAANA,IACA1L,EAAK6L,QAAS,IAIbxY,KAAA8P,WAAa,WAAM,OAAgB,IAAhBnD,EAAK6L,SCTrCC,GAAA,WACazY,KAAA8P,WAAa,WAAM,OAAA,GACnB9P,KAAAkV,OAAS,cCatBwD,GAGI,SAAoBC,GAApB,IAAAhM,EAAA3M,KAAoBA,KAAA2Y,SAAAA,EAFZ3Y,KAAA6R,MAAQ,EAKP7R,KAAAkV,OAAS,WACdvI,EAAKkF,SAGA7R,KAAA8P,WAAa,WAClB,QAAInD,EAAKkF,OAASlF,EAAKgM,SAASpW,SACzBoK,EAAKgM,SAAShM,EAAKkF,SCPlC+G,GAAA,WAAA,SAAAA,YAOkBA,EAAAC,QAAP,SAAeV,GAClB,OAAO,IAAID,GAAgBC,IAMjBS,EAAAE,OAAP,WACH,OAAOF,EAAUG,QAMPH,EAAAI,MAAP,WACH,OAAOJ,EAAUK,OAMPL,EAAAM,KAAP,WACH,OAAO,IAAIX,IAqBDK,EAAAO,SAAP,SAAgBR,GACnB,OAAO,IAAID,GAAiBC,MAnDpC,GAC4BC,GAAAG,OAAS,IAAIN,GACbG,GAAAK,MAAQ,IAAIX,qBCTpC,SAAAc,EACYrD,EACArQ,EACA8H,EACAmB,QAAA,IAAAA,IAAAA,EAAsBiK,GAAUE,UAHhC9Y,KAAA+V,KAAAA,EACA/V,KAAA0F,IAAAA,EACA1F,KAAAwN,OAAAA,EACAxN,KAAA2O,SAAAA,SAILyK,EAAA9Z,UAAA+Z,OAAA,SAAOzK,GACV,IAAMR,EAAS,IAAIY,GAAahP,KAAK2O,SAAU3O,KAAKwN,OAAQoB,GAE5D,OADA5O,KAAK0F,IAAI0I,GACFpO,KAAK+V,MAGTqD,EAAA9Z,UAAAga,QAAA,SAAQ7W,GACX,IAAM2L,EAAS,IAAImG,GAAcvU,KAAK2O,SAAU3O,KAAKwN,OAAQ/K,GAE7D,OADAzC,KAAK0F,IAAI0I,GACFpO,KAAK+V,MAGTqD,EAAA9Z,UAAAia,OAAA,SAAmBpF,GACtB,IAAM/F,EAAS,IAAIqG,GAAazU,KAAK2O,SAAU3O,KAAKwN,OAAQ2G,GAE5D,OADAnU,KAAK0F,IAAI0I,GACFpO,KAAK+V,MAGTqD,EAAA9Z,UAAA2U,SAAA,SAASA,GACZ,IAAM7F,EAAS,IAAIoG,GAAgBxU,KAAK2O,SAAU3O,KAAKwN,OAAQyG,GAE/D,OADAjU,KAAK0F,IAAI0I,GACFpO,KAAK+V,MAGTqD,EAAA9Z,UAAA0U,KAAA,SAAKrF,GAER,OADA3O,KAAK2O,SAAWA,EACT3O,WC3CFwZ,GAAmB,CAC5B,CAAC5R,QAASyG,GAAS9C,SAAU8C,GAASvE,KAAM,IAC5C,CACIlC,QAASqQ,GAAwB3M,WAAY,SAACyK,EAAMhI,GAAY,OAAA,SAAIP,GAChE,OAAA,IAAI4L,GAAiBrD,GAAM,SAAA3H,GAAU,OAAAL,EAAQO,IAAIF,KAASZ,KAAS1D,KAAM,CAAC4N,GAAMrJ,MCM/EoL,GAAO/K,uBChBpB,SAAAgL,IACY1Z,KAAAyC,MAAQ,SAETiX,EAAApa,UAAAkD,KAAA,WACH,OAAOxC,KAAKyC,cCDPkX,GAAmB,CAC5B,CAAC/R,QAAS8R,GAAYnO,SAAUmO,GAAY5P,KAAM,IAClD,CAAClC,QAAS0O,GAAS/K,SAAU+K,GAASxM,KAAM,CAAC4P,oBCC7C,SAAAE,EAAoBC,GAAA7Z,KAAA6Z,kBAAAA,SAIbD,EAAAta,UAAA6Y,MAAA,SAASnG,EAAkC8H,WAC1C3B,EAAQ,MACZ,IAAyB,IAAA4B,EAAA/X,EAAA8X,GAAWE,EAAAD,EAAAvX,QAAAwX,EAAAtX,KAAAsX,EAAAD,EAAAvX,OAAE,CAAjC,IAAM4K,EAAU4M,EAAAvX,OAC4C,IAAzDzC,KAAK6Z,kBAAkBla,QAAQyN,EAAY4E,KAC3CmG,GAAS,qGAIjB,OAAOA,uBCpBX,SAAA8B,EAAYzP,UACR+B,EAAA5K,KAAA3B,KAAMwK,IAAQxK,YAFW4B,EAAAqY,EAAA1N,MAAAxF,qBCe7B,SAAAmT,EACYC,EACAC,EACAC,GAFAra,KAAAma,UAAAA,EACAna,KAAAoa,YAAAA,EACApa,KAAAqa,gBAAAA,SAILH,EAAA5a,UAAAa,KAAA,SAAK6R,EAAkCsI,EAAcR,EAA4B3H,GACpF,IAAM/E,EAAapN,KAAKma,UAAUhN,QAAQ6E,GACpCuI,EAAYva,KAAKoa,YAAYjC,MAAM/K,EAAY0M,GAErD,IAAe,IADAQ,EAAMna,KAAKoa,GACJ,CAClB,IAAM/P,EAAUxK,KAAKqa,gBAAgB1I,OAAOvE,EAAYkN,EAAM9P,QAAS+P,EAAWT,EAAa3H,GAC/F,MAAM,IAAI8H,GAAYzP,UCnBrBgQ,GAAwB,CACjC,CAAC5S,QAASsS,GAAU3O,SAAU2O,GAAUpQ,KAAM,CAACoD,GAA6B0M,GAAahH,KACzF,CAAChL,QAASgS,GAAarO,SAAUqO,GAAa9P,KAAM,CAACqH,wgECJjB/H,GACpC,MAAO,CACH,CAACxB,QAASiQ,GAAoBtM,SAAUsM,GAAoB/N,KAAM,IAClE,CAAClC,QAAS+P,GAAcrM,WAAY,SAAAmP,GAAW,OAAAA,EAAQ3C,MAAM1O,IAAUU,KAAM,CAAC+N","sourcesContent":["/**\n * @hidden\n */\nexport class CommonTypeProvider {\n    public ofType(left: unknown, right: unknown) {\n        return typeof left && typeof right;\n    }\n}\n\n","import { IObjectMatcher } from \"./object-matcher.type\";\n\n/**\n * Matches Date objects\n */\nexport class DateMatcher implements IObjectMatcher {\n    public matched<T = Date>(left: T, right: T): boolean {\n        if (left instanceof Date && right instanceof Date) {\n            return left.valueOf() === right.valueOf();\n        }\n        return undefined;\n    }\n}\n\n","/*eslint @typescript-eslint/naming-convention: \"off\"*/\nexport type IPredicate<T> = (instance: T) => boolean;\n\n/**\n * This class allows to express wide range of cases in an expression.\n * You can use it with setups or verifies methods.\n *\n * @example\n * ```typescript\n *\n *  const value = 'value';\n *  const object = new Mock<Function>()\n *  .setup(instance => instance(1))\n *  .returns(value)\n *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))\n *  .returns(value)\n *  .setup(instance => instance(It.IsAny())\n *  .returns(value)\n *  .object();\n *\n *  const actual = object(1);\n *\n *  expect(actual).toBe(value);\n * ```\n *\n * This class could be used not only for args matching, but also for function names, property names and so on.\n *\n * @example\n * ```typescript\n *\n * const object = new Mock<ITestObject>()\n * // the expression dynamically checks the property name that is being read\n * .setup(instance => It.Is((expression: ExpectedGetPropertyExpression) => expression.name === 'property'))\n * .returns(value)\n * .object();\n *\n * const object = new Mock<ITestObject>()\n * //denis any write operation on the property\n * .setup(instance => { instance.property = It.IsAny()})\n * // true - allow, false - deny\n * .returns(false)\n * .object();\n *\n * const object = new Mock<ITestObject>()\n * .setup(instance => It.Is((expression: ExpectedNamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))\n * .returns(value)\n * .object();\n *\n * // how to use with verify\n * mock.verify(instance => instance.method(It.Is(a => a === 2)));\n * ```\n */\nexport class It<P> {\n    constructor(public predicate: IPredicate<P>) {\n\n    }\n\n    /**\n     * This factory method returns an expression that matches custom cases.\n     *\n     * @example\n     * ```typescript\n     *\n     *  const value = 'value';\n     *  const object = new Mock<Function>()\n     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))\n     *  .returns(value)\n     *  .object();\n     *\n     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);\n     *\n     *  expect(actual).toBe(value);\n     * ```\n     */\n    public static Is<T>(predicate: IPredicate<T>): It<T> | any {\n        return new It(predicate);\n    }\n\n    /**\n     * This factory method returns a wildcat expression that matches any value.\n     *\n     * @example\n     * ```typescript\n     *\n     *  const value = 'value';\n     *  const object = new Mock<Function>()\n     *  .setup(instance => instance(It.IsAny())\n     *  .returns(value)\n     *  .object();\n     *\n     *  const actual = object(any_value_will_trigger_the_setup);\n     *\n     *  expect(actual).toBe(value);\n     * ```\n     */\n    public static IsAny<T>(): It<T> | any {\n        return new It(() => true);\n    }\n\n    /**\n     * @hidden\n     */\n    public test(instance?: P): boolean {\n        try {\n            const result = this.predicate(instance);\n            return result === true || result === undefined;\n        } catch (e) {\n            return false;\n        }\n    }\n}\n","import { It } from \"../expected-expressions/expression-predicates\";\nimport { EqualMatcher } from \"./equal.matcher\";\n\n/**\n * @hidden\n */\nexport class EqualConstantMatcher {\n    constructor(private equalMatcher: EqualMatcher) {\n    }\n\n    public matched(left: any, right: any | It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n        return this.equalMatcher.matched(left, right);\n    }\n}\n\n","import { PrimitiveMatcher } from \"./primitive.matcher\";\nimport { TypesMatcher } from \"./types.matcher\";\nimport { CommonTypeProvider } from \"./common-type.provider\";\nimport { ObjectMatcher } from \"./object.matcher\";\nimport { FunctionMatcher } from \"./function.matcher\";\n\n/**\n * @hidden\n */\nexport class EqualMatcher {\n\n    constructor(\n        private typesMatcher: TypesMatcher,\n        private commonTypeProvider: CommonTypeProvider,\n        private primitiveMatcher: PrimitiveMatcher,\n        private objectMatcher: ObjectMatcher,\n        private functionMatcher: FunctionMatcher) {\n    }\n\n    public matched(left: any, right: any): boolean {\n        if (this.typesMatcher.matched(left, right) === false) {\n            return false;\n        }\n\n        switch (this.commonTypeProvider.ofType(left, right)) {\n            case \"undefined\":\n                return this.primitiveMatcher.matched(left, right);\n            case \"object\":\n                return this.objectMatcher.matched(left, right);\n            case \"boolean\":\n                return this.primitiveMatcher.matched(left, right);\n            case \"number\":\n                return this.primitiveMatcher.matched(left, right);\n            case \"string\":\n                return this.primitiveMatcher.matched(left, right);\n            case \"function\":\n                return this.functionMatcher.matched(left, right);\n            case \"symbol\":\n                return this.primitiveMatcher.matched(left, right);\n            case \"bigint\":\n                return this.primitiveMatcher.matched(left, right);\n        }\n    }\n}\n\n","/**\n * @hidden\n */\nexport class TypesMatcher {\n\n    public matched(left: unknown, right: unknown): boolean {\n        return typeof left === typeof right;\n    }\n}\n\n","/**\n * @hidden\n */\nexport class PrimitiveMatcher {\n\n    public matched<T extends (string | number | bigint | boolean | symbol)>(left: T, right: T): boolean {\n        return left === right;\n    }\n}\n\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { TypeofInjectionToken } from \"../typeof-injection-token\";\nimport { OBJECT_MATCHERS } from \"./object-matchers.injection-token\";\n\n/**\n * @hidden\n */\nexport class ObjectMatcher {\n\n    constructor(\n        private matchers: TypeofInjectionToken<typeof OBJECT_MATCHERS>) {\n    }\n\n    public matched<T extends Record<string, unknown>>(left: T, right: T): boolean {\n        if (left === null && right === null) return true;\n        if (left === right) return true;\n        for (const matcher of this.matchers) {\n            const matched = matcher.matched(left, right);\n            if (matched === undefined) {\n                continue;\n            }\n            return matched;\n        }\n\n        return false;\n    }\n}\n\n","/**\n * @hidden\n */\nexport class FunctionMatcher {\n\n    public matched<T extends (...args) => unknown>(left: T, right: T): boolean {\n        return left === right;\n    }\n}\n\n","/**\n * @hidden\n */\nexport class IterableTester {\n\n    public verify(left: unknown, right: unknown) {\n        return typeof left[Symbol.iterator] === \"function\" && typeof right[Symbol.iterator] === \"function\";\n    }\n}\n","import { It } from \"../expected-expressions/expression-predicates\";\n\n/**\n * @hidden\n */\nexport class ConstantMatcher {\n    public matched(left: any, right: any | It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n        return left === right;\n    }\n}\n\n","import { IterableTester } from \"./iterable.tester\";\nimport { ConstantMatcher } from \"../expression-matchers/constant.matcher\";\nimport { IObjectMatcher } from \"./object-matcher.type\";\nimport { Injector } from \"../static.injector/injector\";\n\n/**\n * Matches objects that support Iterable protocol\n */\nexport class IteratorMatcher implements IObjectMatcher {\n\n    constructor(\n        private injector: Injector,\n        private iterableTester: IterableTester) {\n    }\n\n    /*eslint-disable-next-line @typescript-eslint/ban-types*/\n    public matched<T extends object>(left: T, right: T): boolean {\n        if (this.iterableTester.verify(left, right) === true) {\n            const leftIterator = [...left[Symbol.iterator]()];\n            const rightIterator = [...right[Symbol.iterator]()];\n            if (leftIterator.length !== rightIterator.length) return false;\n\n            const constantMatcher = this.injector.get(ConstantMatcher);\n            for (let i = 0; i < leftIterator.length; i++) {\n                const leftValue = leftIterator[i];\n                const rightValue = rightIterator[i];\n                if (constantMatcher.matched(leftValue, rightValue) === false) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        return undefined;\n    }\n}\n\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport class InjectionToken<T> {\n    constructor(protected desc: string) {\n    }\n\n    toString(): string {\n        return `InjectionToken ${this.desc}`;\n    }\n}\n","import { IObjectMatcher } from \"./object-matcher.type\";\nimport { InjectionToken } from \"../static.injector/injection_token\";\n\nexport const OBJECT_MATCHERS = new InjectionToken<IObjectMatcher[]>(\"OBJECT_MATCHERS\");\n","import { ObjectMapProvider } from \"./object-map.provider\";\nimport { IObjectMatcher } from \"./object-matcher.type\";\nimport { MapMatcher } from \"./map.matcher\";\n\n/**\n * Matches objects as POJO\n */\nexport class POJOMatcher implements IObjectMatcher {\n    constructor(\n        private mapMatcher: MapMatcher,\n        private objectMapProvider: ObjectMapProvider) {\n    }\n\n    /*eslint-disable-next-line @typescript-eslint/ban-types*/\n    public matched<T extends object>(left: T, right: T): boolean {\n        const leftProps = this.objectMapProvider.get(left);\n        const rightProps = this.objectMapProvider.get(right);\n        return this.mapMatcher.matched(leftProps, rightProps);\n    }\n}\n","/**\n * @hidden\n */\nexport class ObjectMapProvider {\n    /*eslint-disable-next-line @typescript-eslint/ban-types*/\n    get(object: object) {\n        const props = this.getProps(object, []);\n        const keys = [...new Set<PropertyKey>(props)];\n        const map = new Map<PropertyKey, any>();\n        for (const key of keys) {\n            map.set(key, object[key]);\n        }\n\n        return map;\n    }\n\n    private getProps(object, props: PropertyKey[]): PropertyKey[] {\n        if (object === null) return props;\n        if (object === Object.prototype) return props;\n        props = [...props, ...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];\n        return this.getProps(Object.getPrototypeOf(object), props);\n    }\n}\n\n","import { IObjectMatcher } from \"./object-matcher.type\";\nimport { ConstantMatcher } from \"../expression-matchers/constant.matcher\";\nimport { Injector } from \"../static.injector/injector\";\n\n/**\n * Matches Map objects\n */\nexport class MapMatcher implements IObjectMatcher {\n    constructor(private injector: Injector) {\n    }\n\n    public matched<T = Map<unknown, unknown>>(left: T, right: T): boolean {\n        if (left instanceof Map && right instanceof Map) {\n            if (left.size !== right.size) return false;\n            const constantMatcher = this.injector.get(ConstantMatcher);\n            for (const [key, value] of left) {\n                if (right.has(key) === false) return false;\n                if (constantMatcher.matched(value, right.get(key)) === false) return false;\n            }\n            return true;\n        }\n        return undefined;\n    }\n}\n\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport function stringify(token: any): string {\n    if (typeof token === \"string\") {\n        return token;\n    }\n\n    if (Array.isArray(token)) {\n        return `[${token.map(stringify).join(\", \")}]`;\n    }\n\n    if (token == null) {\n        return `${  token}`;\n    }\n\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n\n    if (token.name) {\n        return `${token.name}`;\n    }\n\n    const res = token.toString();\n\n    if (res == null) {\n        return `${  res}`;\n    }\n\n    const newLineIndex = res.indexOf(\"\\n\");\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (const key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error(\"Could not find renamed property on target object.\");\n}\n","/* eslint-disable */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport { Type } from \"./type\";\nimport { stringify } from \"./stringify\";\nimport { getClosureSafeProperty } from \"./property\";\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport type ForwardRefFn = () => any;\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n    (<any>forwardRefFn).__forward_ref__ = forwardRef;\n    (<any>forwardRefFn).toString = function () {\n        return stringify(this());\n    };\n    return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n    return isForwardRef(type) ? type() : type;\n}\n\n/** Checks whether a function is wrapped by a `forwardRef`. */\nexport function isForwardRef(fn: any): fn is() => any {\n    return typeof fn === \"function\" && fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef;\n}\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from \"./injection_token\";\nimport { Injector } from \"./injector\";\nimport { ValueProvider } from \"./interface/provider\";\nimport { getClosureSafeProperty } from \"./property\";\nimport { stringify } from \"./stringify\";\n\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>(\n    \"INJECTOR\"\n);\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport const NG_TEMP_TOKEN_PATH = \"ngTempTokenPath\";\nconst NG_TOKEN_PATH = \"ngTokenPath\";\nconst NEW_LINE = /\\n/gm;\nexport const NO_NEW_LINE = \"ɵ\";\nexport const SOURCE = \"__source\";\n\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nexport class NullInjector implements Injector {\n    get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n            error.name = \"NullInjectorError\";\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\n\nexport function catchInjectorError(\n    e: any, token: any, injectorErrorName: string, source: string | null): never {\n    const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n    if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n    }\n    e.message = formatError(`\\n${e.message}`, tokenPath, injectorErrorName, source);\n    e[NG_TOKEN_PATH] = tokenPath;\n    e[NG_TEMP_TOKEN_PATH] = null;\n    throw e;\n}\n\nexport function formatError(\n    text: string, obj: any, injectorErrorName: string, source: string | null = null): string {\n    text = text && text.charAt(0) === \"\\n\" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;\n    let context = stringify(obj);\n    if (Array.isArray(obj)) {\n        context = obj.map(stringify).join(\" -> \");\n    } else if (typeof obj === \"object\") {\n        const parts = <string[]>[];\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                const value = obj[key];\n                parts.push(\n                    `${key}:${typeof value === \"string\" ? JSON.stringify(value) : stringify(value)}`);\n            }\n        }\n        context = `{${parts.join(\", \")}}`;\n    }\n    return `${injectorErrorName}${source ? `(${source})` : \"\"}[${context}]: ${\n        text.replace(NEW_LINE, \"\\n  \")}`;\n}\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n    // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n    /** Check self and check parent injector if needed */\n    Default = 0b0000,\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    Host = 0b0001,\n    /** Don't ascend to ancestors of the node requesting injection. */\n    Self = 0b0010,\n    /** Skip the node that is requesting injection. */\n    SkipSelf = 0b0100,\n    /** Inject `defaultValue` instead if token not found. */\n    Optional = 0b1000,\n}\n","/* eslint-disable */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Type of the Optional metadata.\n */\nexport class Optional {\n\n}\n\n/**\n * Type of the Self metadata.\n */\nexport class Self {\n\n}\n\n/**\n * Type of the SkipSelf metadata.\n */\nexport class SkipSelf {\n\n}\n\n/**\n * Type of the Host metadata.\n */\nexport class Host {\n\n}\n\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport { resolveForwardRef } from \"./forward_ref\";\nimport { InjectionToken } from \"./injection_token\";\nimport {\n    catchInjectorError,\n    formatError,\n    INJECTOR,\n    NG_TEMP_TOKEN_PATH, NO_NEW_LINE,\n    NullInjector,\n    THROW_IF_NOT_FOUND,\n    USE_VALUE\n} from \"./injector_compatibility\";\nimport { InjectFlags } from \"./interface/injector\";\nimport {\n    ConstructorProvider,\n    ExistingProvider,\n    FactoryProvider,\n    StaticClassProvider,\n    StaticProvider,\n    ValueProvider\n} from \"./interface/provider\";\nimport { Optional, Self, SkipSelf } from \"./metadata\";\nimport { AbstractType, Type } from \"./type\";\nimport { stringify } from \"./stringify\";\n\nexport const INJECTOR_IMPL = (\n    providers: StaticProvider[], parent: Injector | undefined, name: string) => new StaticInjector(providers, parent, name);\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n    static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n    static NULL: Injector = new NullInjector();\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = -1;\n\n    /**\n     * Creates a new injector instance that provides one or more dependencies,\n     * according to a given type or types of `StaticProvider`.\n     *\n     * @param options An object with the following properties:\n     * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n     * * `parent`: (optional) A parent injector.\n     * * `name`: (optional) A developer-defined identifying name for the new injector.\n     *\n     * @returns The new injector instance.\n     *\n     */\n    static create(options: { providers: StaticProvider[]; parent?: Injector; name?: string }): Injector;\n\n    static create(\n        options: StaticProvider[] | { providers: StaticProvider[]; parent?: Injector; name?: string },\n        parent?: Injector): Injector {\n        if (Array.isArray(options)) {\n            return INJECTOR_IMPL(options, parent, \"\");\n        } else {\n            return INJECTOR_IMPL(options.providers, options.parent, options.name || \"\");\n        }\n    }\n\n    /**\n     * Retrieves an instance from the injector based on the provided token.\n     *\n     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n     */\n    abstract get<T>(\n        token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n}\n\n\nconst IDENT = function <T>(value: T): T {\n    return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function (): any[] {\n    return Array.prototype.slice.call(arguments);\n};\n\nconst enum OptionFlags {\n    Optional = 1,\n    CheckSelf = 2,\n    CheckParent = 4,\n    // eslint-disable-next-line no-bitwise\n    Default = CheckSelf | CheckParent\n}\n\nexport class StaticInjector implements Injector {\n    readonly parent: Injector;\n    readonly source: string | null;\n    readonly scope: string | null;\n\n    private _records: Map<any, Record | null>;\n\n    constructor(\n        providers: StaticProvider[], parent = new NullInjector(), source: string | null = null) {\n        this.parent = parent;\n        this.source = source;\n        const records = this._records = new Map<any, Record>();\n        records.set(Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n        records.set(INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n        this.scope = recursivelyProcessProviders(records, providers);\n    }\n\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    get(token: any, notFoundValue?: any): any;\n    get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n        const records = this._records;\n        const record = records.get(token);\n        if (record === undefined) {\n            records.set(token, null);\n        }\n        try {\n            return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);\n        } catch (e) {\n            return catchInjectorError(e, token, \"StaticInjectorError\", this.source);\n        }\n    }\n\n    toString() {\n        const tokens = <string[]>[]; const records = this._records;\n        records.forEach((v, token) => tokens.push(stringify(token)));\n        return `StaticInjector[${tokens.join(\", \")}]`;\n    }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n    fn: Function;\n    useNew: boolean;\n    deps: DependencyRecord[];\n    value: any;\n}\n\ninterface DependencyRecord {\n    token: any;\n    options: number;\n}\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n    const deps = computeDeps(provider);\n    let fn: Function = IDENT;\n    let value: any = EMPTY;\n    let useNew = false;\n    const provide = resolveForwardRef(provider.provide);\n    if (USE_VALUE in provider) {\n        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n        value = (provider as ValueProvider).useValue;\n    } else if ((provider as FactoryProvider).useFactory) {\n        fn = (provider as FactoryProvider).useFactory;\n    } else if ((provider as ExistingProvider).useExisting) {\n        // Just use IDENT\n    } else if ((provider as StaticClassProvider).useClass) {\n        useNew = true;\n        fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n    } else if (typeof provide === \"function\") {\n        useNew = true;\n        fn = provide;\n    } else {\n        throw staticError(\n            \"StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable\",\n            provider);\n    }\n    return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n    return staticError(\"Cannot mix multi providers and regular providers\", token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider): string |\n    null {\n    let scope: string | null = null;\n    if (provider) {\n        provider = resolveForwardRef(provider);\n        if (Array.isArray(provider)) {\n            // if we have an array recurse into the array\n            for (let i = 0; i < provider.length; i++) {\n                scope = recursivelyProcessProviders(records, provider[i]) || scope;\n            }\n        } else if (typeof provider === \"function\") {\n            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n            // error messages\n            throw staticError(\"Function/Class not supported\", provider);\n        } else if (provider && typeof provider === \"object\" && provider.provide) {\n            // At this point we have what looks like a provider: {provide: ?, ....}\n            let token = resolveForwardRef(provider.provide);\n            const resolvedProvider = resolveProvider(provider);\n            if (provider.multi === true) {\n                // This is a multi provider.\n                let multiProvider: Record | undefined = records.get(token);\n                if (multiProvider) {\n                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n                        throw multiProviderMixError(token);\n                    }\n                } else {\n                    // Create a placeholder factory which will look up the constituents of the multi provider.\n                    records.set(token, multiProvider = <Record>{\n                        token: provider.provide,\n                        deps: [],\n                        useNew: false,\n                        fn: MULTI_PROVIDER_FN,\n                        value: EMPTY\n                    });\n                }\n                // Treat the provider as the token.\n                token = provider;\n                multiProvider.deps.push({token, options: OptionFlags.Default});\n            }\n            const record = records.get(token);\n            if (record && record.fn === MULTI_PROVIDER_FN) {\n                throw multiProviderMixError(token);\n            }\n            records.set(token, resolvedProvider);\n        } else {\n            throw staticError(\"Unexpected provider\", provider);\n        }\n    }\n    return scope;\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined | null, records: Map<any, Record | null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n    try {\n        return resolveToken(token, record, records, parent, notFoundValue, flags);\n    } catch (e) {\n        // ensure that 'e' is of type Error.\n        if (!(e instanceof Error)) {\n            e = new Error(e);\n        }\n        const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(token);\n        if (record && record.value === CIRCULAR) {\n            // Reset the Circular flag.\n            record.value = EMPTY;\n        }\n        throw e;\n    }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined | null, records: Map<any, Record | null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n    let value;\n    // eslint-disable-next-line no-bitwise\n    if (record && !(flags & InjectFlags.SkipSelf)) {\n        // If we don't have a record, this implies that we don't own the provider hence don't know how\n        // to resolve it.\n        value = record.value;\n        if (value === CIRCULAR) {\n            throw Error(`${NO_NEW_LINE  }Circular dependency`);\n        } else if (value === EMPTY) {\n            record.value = CIRCULAR;\n            const {useNew, fn, deps: depRecords} = record;\n            let deps = EMPTY;\n            if (depRecords.length) {\n                deps = [];\n                for (let i = 0; i < depRecords.length; i++) {\n                    const depRecord: DependencyRecord = depRecords[i];\n                    const options = depRecord.options;\n                    // eslint-disable-next-line no-bitwise\n                    const childRecord = options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n                    deps.push(tryResolveToken(\n                        // Current Token to resolve\n                        depRecord.token,\n                        // A record which describes how to resolve the token.\n                        // If undefined, this means we don't have such a record\n                        childRecord,\n                        // Other records we know about.\n                        records,\n                        // If we don't know how to resolve dependency and we should not check parent for it,\n                        // than pass in Null injector.\n                        // eslint-disable-next-line no-bitwise\n                        !childRecord && !(options & OptionFlags.CheckParent) ? Injector.NULL : parent,\n                        // eslint-disable-next-line no-bitwise\n                        options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n                        InjectFlags.Default));\n                }\n            }\n            record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(undefined, deps);\n        }\n        // eslint-disable-next-line no-bitwise\n    } else if (!(flags & InjectFlags.Self)) {\n        value = parent.get(token, notFoundValue, InjectFlags.Default);\n        // eslint-disable-next-line no-bitwise\n    } else if (!(flags & InjectFlags.Optional)) {\n        value = Injector.NULL.get(token, notFoundValue);\n    } else {\n        value = Injector.NULL.get(token, typeof notFoundValue !== \"undefined\" ? notFoundValue : null);\n    }\n    return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n    let deps: DependencyRecord[] = EMPTY;\n    const providerDeps: any[] =\n        (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n    if (providerDeps && providerDeps.length) {\n        deps = [];\n        for (let i = 0; i < providerDeps.length; i++) {\n            let options = OptionFlags.Default;\n            let token = resolveForwardRef(providerDeps[i]);\n            if (Array.isArray(token)) {\n                for (let j = 0, annotations = token; j < annotations.length; j++) {\n                    const annotation = annotations[j];\n                    if (annotation instanceof Optional || annotation === Optional) {\n                        // eslint-disable-next-line no-bitwise\n                        options = options | OptionFlags.Optional;\n                    } else if (annotation instanceof SkipSelf || annotation === SkipSelf) {\n                        // eslint-disable-next-line no-bitwise\n                        options = options & ~OptionFlags.CheckSelf;\n                    } else if (annotation instanceof Self || annotation === Self) {\n                        // eslint-disable-next-line no-bitwise\n                        options = options & ~OptionFlags.CheckParent;\n                    } else {\n                        token = resolveForwardRef(annotation);\n                    }\n                }\n            }\n            deps.push({token, options});\n        }\n    } else if ((provider as ExistingProvider).useExisting) {\n        const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n        deps = [{token, options: OptionFlags.Default}];\n    } else if (!providerDeps && !(USE_VALUE in provider)) {\n        // useValue & useExisting are the only ones which are exempt from deps all others need it.\n        throw staticError(\"'deps' required\", provider);\n    }\n    return deps;\n}\n\nfunction staticError(text: string, obj: any): Error {\n    return new Error(formatError(text, obj, \"StaticInjectorError\"));\n}\n","import { EqualMatcher } from \"./equal.matcher\";\nimport { EqualConstantMatcher } from \"./equal-constant.matcher\";\nimport { CommonTypeProvider } from \"./common-type.provider\";\nimport { TypesMatcher } from \"./types.matcher\";\nimport { PrimitiveMatcher } from \"./primitive.matcher\";\nimport { ObjectMatcher } from \"./object.matcher\";\nimport { FunctionMatcher } from \"./function.matcher\";\nimport { IterableTester } from \"./iterable.tester\";\nimport { IteratorMatcher } from \"./iterator.matcher\";\nimport { OBJECT_MATCHERS } from \"./object-matchers.injection-token\";\nimport { POJOMatcher } from \"./pojo.matcher\";\nimport { ObjectMapProvider } from \"./object-map.provider\";\nimport { MapMatcher } from \"./map.matcher\";\nimport { ConstantMatcher } from \"../expression-matchers/constant.matcher\";\nimport { Injector } from \"../static.injector/injector\";\n\n/**\n * @hidden\n */\nexport const equalMatchersProviders = [\n    {provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: []},\n    {provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [EqualMatcher]},\n    {provide: ConstantMatcher, useExisting: EqualConstantMatcher},\n    {\n        provide: EqualMatcher, useClass: EqualMatcher, deps: [\n            TypesMatcher,\n            CommonTypeProvider,\n            PrimitiveMatcher,\n            ObjectMatcher,\n            FunctionMatcher\n        ]\n    },\n    {provide: FunctionMatcher, useClass: FunctionMatcher, deps: []},\n    {provide: IterableTester, useClass: IterableTester, deps: []},\n    {\n        provide: IteratorMatcher, useClass: IteratorMatcher, deps: [\n            Injector,\n            IterableTester\n        ]\n    },\n    {provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS]},\n    {provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider]},\n    {provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: []},\n    {provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: []},\n    {provide: TypesMatcher, useClass: TypesMatcher, deps: []},\n    {provide: MapMatcher, useClass: MapMatcher, deps: [Injector]},\n];\n","/*eslint-disable max-classes-per-file*/\nexport abstract class Interaction {\n    protected constructor(\n        public readonly name: PropertyKey,\n        public readonly args: any[]) {\n\n    }\n}\n\n/**\n * This class represents an invocation of a named function.\n * It provides access to the name of function and list of parameters.\n */\nexport class NamedMethodInteraction extends Interaction {\n    constructor(name: PropertyKey,\n                args: any[]) {\n        super(name, args);\n    }\n}\n\n/**\n * This class represents an invocation of a function.\n * It provides access to the list of parameters.\n */\nexport class MethodInteraction extends Interaction {\n    constructor(args: any[]) {\n        super(undefined, args);\n    }\n}\n\n/**\n * This class represents a property accessing.\n * It provides access to the name of property.\n */\nexport class GetPropertyInteraction extends Interaction {\n    constructor(name: PropertyKey) {\n        super(name, undefined);\n    }\n}\n\n/**\n * This class represents a property write interaction.\n * It provides access to the name of property and the value.\n */\nexport class SetPropertyInteraction extends Interaction {\n    constructor(name: PropertyKey,\n                public readonly value: any) {\n        super(name, [value]);\n    }\n}\n\n/**\n * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).\n * It provides access to the name of property.\n */\nexport class InOperatorInteraction extends Interaction {\n    constructor(name: PropertyKey) {\n        super(name, undefined);\n    }\n}\n","/*eslint-disable max-classes-per-file*/\nimport { It } from \"./expression-predicates\";\nimport {\n    GetPropertyInteraction,\n    InOperatorInteraction,\n    MethodInteraction,\n    NamedMethodInteraction,\n    SetPropertyInteraction\n} from \"../interactions\";\n\n// todo: check if could be renamed in expressions\n/**\n * See {@link NamedMethodInteraction}\n */\nexport class ExpectedNamedMethodExpression extends NamedMethodInteraction {\n\n}\n\n/**\n * See {@link MethodInteraction}\n */\nexport class ExpectedMethodExpression extends MethodInteraction {\n\n}\n\n/**\n * See {@link GetPropertyInteraction}\n */\nexport class ExpectedGetPropertyExpression extends GetPropertyInteraction {\n\n}\n\n/**\n * See {@link SetPropertyInteraction}\n */\nexport class ExpectedSetPropertyExpression extends SetPropertyInteraction {\n\n}\n\n/**\n * See {@link InOperatorInteraction}\n */\nexport class ExpectedInOperatorExpression extends InOperatorInteraction {\n\n}\n\n/**\n * This types are special sub types of expressions that are used in an expectation context.\n */\nexport type ExpectedExpressions<T> =\n    ExpectedMethodExpression\n    | ExpectedGetPropertyExpression\n    | ExpectedSetPropertyExpression\n    | ExpectedInOperatorExpression\n    | ExpectedNamedMethodExpression\n    | It<T>;\n","import { It } from \"./expression-predicates\";\r\nimport {\r\n    ExpectedExpressions,\r\n    ExpectedGetPropertyExpression,\r\n    ExpectedInOperatorExpression,\r\n    ExpectedMethodExpression,\r\n    ExpectedNamedMethodExpression,\r\n    ExpectedSetPropertyExpression\r\n} from \"./expected-expressions\";\r\n\r\n/**\r\n * A function that accepts a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\r\n * and either plays expected interaction or returns a predicate function.\r\n * See {@link IMock.setup} function and {@link It} class for more details.\r\n */\r\nexport type IExpectedExpression<T> = (instance: T) => void | any | It<T>;\r\n\r\n/**\r\n * This class reflects an expression to an expression tree representation.\r\n *\r\n * @example\r\n * ```typescript\r\n *\r\n * const arg = 'argument';\r\n * const reflector = new ExpectedExpressionReflector();\r\n * const actual = reflector.reflect<any>(instance => instance(arg));\r\n *\r\n * const expected = new ExpectedMethodExpression([arg]);\r\n * expect(actual).toEqual(expected);\r\n * ```\r\n *\r\n * For more examples check\r\n * [unit tests for this class]\r\n * (https://github.com/dvabuzyarov/moq.ts/blob/master/tests.unit/expected-expressions/expected-expression-reflector.UnitTests.ts)\r\n */\r\nexport class ExpectedExpressionReflector {\r\n\r\n    private reflectedInfo;\r\n\r\n    /**\r\n     * Reflects the provided code as an expression tree.\r\n     */\r\n    public reflect<T>(expression: IExpectedExpression<T>): ExpectedExpressions<T> {\r\n        this.reflectedInfo = undefined;\r\n\r\n        const proxy = this.expressionProxy();\r\n        const predicate = expression(proxy);\r\n\r\n        return predicate instanceof It && (this.reflectedInfo instanceof ExpectedSetPropertyExpression) === false\r\n            ? predicate : this.reflectedInfo;\r\n    }\r\n\r\n    private expressionProxy(): any {\r\n\r\n        const options = {\r\n            get: (target, name) => {\r\n                this.reflectedInfo = new ExpectedGetPropertyExpression(name);\r\n                return (...args) => {\r\n                    this.reflectedInfo = new ExpectedNamedMethodExpression(name, args);\r\n                };\r\n            },\r\n\r\n            set: (target, name, value) => {\r\n                this.reflectedInfo = new ExpectedSetPropertyExpression(name, value);\r\n                return true;\r\n            },\r\n\r\n            apply: (target, thisArg, args) => {\r\n                this.reflectedInfo = new ExpectedMethodExpression(args);\r\n            },\r\n\r\n            has: (target, name) => {\r\n                this.reflectedInfo = new ExpectedInOperatorExpression(name);\r\n                return true;\r\n            }\r\n        };\r\n\r\n        return new Proxy(() => undefined, options);\r\n    }\r\n}\r\n","/**\n * @hidden\n */\nimport { ExpectedExpressionReflector } from \"./expected-expression-reflector\";\n\nexport const reflectorProviders = [\n    {provide: ExpectedExpressionReflector, useClass: ExpectedExpressionReflector, deps: []}\n];\n","import { InjectionToken } from \"../static.injector/injection_token\";\n\n/**\n * @hidden\n */\nexport const REFLECT_HAS = new InjectionToken<typeof Reflect.has>(\"Reflect has\");\n","import { ExpectedExpressions, ExpectedNamedMethodExpression } from \"../../expected-expressions/expected-expressions\";\n\n/**\n * @hidden\n */\nexport class ExpressionHasMethodExplorer {\n    public has(name: PropertyKey, expression: ExpectedExpressions<unknown>): boolean {\n        if (expression instanceof ExpectedNamedMethodExpression) {\n            return expression.name === name;\n        }\n\n        return false;\n    }\n}\n","import { PresetHasMethodExplorer } from \"./preset.has-method.explorer\";\nimport { Presets } from \"../../presets/presets\";\nimport { MembersMethodExplorer } from \"../members.explorer/members-method.explorer\";\n\n/**\n * @hidden\n */\nexport class HasMethodExplorer {\n    constructor(\n        private presets: Presets<unknown>,\n        private membersExplorer: MembersMethodExplorer,\n        private explorer: PresetHasMethodExplorer) {\n\n    }\n\n    public has(name: PropertyKey): boolean {\n        if (this.membersExplorer.hasMethod(name)) {\n            return true;\n        }\n\n        return this.presets\n            .get()\n            .find(preset => this.explorer.has(name, preset)) !== undefined;\n    }\n}\n","import { IPreset } from \"./presets/preset\";\n\n/**\n * @hidden\n */\nexport class Presets<T> {\n    private presets: IPreset<T>[] = [];\n\n    public add(preset: IPreset<T>): void {\n        this.presets.unshift(preset);\n    }\n\n    public get(): IPreset<T>[] {\n        return [...this.presets];\n    }\n}\n","import { PrototypeStorage } from \"../../interceptors/prototype.storage\";\nimport { PropertyDescriptorProvider } from \"./property-descriptor.provider\";\nimport { REFLECT_HAS } from \"../reflect-has.injection-token\";\nimport { TypeofInjectionToken } from \"../../typeof-injection-token\";\n\n/**\n * @hidden\n */\nexport class MembersMethodExplorer {\n    constructor(\n        private storage: PrototypeStorage,\n        private propertyDescriptorProvider: PropertyDescriptorProvider,\n        private has: TypeofInjectionToken<typeof REFLECT_HAS>) {\n\n    }\n\n    public hasMethod(name: PropertyKey): boolean {\n        const prototype = this.storage.get();\n        if (prototype && this.has(prototype, name)) {\n            const descriptor = this.propertyDescriptorProvider.get(prototype, name);\n            return descriptor.value instanceof Function;\n        }\n        return false;\n    }\n}\n\n","import { IPreset } from \"./preset\";\nimport { ExpectedExpressions } from \"../../expected-expressions/expected-expressions\";\nimport { IPlayable } from \"../../moq\";\n\nexport class MimicsPreset<T> implements IPreset<T> {\n    constructor(\n        public readonly playable: IPlayable,\n        public readonly target: ExpectedExpressions<T>,\n        public readonly origin: unknown) {\n\n    }\n}\n","import { IPreset } from \"../../presets/presets/preset\";\nimport { ExpressionHasMethodExplorer } from \"./expression.has-method.explorer\";\nimport { ObjectHasMethodExplorer } from \"./object.has-method.explorer\";\nimport { MimicsPreset } from \"../../presets/presets/mimics.preset\";\n\n/**\n * @hidden\n */\nexport class PresetHasMethodExplorer {\n    constructor(private expressionHasMethodExplorer: ExpressionHasMethodExplorer,\n                private objectHasMethodExplorer: ObjectHasMethodExplorer) {\n\n    }\n\n    public has(name: PropertyKey, preset: IPreset<unknown>): boolean {\n        if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {\n            return true;\n        }\n        return this.expressionHasMethodExplorer.has(name, preset.target);\n    }\n}\n","/**\n * @hidden\n */\nexport class ObjectHasMethodExplorer {\n    public has(name: PropertyKey, target: any): boolean {\n        return target[name] instanceof Function;\n    }\n}\n","import {\n    ExpectedExpressions,\n    ExpectedInOperatorExpression,\n    ExpectedMethodExpression,\n    ExpectedNamedMethodExpression\n} from \"../../expected-expressions/expected-expressions\";\nimport { It } from \"../../expected-expressions/expression-predicates\";\n\n/**\n * @hidden\n */\nexport class ExpressionHasPropertyExplorer {\n    public has(name: PropertyKey, expression: ExpectedExpressions<unknown>): boolean {\n        if (expression instanceof It\n            || expression instanceof ExpectedMethodExpression\n            || expression instanceof ExpectedNamedMethodExpression\n            || expression instanceof ExpectedInOperatorExpression) {\n            return false;\n        }\n\n        return expression.name === name;\n    }\n}\n","import { PresetHasPropertyExplorer } from \"./preset-has-property.explorer\";\nimport { Presets } from \"../../presets/presets\";\nimport { MembersPropertyExplorer } from \"../members.explorer/members-property.explorer\";\n\n/**\n * @hidden\n */\nexport class HasPropertyExplorer {\n    constructor(\n        private presets: Presets<unknown>,\n        private membersExplorer: MembersPropertyExplorer,\n        private explorer: PresetHasPropertyExplorer) {\n\n    }\n\n    public has(name: PropertyKey): boolean {\n        if (this.membersExplorer.hasProperty(name)) {\n            return true;\n        }\n        return this.presets\n            .get()\n            .find(preset => this.explorer.has(name, preset)) !== undefined;\n    }\n}\n","import { PrototypeStorage } from \"../../interceptors/prototype.storage\";\nimport { PropertyDescriptorProvider } from \"./property-descriptor.provider\";\nimport { REFLECT_HAS } from \"../reflect-has.injection-token\";\nimport { TypeofInjectionToken } from \"../../typeof-injection-token\";\n\n/**\n * @hidden\n */\nexport class MembersPropertyExplorer {\n    constructor(\n        private storage: PrototypeStorage,\n        private propertyDescriptorProvider: PropertyDescriptorProvider,\n        private has: TypeofInjectionToken<typeof REFLECT_HAS>) {\n\n    }\n\n    public hasProperty(name: PropertyKey): boolean {\n        const prototype = this.storage.get();\n        if (prototype && this.has(prototype, name)) {\n            const descriptor = this.propertyDescriptorProvider.get(prototype, name);\n            return descriptor.get !== undefined || (descriptor.value instanceof Function) === false;\n        }\n        return false;\n    }\n}\n","import { IPreset } from \"../../presets/presets/preset\";\nimport { ExpressionHasPropertyExplorer } from \"./expression-has-property.explorer\";\nimport { ObjectHasPropertyExplorer } from \"./object-has-property.explorer\";\nimport { MimicsPreset } from \"../../presets/presets/mimics.preset\";\n\n/**\n * @hidden\n */\nexport class PresetHasPropertyExplorer {\n    constructor(private expressionHasPropertyExplorer: ExpressionHasPropertyExplorer,\n                private objectHasPropertyExplorer: ObjectHasPropertyExplorer) {\n\n    }\n\n    public has(name: PropertyKey, preset: IPreset<unknown>): boolean {\n        if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {\n            return true;\n        }\n        return this.expressionHasPropertyExplorer.has(name, preset.target);\n    }\n}\n","/**\n * @hidden\n */\nexport class ObjectHasPropertyExplorer {\n    public has(name: PropertyKey, target: any): boolean {\n        return Reflect.has(target, name) && (target[name] instanceof Function) === false;\n    }\n}\n","import { PresetHasInOperatorExplorer } from \"./preset.has-in-operator.explorer\";\nimport { Presets } from \"../../presets/presets\";\n\n/**\n * @hidden\n */\nexport class InOperatorInteractionExplorer {\n    constructor(\n        private presets: Presets<unknown>,\n        private explorer: PresetHasInOperatorExplorer) {\n\n    }\n\n    public has(name: PropertyKey): boolean {\n        return this.presets\n            .get()\n            .find(preset => this.explorer.has(name, preset)) !== undefined;\n    }\n}\n","import { IPreset } from \"../../presets/presets/preset\";\nimport { InOperatorInteraction } from \"../../interactions\";\nimport { ExpectedInOperatorExpression } from \"../../expected-expressions/expected-expressions\";\nimport { It } from \"../../expected-expressions/expression-predicates\";\n\n/**\n * @hidden\n */\nexport class PresetHasInOperatorExplorer {\n    public has(name: PropertyKey, preset: IPreset<unknown>): boolean {\n        const {playable: {isPlayable}} = preset;\n\n        if (isPlayable() === false) {\n            return false;\n        }\n\n        if (preset.target instanceof ExpectedInOperatorExpression) {\n            return preset.target.name === name;\n        }\n\n        if (preset.target instanceof It) {\n            return preset.target.test(new InOperatorInteraction(name));\n        }\n\n        return false;\n    }\n}\n","/**\n * @hidden\n */\n\nexport class PrototypeStorage {\n    private prototype: any = null;\n\n    constructor(mockTarget: any) {\n        this.prototype = mockTarget?.prototype ?? mockTarget;\n    }\n\n    public get(): any {\n        return this.prototype;\n    }\n\n    public set(prototype: any): void {\n        this.prototype = prototype;\n    }\n}\n","/**\n * @hidden\n */\nexport class PropertyDescriptorProvider {\n    get(target: any, name: PropertyKey) {\n        let prototype = target;\n        while (prototype !== null) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);\n            if (descriptor !== undefined) return descriptor;\n            prototype = Reflect.getPrototypeOf(prototype);\n        }\n    }\n}\n","import { PrototypeStorage } from \"../../interceptors/prototype.storage\";\nimport { PropertyDescriptorProvider } from \"../members.explorer/property-descriptor.provider\";\nimport { TypeofInjectionToken } from \"../../typeof-injection-token\";\nimport { REFLECT_HAS } from \"../reflect-has.injection-token\";\n\n/**\n * @hidden\n */\nexport class PropertyIsReadOnlyTester {\n    constructor(\n        private storage: PrototypeStorage,\n        private propertyDescriptorProvider: PropertyDescriptorProvider,\n        private has: TypeofInjectionToken<typeof REFLECT_HAS>) {\n\n    }\n\n    public isReadOnly(name: PropertyKey): boolean {\n        const prototype = this.storage.get();\n        if (prototype && this.has(prototype, name)) {\n            const descriptor = this.propertyDescriptorProvider.get(prototype, name);\n            return descriptor.get instanceof Function && descriptor.set === undefined || descriptor.writable === false;\n        }\n        return false;\n    }\n}\n","import { ExpressionHasMethodExplorer } from \"./has-method.explorer/expression.has-method.explorer\";\nimport { HasMethodExplorer } from \"./has-method.explorer/has-method.explorer\";\nimport { Presets } from \"../presets/presets\";\nimport { MembersMethodExplorer } from \"./members.explorer/members-method.explorer\";\nimport { PresetHasMethodExplorer } from \"./has-method.explorer/preset.has-method.explorer\";\nimport { ObjectHasMethodExplorer } from \"./has-method.explorer/object.has-method.explorer\";\nimport { ExpressionHasPropertyExplorer } from \"./has-property.explorer/expression-has-property.explorer\";\nimport { HasPropertyExplorer } from \"./has-property.explorer/has-property.explorer\";\nimport { MembersPropertyExplorer } from \"./members.explorer/members-property.explorer\";\nimport { PresetHasPropertyExplorer } from \"./has-property.explorer/preset-has-property.explorer\";\nimport { ObjectHasPropertyExplorer } from \"./has-property.explorer/object-has-property.explorer\";\nimport { InOperatorInteractionExplorer } from \"./in-operator-interaction.explorer/in-operator-interaction.explorer\";\nimport { PresetHasInOperatorExplorer } from \"./in-operator-interaction.explorer/preset.has-in-operator.explorer\";\nimport { PrototypeStorage } from \"../interceptors/prototype.storage\";\nimport { PropertyDescriptorProvider } from \"./members.explorer/property-descriptor.provider\";\nimport { REFLECT_HAS } from \"./reflect-has.injection-token\";\nimport { PropertyIsReadOnlyTester } from \"./has-property.explorer/property-is-read-only.tester\";\n\n/**\n * @hidden\n */\nexport const typeExplorersProviders = [\n    {provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: []},\n    {\n        provide: HasMethodExplorer,\n        useClass: HasMethodExplorer,\n        deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]\n    },\n    {provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: []},\n    {\n        provide: PresetHasMethodExplorer,\n        useClass: PresetHasMethodExplorer,\n        deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]\n    },\n    {provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: []},\n    {\n        provide: HasPropertyExplorer,\n        useClass: HasPropertyExplorer,\n        deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]\n    },\n    {provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: []},\n    {\n        provide: PresetHasPropertyExplorer,\n        useClass: PresetHasPropertyExplorer,\n        deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]\n    },\n    {\n        provide: InOperatorInteractionExplorer,\n        useClass: InOperatorInteractionExplorer,\n        deps: [Presets, PresetHasInOperatorExplorer]\n    },\n    {provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: []},\n    {\n        provide: MembersMethodExplorer,\n        useClass: MembersMethodExplorer,\n        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]\n    },\n    {\n        provide: PropertyIsReadOnlyTester,\n        useClass: PropertyIsReadOnlyTester,\n        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]\n    },\n    {\n        provide: MembersPropertyExplorer,\n        useClass: MembersPropertyExplorer,\n        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]\n    },\n    {provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: []},\n    {provide: REFLECT_HAS, useValue: Reflect.has, deps: []},\n];\n","import { It } from \"../expected-expressions/expression-predicates\";\nimport { ConstantMatcher } from \"./constant.matcher\";\n\n/**\n * @hidden\n */\nexport class ArgumentsMatcher  {\n    constructor(private constantMatcher: ConstantMatcher) {\n\n    }\n\n    public matched(left: any[], right: (any | It<any>)[]): boolean {\n        if (left === right) return true;\n        if (left.length !== right.length) return false;\n\n        for (let i = 0; i < left.length; i++) {\n            const lvalue = left[i];\n            const rvalue = right[i];\n            if (this.constantMatcher.matched(lvalue, rvalue) === false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { ExpectedSetPropertyExpression } from \"../expected-expressions/expected-expressions\";\nimport { SetPropertyInteraction } from \"../interactions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\nimport { ConstantMatcher } from \"./constant.matcher\";\n\n/**\n * @hidden\n */\nexport class SetPropertyExpressionMatcher {\n\n    constructor(private constantMatcher: ConstantMatcher) {\n\n    }\n\n    public matched(left: SetPropertyInteraction, right: ExpectedSetPropertyExpression | It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n\n        const rightExpression = right as ExpectedSetPropertyExpression;\n        if (left.name === rightExpression.name && this.constantMatcher.matched(left.value, rightExpression.value)) return true;\n\n        return false;\n    }\n}\n","import { ArgumentsMatcher } from \"./arguments.matcher\";\nimport { NamedMethodInteraction } from \"../interactions\";\nimport { ExpectedNamedMethodExpression } from \"../expected-expressions/expected-expressions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\n\n/**\n * @hidden\n */\nexport class NamedMethodExpressionMatcher {\n\n    constructor(private argumentsMatcher: ArgumentsMatcher) {\n\n    }\n\n    public matched(left: NamedMethodInteraction, right: ExpectedNamedMethodExpression | It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n\n        const rightExpression = right as ExpectedNamedMethodExpression;\n        if (left.name === rightExpression.name) {\n            return this.argumentsMatcher.matched(left.args, rightExpression.args);\n        }\n\n        return false;\n    }\n}\n","import { ArgumentsMatcher } from \"./arguments.matcher\";\nimport { MethodInteraction } from \"../interactions\";\nimport { ExpectedMethodExpression } from \"../expected-expressions/expected-expressions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\n\n/**\n * @hidden\n */\nexport class MethodExpressionMatcher {\n\n    constructor(private argumentsMatcher: ArgumentsMatcher) {\n\n    }\n\n    public matched(left: MethodInteraction, right: ExpectedMethodExpression|It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n\n        const rightExpression = right as ExpectedMethodExpression;\n        return this.argumentsMatcher.matched(left.args, rightExpression.args);\n\n    }\n}\n","import { InOperatorInteraction } from \"../interactions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\nimport { ExpectedInOperatorExpression } from \"../expected-expressions/expected-expressions\";\n\n/**\n * @hidden\n */\nexport class InOperatorMatcher {\n\n    public matched(left: InOperatorInteraction, right: ExpectedInOperatorExpression | It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n\n        const rightExpression = right as ExpectedInOperatorExpression;\n        if (left.name === rightExpression.name) return true;\n\n        return false;\n    }\n}\n","import {GetPropertyInteraction} from \"../interactions\";\nimport {It} from \"../expected-expressions/expression-predicates\";\nimport {ExpectedGetPropertyExpression} from \"../expected-expressions/expected-expressions\";\n\n/**\n * @hidden\n */\nexport class GetPropertyExpressionMatcher {\n\n    public matched(left: GetPropertyInteraction, right: ExpectedGetPropertyExpression|It<any>): boolean {\n        if (right instanceof It) {\n            return (right as It<any>).test(left);\n        }\n\n        const rightExpression = right as ExpectedGetPropertyExpression;\n        if (left.name === rightExpression.name) return true;\n\n        return false;\n    }\n}\n","import { GetPropertyExpressionMatcher } from \"./get-property.matcher\";\nimport { SetPropertyExpressionMatcher } from \"./set-property.matcher\";\nimport { MethodExpressionMatcher } from \"./method.matcher\";\nimport { NamedMethodExpressionMatcher } from \"./instance-method.matcher\";\nimport {\n    GetPropertyInteraction,\n    InOperatorInteraction,\n    Interaction,\n    MethodInteraction,\n    NamedMethodInteraction,\n    SetPropertyInteraction\n} from \"../interactions\";\nimport {\n    ExpectedExpressions,\n    ExpectedGetPropertyExpression,\n    ExpectedInOperatorExpression,\n    ExpectedMethodExpression,\n    ExpectedNamedMethodExpression,\n    ExpectedSetPropertyExpression\n} from \"../expected-expressions/expected-expressions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\nimport { InOperatorMatcher } from \"./in-operator.matcher\";\n\n/**\n * @hidden\n */\nexport class ExpressionMatcher {\n\n    constructor(private getPropertyExpressionMatcher: GetPropertyExpressionMatcher,\n                private setPropertyExpressionMatcher: SetPropertyExpressionMatcher,\n                private methodExpressionMatcher: MethodExpressionMatcher,\n                private namedMethodExpressionMatcher: NamedMethodExpressionMatcher,\n                private inOperatorExpressionMatcher: InOperatorMatcher) {\n\n    }\n\n    public matched(left: Interaction, right: ExpectedExpressions<any>): boolean {\n\n        if (left === right) return true;\n        if (right === undefined) return true;\n\n        if (left instanceof GetPropertyInteraction && (right instanceof ExpectedGetPropertyExpression || right instanceof It)) {\n            return this.getPropertyExpressionMatcher.matched(left, right);\n        }\n        if (left instanceof SetPropertyInteraction && (right instanceof ExpectedSetPropertyExpression || right instanceof It)) {\n            return this.setPropertyExpressionMatcher.matched(left, right);\n        }\n        if (left instanceof InOperatorInteraction && (right instanceof ExpectedInOperatorExpression || right instanceof It)) {\n            return this.inOperatorExpressionMatcher.matched(left, right);\n        }\n        if (left instanceof MethodInteraction && (right instanceof ExpectedMethodExpression || right instanceof It)) {\n            return this.methodExpressionMatcher.matched(left, right);\n        }\n        if (left instanceof NamedMethodInteraction && (right instanceof ExpectedNamedMethodExpression || right instanceof It)) {\n            return this.namedMethodExpressionMatcher.matched(left, right);\n        }\n\n        return false;\n    }\n}\n","import { SetPropertyExpressionMatcher } from \"./set-property.matcher\";\nimport { ConstantMatcher } from \"./constant.matcher\";\nimport { NamedMethodExpressionMatcher } from \"./instance-method.matcher\";\nimport { ArgumentsMatcher } from \"./arguments.matcher\";\nimport { MethodExpressionMatcher } from \"./method.matcher\";\nimport { InOperatorMatcher } from \"./in-operator.matcher\";\nimport { GetPropertyExpressionMatcher } from \"./get-property.matcher\";\nimport { ExpressionMatcher } from \"./expression.matcher\";\n\n/**\n * @hidden\n */\nexport const expressionMatchersProviders = [\n    {\n        provide: ExpressionMatcher,\n        useClass: ExpressionMatcher,\n        deps: [\n            GetPropertyExpressionMatcher,\n            SetPropertyExpressionMatcher,\n            MethodExpressionMatcher,\n            NamedMethodExpressionMatcher,\n            InOperatorMatcher\n        ]\n    },\n    {provide: SetPropertyExpressionMatcher, useClass: SetPropertyExpressionMatcher, deps: [ConstantMatcher]},\n    {provide: NamedMethodExpressionMatcher, useClass: NamedMethodExpressionMatcher, deps: [ArgumentsMatcher]},\n    {provide: MethodExpressionMatcher, useClass: MethodExpressionMatcher, deps: [ArgumentsMatcher]},\n    {provide: InOperatorMatcher, useClass: InOperatorMatcher, deps: []},\n    {provide: GetPropertyExpressionMatcher, useClass: GetPropertyExpressionMatcher, deps: []},\n    {provide: ConstantMatcher, useClass: ConstantMatcher, deps: []},\n    {provide: ArgumentsMatcher, useClass: ArgumentsMatcher, deps: [ConstantMatcher]},\n];\n","import { It } from \"../expected-expressions/expression-predicates\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ConstantFormatter {\r\n\r\n    public format(object: any | It<any>): string {\r\n        if (object instanceof It) return `It.Is(${(object as It<any>).predicate})`;\r\n        if (object instanceof String || typeof object === \"string\") return `\\'${object}\\'`;\r\n        if (object instanceof Array) {\r\n            const description = [];\r\n            for (const index of Object.keys(object)) {\r\n                description.push(new ConstantFormatter().format(object[index]));\r\n            }\r\n\r\n            return `[${description}]`;\r\n        }\r\n        return `${object}`;\r\n    }\r\n}\r\n\r\n","import { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\r\nimport { ExpressionFormatter } from \"./expression-formatter\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ExpectedExpressionFormatter {\r\n\r\n    constructor(private expressionFormatter: ExpressionFormatter) {\r\n\r\n    }\r\n\r\n    public format(expected: ExpectedExpressions<any>, timesMessage: string, haveBeenCalledTimes: number, mockName?: string): string {\r\n        const expressionDescription = this.expressionFormatter.format(expected);\r\n        const mockDescription = mockName !== undefined ? ` of ${mockName}` : \"\";\r\n        return `${expressionDescription}${mockDescription} ${timesMessage.toLowerCase()}, but was called ${haveBeenCalledTimes} time(s)`;\r\n    }\r\n}\r\n","import {\n    GetPropertyInteraction,\n    InOperatorInteraction,\n    Interaction,\n    MethodInteraction,\n    NamedMethodInteraction,\n    SetPropertyInteraction\n} from \"../interactions\";\nimport { It } from \"../expected-expressions/expression-predicates\";\nimport { GetPropertyExpressionFormatter } from \"./get.property-formatter\";\nimport { SetPropertyExpressionFormatter } from \"./set.property-formatter\";\nimport { MethodExpressionFormatter } from \"./method-formatter\";\nimport { NamedMethodExpressionFormatter } from \"./named.method-formatter\";\nimport { ConstantFormatter } from \"./constant-formatter\";\nimport { InOperatorFormatter } from \"./in-operator.formatter\";\n\n/**\n * @hidden\n */\nexport class ExpressionFormatter {\n\n    constructor(private getPropertyFormatter: GetPropertyExpressionFormatter,\n                private setPropertyFormatter: SetPropertyExpressionFormatter,\n                private methodFormatter: MethodExpressionFormatter,\n                private namedMethodFormatter: NamedMethodExpressionFormatter,\n                private constantFormatter: ConstantFormatter,\n                private inOperatorFormatter: InOperatorFormatter) {\n\n    }\n\n    public format(expression: Interaction | It<any>): string {\n        if (expression instanceof GetPropertyInteraction) return this.getPropertyFormatter.format(expression);\n        if (expression instanceof SetPropertyInteraction) return this.setPropertyFormatter.format(expression);\n        if (expression instanceof InOperatorInteraction) return this.inOperatorFormatter.format(expression);\n        if (expression instanceof MethodInteraction) return this.methodFormatter.format(expression);\n        if (expression instanceof NamedMethodInteraction) return this.namedMethodFormatter.format(expression);\n        if (expression instanceof It) return this.constantFormatter.format(expression);\n\n        return undefined;\n    }\n}\n","import { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\r\nimport { Interaction } from \"../interactions\";\r\nimport { ExpectedExpressionFormatter } from \"./expected-expression-formatter\";\r\nimport { TrackedExpressionsFormatter } from \"./tracked-expressions-formatter\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class VerifyFormatter {\r\n\r\n    constructor(\r\n        private expectedExpressionFormatter: ExpectedExpressionFormatter,\r\n        private trackedExpressionsFormatter: TrackedExpressionsFormatter) {\r\n    }\r\n\r\n    public format(\r\n        expected: ExpectedExpressions<any>,\r\n        timesMessage: string,\r\n        haveBeenCalledTimes: number,\r\n        trackedExpressions: Interaction[],\r\n        mockName?: string): string {\r\n        const expectedExpressionMessage = this.expectedExpressionFormatter.format(expected, timesMessage, haveBeenCalledTimes, mockName);\r\n        const trackedExpressionsMessage = this.trackedExpressionsFormatter.format(trackedExpressions);\r\n        const delimiter = \"-------------------------------------\";\r\n        return `${expectedExpressionMessage}\\n${delimiter}\\nTracked calls:\\n${trackedExpressionsMessage}\\n${delimiter}\\n`;\r\n    }\r\n}\r\n","import { ExpressionFormatter } from \"./expression-formatter\";\r\nimport { Interaction } from \"../interactions\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TrackedExpressionsFormatter {\r\n\r\n    constructor(private expressionFormatter: ExpressionFormatter) {\r\n\r\n    }\r\n\r\n    public format(trackedExpressions: Interaction[]): string {\r\n        let result = \"\";\r\n        for (const expression of trackedExpressions) {\r\n            result += `${this.expressionFormatter.format(expression)}\\n`;\r\n        }\r\n\r\n        return result.substr(0, result.length - 1);\r\n    }\r\n}\r\n","import { SetPropertyInteraction } from \"../interactions\";\nimport { ConstantFormatter } from \"./constant-formatter\";\nimport { PropertyKeyFormatter } from \"./property-key.formatter\";\n\n/**\n * @hidden\n */\nexport class SetPropertyExpressionFormatter {\n\n    constructor(private constantFormatter: ConstantFormatter,\n                private propertyKeyFormatter: PropertyKeyFormatter) {\n\n    }\n\n    public format(expression: SetPropertyInteraction): string {\n        const value = this.constantFormatter.format(expression.value);\n        const propertyKey = this.propertyKeyFormatter.format(expression.name);\n        return `Assignment of ${value} to property \\'${propertyKey}\\'`;\n    }\n}\n","/**\n * @hidden\n */\nexport class PropertyKeyFormatter {\n    public format(property: PropertyKey): string {\n        return String(property);\n    }\n}\n","import { NamedMethodInteraction } from \"../interactions\";\r\nimport { ConstantFormatter } from \"./constant-formatter\";\r\nimport { PropertyKeyFormatter } from \"./property-key.formatter\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class NamedMethodExpressionFormatter {\r\n\r\n    constructor(private constantFormatter: ConstantFormatter,\r\n                private propertyKeyFormatter: PropertyKeyFormatter) {\r\n\r\n    }\r\n\r\n    public format(expression: NamedMethodInteraction): string {\r\n        const formatted: string[] = [];\r\n\r\n        expression.args.forEach(arg => {\r\n            formatted.push(this.constantFormatter.format(arg));\r\n        });\r\n\r\n        const value = formatted.join(\", \");\r\n        const propertyKey = this.propertyKeyFormatter.format(expression.name);\r\n        return `${propertyKey}(${value})`;\r\n    }\r\n}\r\n","import { MethodInteraction } from \"../interactions\";\r\nimport { ConstantFormatter } from \"./constant-formatter\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class MethodExpressionFormatter {\r\n\r\n    constructor(private constantFormatter: ConstantFormatter) {\r\n\r\n    }\r\n\r\n    public format(expression: MethodInteraction): string {\r\n        const value = this.constantFormatter.format(expression.args);\r\n        return `(${value})`;\r\n    }\r\n}\r\n","import { InOperatorInteraction } from \"../interactions\";\nimport { PropertyKeyFormatter } from \"./property-key.formatter\";\n\n/**\n * @hidden\n */\nexport class InOperatorFormatter {\n    constructor(private propertyKeyFormatter: PropertyKeyFormatter) {\n\n    }\n\n    public format(expression: InOperatorInteraction): string {\n        const propertyKey = this.propertyKeyFormatter.format(expression.name);\n        return `In operator for \\'${propertyKey}\\'`;\n    }\n}\n","import { GetPropertyInteraction } from \"../interactions\";\nimport { PropertyKeyFormatter } from \"./property-key.formatter\";\n\n/**\n * @hidden\n */\nexport class GetPropertyExpressionFormatter {\n    constructor(private propertyKeyFormatter: PropertyKeyFormatter) {\n\n    }\n\n    public format(expression: GetPropertyInteraction): string {\n        const propertyKey = this.propertyKeyFormatter.format(expression.name);\n        return `Getter of \\'${propertyKey}\\'`;\n    }\n}\n","import { VerifyFormatter } from \"./verify-formatter\";\nimport { ExpectedExpressionFormatter } from \"./expected-expression-formatter\";\nimport { TrackedExpressionsFormatter } from \"./tracked-expressions-formatter\";\nimport { ExpressionFormatter } from \"./expression-formatter\";\nimport { SetPropertyExpressionFormatter } from \"./set.property-formatter\";\nimport { ConstantFormatter } from \"./constant-formatter\";\nimport { PropertyKeyFormatter } from \"./property-key.formatter\";\nimport { NamedMethodExpressionFormatter } from \"./named.method-formatter\";\nimport { MethodExpressionFormatter } from \"./method-formatter\";\nimport { InOperatorFormatter } from \"./in-operator.formatter\";\nimport { GetPropertyExpressionFormatter } from \"./get.property-formatter\";\n\n/**\n * @hidden\n */\nexport const formattersProviders = [\n    {\n        provide: VerifyFormatter,\n        useClass: VerifyFormatter,\n        deps: [ExpectedExpressionFormatter, TrackedExpressionsFormatter]\n    },\n    {provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [ExpressionFormatter]},\n    {\n        provide: SetPropertyExpressionFormatter,\n        useClass: SetPropertyExpressionFormatter,\n        deps: [ConstantFormatter, PropertyKeyFormatter]\n    },\n    {provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: []},\n    {\n        provide: NamedMethodExpressionFormatter,\n        useClass: NamedMethodExpressionFormatter,\n        deps: [ConstantFormatter, PropertyKeyFormatter]\n    },\n    {provide: MethodExpressionFormatter, useClass: MethodExpressionFormatter, deps: [ConstantFormatter]},\n    {provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter]},\n    {provide: GetPropertyExpressionFormatter, useClass: GetPropertyExpressionFormatter, deps: [PropertyKeyFormatter]},\n    {\n        provide: ExpressionFormatter,\n        useClass: ExpressionFormatter,\n        deps: [\n            GetPropertyExpressionFormatter,\n            SetPropertyExpressionFormatter,\n            MethodExpressionFormatter,\n            NamedMethodExpressionFormatter,\n            ConstantFormatter,\n            InOperatorFormatter\n        ]\n    },\n    {provide: ExpectedExpressionFormatter, useClass: ExpectedExpressionFormatter, deps: [ExpressionFormatter]},\n    {provide: ConstantFormatter, useClass: ConstantFormatter, deps: []},\n];\n","import { Interaction } from \"../interactions\";\n\n/**\n * @hidden\n */\nexport class CallbackPresetPlayer {\n    public play<TValue>(callback: (interaction: Interaction) => TValue, interaction: Interaction): any {\n        return callback.apply(undefined, [interaction]);\n    }\n}\n","import { IPreset } from \"./preset\";\nimport { ExpectedExpressions } from \"../../expected-expressions/expected-expressions\";\nimport { IPlayable } from \"../../moq\";\n\nexport class ReturnsPreset<T, TValue> implements IPreset<T> {\n    constructor(\n        public readonly playable: IPlayable,\n        public readonly target: ExpectedExpressions<T>,\n        public readonly value: TValue) {\n\n    }\n}\n\n","import { IPreset } from \"./preset\";\nimport { ExpectedExpressions } from \"../../expected-expressions/expected-expressions\";\nimport { Interaction } from \"../../interactions\";\nimport { IPlayable } from \"../../moq\";\n\nexport class CallbacksPreset<T> implements IPreset<T> {\n    constructor(\n        public readonly playable: IPlayable,\n        public readonly target: ExpectedExpressions<T>,\n        public readonly callback: (interaction: Interaction) => unknown) {\n\n    }\n}\n","import { IPreset } from \"./preset\";\nimport { ExpectedExpressions } from \"../../expected-expressions/expected-expressions\";\nimport { IPlayable } from \"../../moq\";\n\nexport class ThrowsPreset<T, TException> implements IPreset<T> {\n    constructor(\n        public readonly playable: IPlayable,\n        public readonly target: ExpectedExpressions<T>,\n        public readonly exception: TException) {\n\n    }\n}\n","import { IPreset } from \"../presets/presets/preset\";\nimport { Interaction } from \"../interactions\";\nimport { ReturnsPreset } from \"../presets/presets/returns.preset\";\nimport { CallbackPresetPlayer } from \"./callback-preset.player\";\nimport { CallbacksPreset } from \"../presets/presets/callbacks.preset\";\nimport { ThrowsPreset } from \"../presets/presets/throws.preset\";\nimport { MimicsPresetPlayer } from \"./mimics-preset.player\";\nimport { MimicsPreset } from \"../presets/presets/mimics.preset\";\n\n/**\n * @hidden\n */\nexport class PresetPlayer {\n    constructor(\n        private callbackPresetPlayer: CallbackPresetPlayer,\n        private mimicsPresetPlayer: MimicsPresetPlayer) {\n\n    }\n\n    public play<T>(preset: IPreset<T>, interaction: Interaction): any {\n        if (preset instanceof ReturnsPreset) {\n            return preset.value;\n        }\n        if (preset instanceof CallbacksPreset) {\n            return this.callbackPresetPlayer.play(preset.callback, interaction);\n        }\n        if (preset instanceof MimicsPreset) {\n            return this.mimicsPresetPlayer.play(preset.origin, interaction);\n        }\n        if (preset instanceof ThrowsPreset) {\n            throw preset.exception;\n        }\n    }\n}\n","import {\n    GetPropertyInteraction,\n    InOperatorInteraction,\n    Interaction,\n    MethodInteraction,\n    NamedMethodInteraction,\n    SetPropertyInteraction\n} from \"../interactions\";\nimport { REFLECT_APPLY } from \"./reflect-apply.injection-token\";\nimport { TypeofInjectionToken } from \"../typeof-injection-token\";\n\n/**\n * @hidden\n */\nexport class MimicsPresetPlayer {\n    constructor(\n        private apply: TypeofInjectionToken<typeof REFLECT_APPLY>) {\n\n    }\n\n    public play(origin: any, interaction: Interaction): any {\n        if (interaction instanceof GetPropertyInteraction) {\n            return origin[interaction.name];\n        }\n        if (interaction instanceof SetPropertyInteraction) {\n            origin[interaction.name] = interaction.value;\n            return true;\n        }\n        if (interaction instanceof NamedMethodInteraction) {\n            const method = origin[interaction.name];\n            return this.apply(method, origin, interaction.args);\n        }\n        if (interaction instanceof MethodInteraction) {\n            return this.apply(origin, undefined, interaction.args);\n        }\n        if (interaction instanceof InOperatorInteraction) {\n            return interaction.name in origin;\n        }\n\n    }\n}\n","import { IPreset } from \"../presets/presets/preset\";\nimport { Interaction } from \"../interactions\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\nimport { Presets } from \"../presets/presets\";\n\n/**\n * @hidden\n */\nexport class PlayablePresetProvider {\n\n    constructor(\n        private presets: Presets<unknown>,\n        private matcher: ExpressionMatcher) {\n\n    }\n\n    public get(interaction: Interaction): IPreset<unknown> | undefined {\n        for (const preset of this.presets.get()) {\n            const {target, playable: {isPlayable}} = preset;\n            if (this.matcher.matched(interaction, target) && isPlayable() === true) {\n                return preset;\n            }\n        }\n    }\n}\n","import { Interaction } from \"../interactions\";\nimport { PlayablePresetProvider } from \"./playable-preset.provider\";\nimport { PresetPlayer } from \"./preset.player\";\nimport { PresetPlayablesUpdater } from \"../playables/preset-playables.updater\";\n\n/**\n * @hidden\n */\nexport class InteractionPlayer {\n    constructor(\n        private playablePresetProvider: PlayablePresetProvider,\n        private presetPlayablesUpdater: PresetPlayablesUpdater,\n        private presetPlayer: PresetPlayer) {\n\n    }\n\n    public play(interaction: Interaction): any {\n        const preset = this.playablePresetProvider.get(interaction);\n        this.presetPlayablesUpdater.update(interaction, preset);\n        if (preset === undefined) return undefined;\n        return this.presetPlayer.play(preset, interaction);\n    }\n}\n","import { IPreset } from \"../presets/presets/preset\";\nimport { Interaction } from \"../interactions\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\nimport { Presets } from \"../presets/presets\";\nimport { PlayableUpdateReason } from \"../moq\";\n\n/**\n * @hidden\n */\nexport class PresetPlayablesUpdater {\n\n    constructor(\n        private presets: Presets<unknown>,\n        private matcher: ExpressionMatcher) {\n\n    }\n\n    public update(interaction: Interaction, playable: IPreset<unknown>) {\n        for (const preset of this.presets.get()) {\n            const {target, playable: {update}} = preset;\n            if (this.matcher.matched(interaction, target)) {\n                const reason = preset === playable ?\n                    PlayableUpdateReason.OwnSetupWouldBePlayed :\n                    PlayableUpdateReason.OtherSetupWouldBePlayed;\n                update(reason);\n            }\n        }\n    }\n}\n","import { InjectionToken } from \"../static.injector/injection_token\";\n\n/**\n * @hidden\n */\nexport const REFLECT_APPLY = new InjectionToken<typeof Reflect.apply>(\"Reflect Apply\");\n","import { PresetPlayer } from \"./preset.player\";\nimport { CallbackPresetPlayer } from \"./callback-preset.player\";\nimport { MimicsPresetPlayer } from \"./mimics-preset.player\";\nimport { PlayablePresetProvider } from \"./playable-preset.provider\";\nimport { Presets } from \"../presets/presets\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\nimport { InteractionPlayer } from \"./interaction.player\";\nimport { PresetPlayablesUpdater } from \"../playables/preset-playables.updater\";\nimport { REFLECT_APPLY } from \"./reflect-apply.injection-token\";\n\n/**\n * @hidden\n */\nexport const interactionPlayersProviders = [\n    {provide: REFLECT_APPLY, useValue: Reflect.apply, deps: []},\n    {provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer]},\n    {provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionMatcher]},\n    {provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY]},\n    {\n        provide: InteractionPlayer,\n        useClass: InteractionPlayer,\n        deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]\n    },\n    {provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: []},\n];\n","import { Tracker } from \"../tracker/tracker\";\nimport { MethodInteraction } from \"../interactions\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\n\n/**\n * @hidden\n */\nexport class ApplyTrap {\n    constructor(\n        private tracker: Tracker,\n        private interactionPlayer: InteractionPlayer) {\n\n    }\n\n    public intercept(target: any, thisArg: any, argArray?: any): any {\n        const expression = new MethodInteraction(argArray);\n\n        this.tracker.add(expression);\n\n        return this.interactionPlayer.play(expression);\n    }\n}\n","import { PrototypeStorage } from \"./prototype.storage\";\n\n/**\n * @hidden\n */\nexport class GetPrototypeOfTrap {\n    constructor(\n        private prototypeStorage: PrototypeStorage) {\n\n    }\n\n    public intercept(): any {\n        return this.prototypeStorage.get();\n    }\n}\n","import { IExpectedExpression } from \"./expected-expressions/expected-expression-reflector\";\r\nimport { Times } from \"./times\";\r\nimport { Interaction } from \"./interactions\";\r\nimport { Tracker } from \"./tracker/tracker\";\r\nimport { StaticProvider } from \"./static.injector/interface/provider\";\r\n\r\nexport const enum PlayableUpdateReason {\r\n    /**\r\n     * The playable is update because it's setup is about to be played\r\n     */\r\n    OwnSetupWouldBePlayed,\r\n    /**\r\n     * The playable is update because another setup is about to be played\r\n     */\r\n    OtherSetupWouldBePlayed\r\n}\r\n\r\n/**\r\n * Provides playable logic for a setup\r\n */\r\nexport interface IPlayable {\r\n    /**\r\n     * Tests if setup is playable\r\n     */\r\n    isPlayable(): boolean;\r\n\r\n    /**\r\n     * Invokes as the setup is about to be played, so the playable logic can change it's state.\r\n     *\r\n     * @param reason The reason why this update is called {@link PlayableUpdateReason}\r\n     * @example\r\n     * ```typescript\r\n     *\r\n     *     const playable1 = new PlayableOnce();\r\n     *     const playable2 = new PlayableOnce();\r\n     *\r\n     *     const mock = new Mock<(val: number) => void)>()\r\n     *     // setup A\r\n     *     .setup(instance => instance(1))\r\n     *     .play(playable1)\r\n     *     .returns(1)\r\n     *     // setup B\r\n     *     .setup(instance => instance(2))\r\n     *     .play(playable2)\r\n     *     .returns(2);\r\n     *\r\n     *     const actual = mock.object()(1);\r\n     *     // at this point the update of playable1 should be called with OwnSetupWouldBePlayed\r\n     *     // because setup A would be played\r\n     *     // and the update of playable2 should be called with OtherSetupWouldBePlayed\r\n     * ```\r\n     */\r\n    update(reason: PlayableUpdateReason): void;\r\n}\r\n\r\n/**\r\n * Sets a behaviour rule for a particular use case\r\n *\r\n * @param T The type of mocked object.\r\n */\r\nexport interface IPresetBuilder<T, TValue = any> {\r\n    /**\r\n     * Returns the provided value as a result of interaction in case of\r\n     * - get property value\r\n     * - invocation a function\r\n     *\r\n     * Controls write operation in case of\r\n     * - property assignment (true - the assignment is allowed, false - the assignment is not allowed)\r\n     *\r\n     * @param value The value\r\n     */\r\n    returns(value: TValue): IMock<T>;\r\n\r\n    /**\r\n     * Throws the provided exception.\r\n     */\r\n    throws<TException>(exception: TException): IMock<T>;\r\n\r\n    /**\r\n     * @param callback A callback function that will intercept the interaction.\r\n     * The function may returns a value that will be provided as result (see {@link IPresetBuilder.returns})\r\n     * @example\r\n     * ```typescript\r\n     *\r\n     *     const ipcRendererMock = new StrictMock<typeof ipcRenderer>()\r\n     *     .setup(instance => instance.on(ipcRendererChannelName, It.IsAny()))\r\n     *     .callback(({args: [channel, listener]}) => listener(undefined, response));\r\n     * ```\r\n     */\r\n    callback(callback: (interaction: Interaction) => TValue): IMock<T>;\r\n\r\n    /**\r\n     * Plays the setup on target invocation when predicate returns true otherwise the setup will be ignored.\r\n     * As predicate {@link PlayTimes} could be used.\r\n     */\r\n    play(predicate: IPlayable): IPresetBuilder<T, TValue>;\r\n\r\n    /**\r\n     * Replicates interactions with original object.\r\n     * The mock object keeps tracking all interactions and reflects them on the original object.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     *\r\n     * const value = 2;\r\n     *\r\n     * class Origin {\r\n     *   public property = value;\r\n     *}\r\n     *\r\n     * const origin = new Origin();\r\n     * const mock = new Mock<Origin>()\r\n     * .setup(() => It.IsAny())\r\n     * .mimics(origin);\r\n     *\r\n     * const actual = mock.object().property;\r\n     * expect(actual).toBe(2);\r\n     * ```\r\n     */\r\n    mimics(origin: T): IMock<T>;\r\n}\r\n\r\n/**\r\n * The main API of the framework.\r\n *\r\n * @example\r\n * ```typescript\r\n *\r\n *  const value = 'value';\r\n *  const object = new Mock<Function>()\r\n *  .setup(instance => instance(1))\r\n *  .returns(value)\r\n *  .object();\r\n *\r\n *  const actual = object(1);\r\n *\r\n *  expect(actual).toBe(value);\r\n * ```\r\n * ---\r\n * #### Latest setups have more precedence over earlier setups.\r\n * @example\r\n * ```typescript\r\n *\r\n *  const object = new Mock<Function>()\r\n *  .setup(instance => instance(1))\r\n *  .returns(1)\r\n *  .setup(instance => instance(1))\r\n *  .returns(2)\r\n *  .object();\r\n *\r\n *  const actual = object(1);\r\n *\r\n *  expect(actual).toBe(2);\r\n * ```\r\n *\r\n * @param T The type of mocked object. Could be any type including:\r\n * - Function,\r\n * - arrow function,\r\n * - interface,\r\n * - class,\r\n * - object and etc.\r\n */\r\nexport interface IMock<T> {\r\n    /**\r\n     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct\r\n     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].\r\n     */\r\n    readonly name?: string;\r\n\r\n    /**\r\n     * Returns the tracker object that responsible for storing history of interactions with the mocked object.\r\n     */\r\n    readonly tracker: Tracker;\r\n\r\n    /**\r\n     * Returns options object\r\n     */\r\n    readonly options: IMockOptions<T>;\r\n\r\n    /**\r\n     * Returns instance of mocked object\r\n     */\r\n    object(): T;\r\n\r\n    /**\r\n     * Defines a configuration for particular interaction with the mocked object.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     *\r\n     * // a function invoke with 1 as parameter\r\n     * .setup(instance => instance(1))\r\n     *\r\n     * // apply function invoke on a function with null as the first parameter and a placeholder for the second parameter\r\n     * .setup(instance => instance.apply(null, It.IsAny()))\r\n     *\r\n     * // accessing to a property\r\n     * .setup(instance => instance.property)\r\n     *\r\n     * //accessing to a named function with name 'test' of an object and the first parameter is 1\r\n     * .setup(instance => It.Is((expression: ExpectedNamedMethodExpression) => {\r\n     *      return expression.name === 'test' && expression.args[0] === 1\r\n     * }))\r\n     *\r\n     * //setting propertyA to value of 'a'\r\n     * .setup(instance => {instance.propertyA = 'a'})\r\n     * ```\r\n     * @param expression A function that accepts a\r\n     * [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\r\n     * and either plays expected interaction or returns a predicate function.\r\n     * Refer {@link It} class for parameter placeholders or predicate functions.\r\n     * Refer the integration tests for more examples.\r\n     * @returns PresetBuilder config interface for the provided expression.\r\n     */\r\n    setup<E extends IExpectedExpression<T>,\r\n        R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;\r\n\r\n    /**\r\n     * Asserts expected interactions with the mocked object.\r\n     *\r\n     * @param expression Expected expression\r\n     * @param times The default value is {@link Times.Once}\r\n     */\r\n    verify(expression: IExpectedExpression<T>, times?: Times): IMock<T>;\r\n\r\n    /**\r\n     * Set the prototype of the mocked object.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     *\r\n     *  class PrototypeClass {}\r\n     *\r\n     *  const mock = new Mock<{}>();\r\n     *  const object = mock.object();\r\n     *\r\n     *  Object.setPrototypeOf(object, PrototypeClass.prototype);\r\n     *\r\n     *  expect(object instanceof PrototypeClass).toBe(true);\r\n     * ```\r\n     */\r\n    prototypeof(prototype?: any): IMock<T>;\r\n\r\n    /**\r\n     * @experimental\r\n     * @hidden\r\n     */\r\n    insequence(sequence: ISequenceVerifier, expression: IExpectedExpression<T>): IMock<T>;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * @experimental\r\n */\r\nexport interface ISequenceVerifier {\r\n    add<T>(mock: IMock<T>, expression: IExpectedExpression<T>): ISequenceVerifier;\r\n\r\n    verify(times?: Times): void;\r\n}\r\n\r\n/**\r\n * A mock object exposes a symbol property to access to its Moq API.\r\n * This property is read only and trackable.\r\n * Since this property makes sense only in context of the moq library\r\n * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.\r\n *\r\n * @example\r\n * ```typescript\r\n *\r\n *  const mock = new Mock<() => void>()\r\n *  .object();\r\n *\r\n *  mock[MoqAPI]\r\n *  .setup(instance => instance())\r\n *  .returns(12);\r\n *\r\n *  const actual = mock();\r\n *\r\n *  expect(actual).toBe(12);\r\n * ```\r\n */\r\nexport const MoqAPI = Symbol(\"MoqAPI\");\r\n\r\n\r\n/**\r\n * The Mock internally depends on angular based injector to construct its dependencies.\r\n */\r\nexport interface IInjectorConfig {\r\n    /**\r\n     * Returns array of StaticProviders to construct an angular based injector.\r\n     *\r\n     * @param options The final version of mock options. Options that passed to Mock constructor are merged with\r\n     * the global mock options ({@link Mock.options}). Some components depend on the options and the injector\r\n     * should be able to resolve it. To configure the injector property the implementation could do the following:\r\n     * ``` typescript\r\n     * return [\r\n     *  {provide: MOCK_OPTIONS, useValue: options, deps: []},\r\n     * ];\r\n     * ```\r\n     * @param providers An array of additional providers that could be added to the final configuration.\r\n     */\r\n    get(options: IMockOptions<unknown>, ...providers: StaticProvider[]): StaticProvider[];\r\n}\r\n\r\n/**\r\n * Mock instance options.\r\n * Could be passed as parameter on mock instantiating or could be set globally on {@link Mock.options}.\r\n */\r\nexport interface IMockOptions<T> {\r\n    /**\r\n     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct\r\n     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].\r\n     */\r\n    name?: string;\r\n    /**\r\n     * The target object for Proxy that is used under the hood.\r\n     * typeof operation is applied to this target.\r\n     * The default value is a function.\r\n     */\r\n    target?: T;\r\n    /**\r\n     * The Mock internally based on angular injector to construct its dependencies.\r\n     * An instance of {@link IInjectorConfig} implementation could be passed as parameter in order to\r\n     * changed the mock behaviour. The default value is an instance of {@link DefaultInjectorConfig}.\r\n     * There is also {@link EqualMatchingInjectorConfig} that would setup Mock to use equal logic for comparing values.\r\n     */\r\n    injectorConfig?: IInjectorConfig;\r\n}\r\n","import { GetPropertyInteraction } from \"../interactions\";\nimport { PropertiesValueStorage } from \"./properties-value.storage\";\nimport { SpyFunctionProvider } from \"./spy-function.provider\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\nimport { HasPropertyExplorer } from \"../explorers/has-property.explorer/has-property.explorer\";\nimport { HasMethodExplorer } from \"../explorers/has-method.explorer/has-method.explorer\";\nimport { MoqAPI } from \"../moq\";\nimport { Tracker } from \"../tracker/tracker\";\nimport { TypeofInjectionToken } from \"../typeof-injection-token\";\nimport { MOCK } from \"../injector/moq.injection-token\";\n\n/**\n * @hidden\n */\nexport class GetTrap {\n    constructor(\n        private mock: TypeofInjectionToken<typeof MOCK>,\n        private tracker: Tracker,\n        private propertiesValueStorage: PropertiesValueStorage,\n        private interactionPlayer: InteractionPlayer,\n        private hasPropertyExplorer: HasPropertyExplorer,\n        private hasMethodExplorer: HasMethodExplorer,\n        private spyFunctionProvider: SpyFunctionProvider) {\n\n    }\n\n    public intercept(property: PropertyKey): any {\n        const interaction = new GetPropertyInteraction(property);\n\n        this.tracker.add(interaction);\n\n        if (property === MoqAPI) {\n            return this.mock;\n        }\n\n        if (this.propertiesValueStorage.has(property)) {\n            return this.propertiesValueStorage.get(property);\n        }\n\n        if (this.hasPropertyExplorer.has(property)) {\n            return this.interactionPlayer.play(interaction);\n        }\n\n        if (this.hasMethodExplorer.has(property)) {\n            return this.spyFunctionProvider.get(property);\n        }\n\n        return this.interactionPlayer.play(interaction);\n    }\n}\n","import { Tracker } from \"../tracker/tracker\";\nimport { InOperatorInteraction } from \"../interactions\";\nimport { PropertiesValueStorage } from \"./properties-value.storage\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\nimport { HasPropertyExplorer } from \"../explorers/has-property.explorer/has-property.explorer\";\nimport { HasMethodExplorer } from \"../explorers/has-method.explorer/has-method.explorer\";\nimport { InOperatorInteractionExplorer } from \"../explorers/in-operator-interaction.explorer/in-operator-interaction.explorer\";\nimport { PresetPlayablesUpdater } from \"../playables/preset-playables.updater\";\n\n/**\n * @hidden\n */\nexport class HasTrap {\n    constructor(\n        private tracker: Tracker,\n        private propertiesValueStorage: PropertiesValueStorage,\n        private interactionPlayer: InteractionPlayer,\n        private inOperatorInteractionExplorer: InOperatorInteractionExplorer,\n        private hasPropertyExplorer: HasPropertyExplorer,\n        private hasMethodExplorer: HasMethodExplorer,\n        private presetPlayablesUpdater: PresetPlayablesUpdater) {\n\n    }\n\n    public intercept(property: PropertyKey): any {\n        const interaction = new InOperatorInteraction(property);\n        this.tracker.add(interaction);\n\n        if (this.propertiesValueStorage.has(property)) {\n            return true;\n        }\n\n        if (this.inOperatorInteractionExplorer.has(property)) {\n            return this.interactionPlayer.play(interaction);\n        }\n\n        this.presetPlayablesUpdater.update(interaction, undefined);\n\n        if (this.hasPropertyExplorer.has(property)) {\n            return true;\n        }\n\n        if (this.hasMethodExplorer.has(property)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { GetPropertyInteraction, MethodInteraction, SetPropertyInteraction } from \"../interactions\";\nimport { SequenceId } from \"./sequence-id\";\n\n/**\n * This class represents a recorded interaction with the a mocked object.\n */\nexport interface TrackedAction {\n    id: number;\n    expression: MethodInteraction | GetPropertyInteraction | SetPropertyInteraction;\n}\n\n/**\n * This class records all interactions with a mocked object.\n */\nexport class Tracker {\n    private log: TrackedAction[] = [];\n\n    constructor(private sequenceId: SequenceId) {\n\n    }\n\n    /**\n     * @hidden\n     */\n    public add(action: MethodInteraction | GetPropertyInteraction | SetPropertyInteraction): void {\n        const record = {id: this.sequenceId.next(), expression: action};\n        this.log.push(record);\n    }\n\n    /**\n     * Returns recorded interactions.\n     */\n    public get(): TrackedAction[] {\n        return [...this.log];\n    }\n}\n","export class PropertiesValueStorage {\n    private storage = new Map<PropertyKey, any>();\n\n    public has(property: PropertyKey): boolean {\n        return this.storage.has(property);\n    }\n\n    public get(property: PropertyKey): any {\n        return this.storage.get(property);\n    }\n\n    public set(property: PropertyKey, value: any): void {\n        this.storage.set(property, value);\n    }\n}\n","import { Tracker } from \"../tracker/tracker\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\nimport { NamedMethodInteraction } from \"../interactions\";\n\n/**\n * @hidden\n */\nexport class SpyFunctionProvider {\n    private map = new Map<PropertyKey, (...args) => any>();\n\n    constructor(\n        private tracker: Tracker,\n        private interactionPlayer: InteractionPlayer) {\n\n    }\n\n    public get(property: PropertyKey): (...args) => any {\n        if (this.map.has(property) === false) {\n            this.map.set(property, (...args): any => {\n                const interaction = new NamedMethodInteraction(property, args);\n                this.tracker.add(interaction);\n                return this.interactionPlayer.play(interaction);\n            });\n        }\n        return this.map.get(property);\n    }\n}\n","import { Tracker } from \"../tracker/tracker\";\nimport { SetPropertyInteraction } from \"../interactions\";\nimport { PropertiesValueStorage } from \"./properties-value.storage\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\nimport { MoqAPI } from \"../moq\";\nimport { PropertyIsReadOnlyTester } from \"../explorers/has-property.explorer/property-is-read-only.tester\";\n\n/**\n * @hidden\n */\nexport class SetTrap {\n    constructor(\n        private tracker: Tracker,\n        private propertiesValueStorage: PropertiesValueStorage,\n        private interactionPlayer: InteractionPlayer,\n        private propertyIsReadOnlyTester: PropertyIsReadOnlyTester) {\n\n    }\n\n    public intercept(target: any, property: PropertyKey, value: any): boolean {\n        const expression = new SetPropertyInteraction(property, value);\n\n        this.tracker.add(expression);\n\n        if (property === MoqAPI) {\n            return false;\n        }\n\n        if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {\n            return false;\n        }\n\n        const accepted = this.interactionPlayer.play(expression);\n        if (accepted === true || accepted === undefined) {\n            this.propertiesValueStorage.set(property, value);\n        }\n\n        return accepted === undefined ? true : accepted;\n    }\n}\n","import { PrototypeStorage } from \"./prototype.storage\";\n\n/**\n * @hidden\n */\nexport class SetPrototypeOfTrap {\n    constructor(\n        private prototypeStorage: PrototypeStorage) {\n\n    }\n\n    public intercept(prototype: any): any {\n        if (prototype !== undefined) {\n            this.prototypeStorage.set(prototype);\n            return true;\n        }\n        return false;\n\n    }\n}\n","import { GetTrap } from \"./get.trap\";\nimport { SetTrap } from \"./set.trap\";\nimport { ApplyTrap } from \"./apply.trap\";\nimport { GetPrototypeOfTrap } from \"./get-prototype-of.trap\";\nimport { SetPrototypeOfTrap } from \"./set-prototype-of.trap\";\nimport { HasTrap } from \"./has.trap\";\nimport { MOCK_OPTIONS } from \"../mock-options/mock-options.injection-token\";\nimport { TypeofInjectionToken } from \"../typeof-injection-token\";\n\n/**\n * @hidden\n */\nexport class ProxyFactory<T> {\n    private _proxy: T;\n\n    constructor(private options: TypeofInjectionToken<typeof MOCK_OPTIONS>,\n                private getTrap: GetTrap,\n                private setTrap: SetTrap,\n                private hasTrap: HasTrap,\n                private applyTrap: ApplyTrap,\n                private getPrototypeOfTrap: GetPrototypeOfTrap,\n                private setPrototypeOfTrap: SetPrototypeOfTrap) {\n    }\n\n    public object(): T {\n        if (this._proxy === undefined) {\n            this._proxy = this.createObject();\n        }\n\n        return this._proxy;\n    }\n\n    private createObject(): T {\n        const options = {\n            get: (target, name) => this.getTrap.intercept(name),\n            set: (target, name, value) => this.setTrap.intercept(target, name, value),\n            has: (target, name) => this.hasTrap.intercept(name),\n            apply: (target, thisArg, args) => this.applyTrap.intercept(target, thisArg, args),\n            getPrototypeOf: () => this.getPrototypeOfTrap.intercept(),\n            setPrototypeOf: (target, prototype) => this.setPrototypeOfTrap.intercept(prototype)\n        };\n\n        if (this.options.name) {\n            options[\"mockName\"] = this.options.name;\n        }\n\n        return new Proxy(this.options.target, options);\n    }\n}\n","import { IMock } from \"../moq\";\nimport { InjectionToken } from \"../static.injector/injection_token\";\n\n/**\n * @Hidden\n */\nexport const MOCK = new InjectionToken<IMock<unknown>>(\"IMock\");\n","import { IMockOptions } from \"../moq\";\nimport { InjectionToken } from \"../static.injector/injection_token\";\n\n/**\n * @hidden\n */\nexport const MOCK_OPTIONS = new InjectionToken<IMockOptions<any>>(\"mock options\");\n","import { ApplyTrap } from \"./apply.trap\";\nimport { Tracker } from \"../tracker/tracker\";\nimport { InteractionPlayer } from \"../interaction-players/interaction.player\";\nimport { GetTrap } from \"./get.trap\";\nimport { PropertiesValueStorage } from \"./properties-value.storage\";\nimport { HasPropertyExplorer } from \"../explorers/has-property.explorer/has-property.explorer\";\nimport { HasMethodExplorer } from \"../explorers/has-method.explorer/has-method.explorer\";\nimport { SpyFunctionProvider } from \"./spy-function.provider\";\nimport { GetPrototypeOfTrap } from \"./get-prototype-of.trap\";\nimport { PrototypeStorage } from \"./prototype.storage\";\nimport { HasTrap } from \"./has.trap\";\nimport { InOperatorInteractionExplorer } from \"../explorers/in-operator-interaction.explorer/in-operator-interaction.explorer\";\nimport { PresetPlayablesUpdater } from \"../playables/preset-playables.updater\";\nimport { SetTrap } from \"./set.trap\";\nimport { SetPrototypeOfTrap } from \"./set-prototype-of.trap\";\nimport { ProxyFactory } from \"./proxy.factory\";\nimport { MOCK } from \"../injector/moq.injection-token\";\nimport { MOCK_OPTIONS } from \"../mock-options/mock-options.injection-token\";\nimport { PropertyIsReadOnlyTester } from \"../explorers/has-property.explorer/property-is-read-only.tester\";\n\n/**\n * @hidden\n */\nexport const interceptorsProviders = [\n    {\n        provide: ProxyFactory, useClass: ProxyFactory, deps: [\n            MOCK_OPTIONS,\n            GetTrap,\n            SetTrap,\n            HasTrap,\n            ApplyTrap,\n            GetPrototypeOfTrap,\n            SetPrototypeOfTrap\n        ]\n    },\n    {provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer]},\n    {\n        provide: GetTrap, useClass: GetTrap, deps: [\n            MOCK,\n            Tracker,\n            PropertiesValueStorage,\n            InteractionPlayer,\n            HasPropertyExplorer,\n            HasMethodExplorer,\n            SpyFunctionProvider\n        ]\n    },\n    {provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage]},\n    {\n        provide: HasTrap, useClass: HasTrap, deps: [\n            Tracker,\n            PropertiesValueStorage,\n            InteractionPlayer,\n            InOperatorInteractionExplorer,\n            HasPropertyExplorer,\n            HasMethodExplorer,\n            PresetPlayablesUpdater\n        ]\n    },\n    {provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: []},\n    {provide: PrototypeStorage, useFactory: ({target}) => new PrototypeStorage(target), deps: [MOCK_OPTIONS]},\n    {provide: SetTrap, useClass: SetTrap, deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester]},\n    {provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage]},\n    {provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer]},\n];\n","import { IMockOptions } from \"../moq\";\n\n/**\n * @hidden\n */\nexport class MockOptionsBuilder {\n    build<T>(options: IMockOptions<T>) {\n        const target = (() => undefined) as unknown as T;\n        return {target, ...options};\n    }\n}\n\n","import { PresetPlayablesUpdater } from \"./preset-playables.updater\";\nimport { Presets } from \"../presets/presets\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\n\n/**\n * @hidden\n */\nexport const playablesProviders = [\n    {provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionMatcher]}\n];\n","import { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\nimport { PresetBuilder } from \"./preset-builder\";\nimport { InjectionToken } from \"../static.injector/injection_token\";\n\n/**\n * @hidden\n */\nexport const PRESET_BUILDER_FACTORY = new InjectionToken<<T>(target: ExpectedExpressions<T>) => PresetBuilder<T>>(\"PRESET_BUILDER_FACTORY\");\n","import { IPlayable, PlayableUpdateReason } from \"../moq\";\n\n/**\n * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.\n */\nexport class PlayableExactly implements IPlayable {\n    private invoked = 0;\n\n    constructor(private count: number) {\n    }\n\n    readonly update = (reason: PlayableUpdateReason) => {\n        if (reason === PlayableUpdateReason.OwnSetupWouldBePlayed) {\n            this.invoked++;\n        }\n    };\n\n    readonly isPlayable = () => this.invoked <= this.count;\n}\n","import { IPlayable } from \"../moq\";\n\n/**\n * The configured setup will be never applied to invocations.\n */\nexport class PlayableNever implements IPlayable {\n    readonly update = () => undefined;\n    readonly isPlayable = () => false;\n}\n","import { IPlayable, PlayableUpdateReason } from \"../moq\";\n\n/**\n * The configured setup will be applied only to the first invocation.\n */\nexport class PlayableOnce implements IPlayable {\n    private played = false;\n\n    readonly update = (reason: PlayableUpdateReason) => {\n        if (reason === PlayableUpdateReason.OwnSetupWouldBePlayed) {\n            this.played = true;\n        }\n    };\n\n    readonly isPlayable = () => this.played === false;\n}\n","import { IPlayable } from \"../moq\";\n\n/**\n * The configured setup will be always applied to invocations.\n */\nexport class PlayableAlways implements IPlayable {\n    readonly isPlayable = () => true;\n    readonly update = () => undefined;\n}\n","import { IPlayable } from \"../moq\";\n\n/**\n * The configured setup will be applied or not accordingly to the value in the sequence.\n *\n * @example\n * ```typescript\n *\n * const value = 'value';\n * const object = new Mock<Function>()\n * .setup(instance => instance(1))\n * .play(PlayTimes.Sequence([false, true]))\n * .returns(value)\n * .object();\n *\n * expect(object(1).toBe(undefined);\n * expect(object(1).toBe(value);\n * expect(object(1).toBe(undefined);\n * ```\n */\nexport class PlayableSequence implements IPlayable {\n    private index = 0;\n\n    constructor(private sequence: boolean[]) {\n    }\n\n    readonly update = () => {\n        this.index++;\n    };\n\n    readonly isPlayable = () => {\n        if (this.index >= this.sequence.length) return false;\n        return this.sequence[this.index];\n    };\n}\n","import { IPlayable } from \"../moq\";\nimport { PlayableExactly } from \"./playable-exactly\";\nimport { PlayableNever } from \"./playable-never\";\nimport { PlayableOnce } from \"./playable-once\";\nimport { PlayableAlways } from \"./playable-always\";\nimport { PlayableSequence } from \"./playable-sequence\";\n\n\n/**\n * This class sets rules when a configured setup should be applied to the target invocation or not.\n *\n * @example\n * ```typescript\n *\n * const value = 'value';\n * const object = new Mock<Function>()\n * .setup(instance => instance(1))\n * .play(PlayTimes.Once())\n * .returns(value)\n * .object();\n *\n * expect(object(1).toBe(value);\n * expect(object(1).toBe(undefined);\n * ```\n */\nexport class PlayTimes {\n    private static readonly always = new PlayableAlways();\n    private static readonly never = new PlayableNever();\n\n    /**\n     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.\n     */\n    public static Exactly(count: number): IPlayable {\n        return new PlayableExactly(count);\n    }\n\n    /**\n     * The configured setup will be always applied to invocations.\n     */\n    public static Always(): IPlayable {\n        return PlayTimes.always;\n    }\n\n    /**\n     * The configured setup will be never applied to invocations.\n     */\n    public static Never(): IPlayable {\n        return PlayTimes.never;\n    }\n\n    /**\n     * The configured setup will be applied only to the first invocation.\n     */\n    public static Once(): IPlayable {\n        return new PlayableOnce();\n    }\n\n    /**\n     * The configured setup will be applied or not accordingly to the value in the sequence.\n     *\n     * @example\n     * ```typescript\n     *\n     * const value = 'value';\n     * const object = new Mock<Function>()\n     * .setup(instance => instance(1))\n     * .play(PlayTimes.Sequence([false, true]))\n     * .returns(value)\n     * .object();\n     *\n     * expect(object(1).toBe(undefined);\n     * expect(object(1).toBe(value);\n     * expect(object(1).toBe(undefined);\n     * ```\n     */\n    public static Sequence(sequence: boolean[]): IPlayable {\n        return new PlayableSequence(sequence);\n    }\n}\n","import { IMock, IPlayable, IPresetBuilder } from \"../moq\";\nimport { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\nimport { IPreset } from \"./presets/preset\";\nimport { MimicsPreset } from \"./presets/mimics.preset\";\nimport { ReturnsPreset } from \"./presets/returns.preset\";\nimport { ThrowsPreset } from \"./presets/throws.preset\";\nimport { CallbacksPreset } from \"./presets/callbacks.preset\";\nimport { Interaction } from \"../interactions\";\nimport { PlayTimes } from \"../playables/play-times\";\n\n/**\n * The default implementation of {@link IPresetBuilder} interface.\n * Is it not intended to be used outside of the moq library.\n *\n * @hidden\n */\nexport class PresetBuilder<T, TValue = any> implements IPresetBuilder<T> {\n\n    constructor(\n        private mock: IMock<T>,\n        private set: (preset: IPreset<T>) => void,\n        private target: ExpectedExpressions<T>,\n        private playable: IPlayable = PlayTimes.Always()) {\n\n    }\n\n    public mimics(origin: T): IMock<T> {\n        const preset = new MimicsPreset(this.playable, this.target, origin);\n        this.set(preset);\n        return this.mock;\n    }\n\n    public returns(value: TValue): IMock<T> {\n        const preset = new ReturnsPreset(this.playable, this.target, value);\n        this.set(preset);\n        return this.mock;\n    }\n\n    public throws<TException>(exception: TException): IMock<T> {\n        const preset = new ThrowsPreset(this.playable, this.target, exception);\n        this.set(preset);\n        return this.mock;\n    }\n\n    public callback(callback: (interaction: Interaction) => TValue): IMock<T> {\n        const preset = new CallbacksPreset(this.playable, this.target, callback);\n        this.set(preset);\n        return this.mock;\n    }\n\n    public play(playable: IPlayable): IPresetBuilder<T> {\n        this.playable = playable;\n        return this;\n    }\n}\n","import { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\nimport { PresetBuilder } from \"./preset-builder\";\nimport { Presets } from \"./presets\";\nimport { MOCK } from \"../injector/moq.injection-token\";\nimport { PRESET_BUILDER_FACTORY } from \"./preset-builder-factory.injection-token\";\n\n/**\n * @hidden\n */\nexport const presetsProviders = [\n    {provide: Presets, useClass: Presets, deps: []},\n    {\n        provide: PRESET_BUILDER_FACTORY, useFactory: (mock, presets) => <T>(target: ExpectedExpressions<T>) =>\n            new PresetBuilder<T>(mock, preset => presets.add(preset), target), deps: [MOCK, Presets]\n    }\n];\n","/* eslint-disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport const Type = Function;\n\n/**\n * @description\n *\n * Represents an abstract class `T`, if applied to a concrete class it would stop being\n * instantiatable.\n *\n * @publicApi\n */\nexport interface AbstractType<T> extends Function {\n    prototype: T;\n}\n\nexport type Type<T> = new(...args: any[]) => T;\n","/**\n * @hidden\n */\nexport class SequenceId {\n    private value = 0;\n\n    public next(): number {\n        return this.value++;\n    }\n}\n","import { SequenceId } from \"./sequence-id\";\nimport { Tracker } from \"./tracker\";\n\n/**\n * @hidden\n */\nexport const trackerProviders = [\n    {provide: SequenceId, useClass: SequenceId, deps: []},\n    {provide: Tracker, useClass: Tracker, deps: [SequenceId]}\n];\n","import { ExpectedExpressions } from \"../expected-expressions/expected-expressions\";\nimport { Interaction } from \"../interactions\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\n\n/**\n * @hidden\n */\nexport class CallCounter {\n\n    constructor(private expressionMatcher: ExpressionMatcher) {\n\n    }\n\n    public count<T>(expected: ExpectedExpressions<T>, expressions: Interaction[]): number {\n        let count = 0;\n        for (const expression of expressions) {\n            if (this.expressionMatcher.matched(expression, expected) === true) {\n                count += 1;\n            }\n        }\n\n        return count;\n    }\n}\n","export class VerifyError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n","import { Times } from \"../times\";\nimport { Interaction } from \"../interactions\";\nimport {\n    ExpectedExpressionReflector,\n    IExpectedExpression\n} from \"../expected-expressions/expected-expression-reflector\";\nimport { CallCounter } from \"./call-counter\";\nimport { VerifyFormatter } from \"../formatters/verify-formatter\";\nimport { VerifyError } from \"./verify-error\";\n\n/**\n * @hidden\n */\nexport class Verifier<T> {\n\n    constructor(\n        private reflector: ExpectedExpressionReflector,\n        private callCounter: CallCounter,\n        private verifyFormatter: VerifyFormatter) {\n\n    }\n\n    public test(expected: IExpectedExpression<T>, times: Times, expressions: Interaction[], mockName?: string): void {\n        const expression = this.reflector.reflect(expected);\n        const callCount = this.callCounter.count(expression, expressions);\n        const passed = times.test(callCount);\n        if (passed === false) {\n            const message = this.verifyFormatter.format(expression, times.message, callCount, expressions, mockName);\n            throw new VerifyError(message);\n        }\n    }\n}\n","/**\n * @hidden\n */\nimport { Verifier } from \"./verifier\";\nimport { CallCounter } from \"./call-counter\";\nimport { VerifyFormatter } from \"../formatters/verify-formatter\";\nimport { ExpectedExpressionReflector } from \"../expected-expressions/expected-expression-reflector\";\nimport { ExpressionMatcher } from \"../expression-matchers/expression.matcher\";\n\nexport const verificationProviders = [\n    {provide: Verifier, useClass: Verifier, deps: [ExpectedExpressionReflector, CallCounter, VerifyFormatter]},\n    {provide: CallCounter, useClass: CallCounter, deps: [ExpressionMatcher]},\n];\n","import { IMockOptions } from \"../moq\";\nimport { MOCK_OPTIONS } from \"./mock-options.injection-token\";\nimport { MockOptionsBuilder } from \"./mock-options.builder\";\n\n/**\n * @hidden\n */\nexport function mockOptionsProviders<T>(options: IMockOptions<T>) {\n    return [\n        {provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: []},\n        {provide: MOCK_OPTIONS, useFactory: builder => builder.build(options), deps: [MockOptionsBuilder]},\n    ];\n}\n"]}