/**
 * A mock object exposes a symbol property to access to its Moq API.
 * This property is read only and trackable.
 * Since this property makes sense only in context of the moq library
 * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.
 *
 * @example
 * ```typescript
 *
 *  const mock = new Mock<() => void>()
 *  .object();
 *
 *  mock[MoqAPI]
 *  .setup(instance => instance())
 *  .returns(12);
 *
 *  const actual = mock();
 *
 *  expect(actual).toBe(12);
 * ```
 */
const MoqAPI = Symbol("MoqAPI");

/**
 * This class allows to express wide range of cases in an expression.
 * You can use it with setups or verifies methods.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
 *  .returns(value)
 *  .setup(instance => instance(It.IsAny())
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 *
 * This class could be used not only for args matching, but also for function names, property names and so on.
 *
 * @example
 * ```typescript
 *
 * const object = new Mock<ITestObject>()
 * // the expression dynamically checks the property name that is being read
 * .setup(instance => It.Is((expression: ExpectedGetPropertyExpression) => expression.name === 'property'))
 * .returns(value)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * //denis any write operation on the property
 * .setup(instance => { instance.property = It.IsAny()})
 * // true - allow, false - deny
 * .returns(false)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * .setup(instance => It.Is((expression: ExpectedNamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
 * .returns(value)
 * .object();
 *
 * // how to use with verify
 * mock.verify(instance => instance.method(It.Is(a => a === 2)));
 * ```
 */
class It {
    constructor(predicate) {
        this.predicate = predicate;
    }
    /**
     * This factory method returns an expression that matches custom cases.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static Is(predicate) {
        return new It(predicate);
    }
    /**
     * This factory method returns a wildcat expression that matches any value.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(any_value_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static IsAny() {
        return new It(() => true);
    }
    /**
     * @hidden
     */
    test(instance) {
        try {
            const result = this.predicate(instance);
            return result === true || result === undefined;
        }
        catch (e) {
            return false;
        }
    }
}

/*eslint-disable max-classes-per-file*/
class Interaction {
    constructor(name, args) {
        this.name = name;
        this.args = args;
    }
}
/**
 * This class represents an invocation of a named function.
 * It provides access to the name of function and list of parameters.
 */
class NamedMethodInteraction extends Interaction {
    constructor(name, args) {
        super(name, args);
    }
}
/**
 * This class represents an invocation of a function.
 * It provides access to the list of parameters.
 */
class MethodInteraction extends Interaction {
    constructor(args) {
        super(undefined, args);
    }
}
/**
 * This class represents a property accessing.
 * It provides access to the name of property.
 */
class GetPropertyInteraction extends Interaction {
    constructor(name) {
        super(name, undefined);
    }
}
/**
 * This class represents a property write interaction.
 * It provides access to the name of property and the value.
 */
class SetPropertyInteraction extends Interaction {
    constructor(name, value) {
        super(name, [value]);
        this.value = value;
    }
}
/**
 * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
 * It provides access to the name of property.
 */
class InOperatorInteraction extends Interaction {
    constructor(name) {
        super(name, undefined);
    }
}

// todo: check if could be renamed in expressions
/**
 * See {@link NamedMethodInteraction}
 */
class ExpectedNamedMethodExpression extends NamedMethodInteraction {
}
/**
 * See {@link MethodInteraction}
 */
class ExpectedMethodExpression extends MethodInteraction {
}
/**
 * See {@link GetPropertyInteraction}
 */
class ExpectedGetPropertyExpression extends GetPropertyInteraction {
}
/**
 * See {@link SetPropertyInteraction}
 */
class ExpectedSetPropertyExpression extends SetPropertyInteraction {
}
/**
 * See {@link InOperatorInteraction}
 */
class ExpectedInOperatorExpression extends InOperatorInteraction {
}

/**
 * This class reflects an expression to an expression tree representation.
 *
 * @example
 * ```typescript
 *
 * const arg = 'argument';
 * const reflector = new ExpectedExpressionReflector();
 * const actual = reflector.reflect<any>(instance => instance(arg));
 *
 * const expected = new ExpectedMethodExpression([arg]);
 * expect(actual).toEqual(expected);
 * ```
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/tests.unit/expected-expressions/expected-expression-reflector.UnitTests.ts)
 */
class ExpectedExpressionReflector {
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect(expression) {
        this.reflectedInfo = undefined;
        const proxy = this.expressionProxy();
        const predicate = expression(proxy);
        return predicate instanceof It && (this.reflectedInfo instanceof ExpectedSetPropertyExpression) === false
            ? predicate : this.reflectedInfo;
    }
    expressionProxy() {
        const options = {
            get: (target, name) => {
                this.reflectedInfo = new ExpectedGetPropertyExpression(name);
                return (...args) => {
                    this.reflectedInfo = new ExpectedNamedMethodExpression(name, args);
                };
            },
            set: (target, name, value) => {
                this.reflectedInfo = new ExpectedSetPropertyExpression(name, value);
                return true;
            },
            apply: (target, thisArg, args) => {
                this.reflectedInfo = new ExpectedMethodExpression(args);
            },
            has: (target, name) => {
                this.reflectedInfo = new ExpectedInOperatorExpression(name);
                return true;
            }
        };
        return new Proxy(() => undefined, options);
    }
}

/**
 * @hidden
 */
class ProxyFactory {
    constructor(options, getTrap, setTrap, hasTrap, applyTrap, getPrototypeOfTrap, setPrototypeOfTrap) {
        this.options = options;
        this.getTrap = getTrap;
        this.setTrap = setTrap;
        this.hasTrap = hasTrap;
        this.applyTrap = applyTrap;
        this.getPrototypeOfTrap = getPrototypeOfTrap;
        this.setPrototypeOfTrap = setPrototypeOfTrap;
    }
    object() {
        if (this._proxy === undefined) {
            this._proxy = this.createObject();
        }
        return this._proxy;
    }
    createObject() {
        const options = {
            get: (target, name) => this.getTrap.intercept(name),
            set: (target, name, value) => this.setTrap.intercept(target, name, value),
            has: (target, name) => this.hasTrap.intercept(name),
            apply: (target, thisArg, args) => this.applyTrap.intercept(target, thisArg, args),
            getPrototypeOf: () => this.getPrototypeOfTrap.intercept(),
            setPrototypeOf: (target, prototype) => this.setPrototypeOfTrap.intercept(prototype)
        };
        if (this.options.name) {
            options["mockName"] = this.options.name;
        }
        return new Proxy(this.options.target, options);
    }
}

/**
 * Sets the rules where bounds of a range are included or excluded from the range.
 * See {@link Times.Between}
 */
var Range;
(function (Range) {
    Range[Range["Exclusive"] = 0] = "Exclusive";
    Range[Range["Inclusive"] = 1] = "Inclusive";
})(Range || (Range = {}));
/**
 * This class expresses the expectation about amount of invocations.
 *
 * @example
 * ```typescript
 *
 * const times = new Times(expected => expected === 1, `Should be called once`);
 * const actual = times.test(2);
 *
 * expect(actual).toBe(false);
 * expect(times.message).toBe(`Should be called once`);
 * ```
 *
 * ```typescript
 *
 * const mockName = 'mock name';
 *const mock = new Mock<ITestObject>(mockName);
 *const object = mock.object();
 *
 *object.property;
 *
 *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
 *
 *expect(action).toThrow();
 * ```
 */
class Times {
    /**
     *
     * @param evaluator It takes actual value and decides if it is expected or not.
     * Returns true or false accordingly.
     * @param message A message that describes the expectation.
     */
    constructor(evaluator, message) {
        this.evaluator = evaluator;
        this.message = message;
    }
    /**
     * It expects that the actual would be equal or bigger then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtLeast(callCount) {
        return new Times(expected => expected >= callCount, `Should be called at least ${callCount} time(s)`);
    }
    /**
     * It expects that the actual would be equal or bigger then 1.
     */
    static AtLeastOnce() {
        return Times._atLeastOnce;
    }
    /**
     * It expects that the actual would be equal or smaller then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtMost(callCount) {
        return new Times(expected => expected <= callCount, `Should be called at most ${callCount} time(s)`);
    }
    /**
     * It expects that the actual would be equal or less then 1.
     */
    static AtMostOnce() {
        return Times._atMostOnce;
    }
    /**
     * It expects that the actual would be in the expected range of values.
     *
     * @param callCountFrom The lowest bound of the range.
     * @param callCountTo The highest bound of the range.
     * @param range  Sets the rules where bounds of a range are included or excluded from the range.
     */
    static Between(callCountFrom, callCountTo, range) {
        if (range === Range.Exclusive) {
            return new Times(expected => expected > callCountFrom && expected < callCountTo, `Should be called exclusively between ${callCountFrom} and ${callCountTo}`);
        }
        return new Times(expected => expected >= callCountFrom && expected <= callCountTo, `Should be called inclusively between ${callCountFrom} and ${callCountTo}`);
    }
    /**
     * It expects that the actual is equal to the expected value.
     *
     * @param callCount The expected value.
     */
    static Exactly(callCount) {
        return new Times(expected => expected === callCount, `Should be called exactly ${callCount} time(s)`);
    }
    /**
     * It expects that the actual is equal 0.
     */
    static Never() {
        return Times._never;
    }
    /**
     * It expects that the actual is equal 1.
     */
    static Once() {
        return Times._once;
    }
    /**
     * Evaluates the expectation against the actual value.
     *
     * @param callCount The actual value.
     */
    test(callCount) {
        return this.evaluator(callCount);
    }
}
Times._once = new Times(expected => expected === 1, "Should be called once");
Times._never = new Times(expected => expected === 0, "Should be called never");
Times._atMostOnce = new Times(expected => expected <= 1, "Should be called at most once");
Times._atLeastOnce = new Times(expected => expected >= 1, "Should be called at least once");

/**
 * This class records all interactions with a mocked object.
 */
class Tracker {
    constructor(sequenceId) {
        this.sequenceId = sequenceId;
        this.log = [];
    }
    /**
     * @hidden
     */
    add(action) {
        const record = { id: this.sequenceId.next(), expression: action };
        this.log.push(record);
    }
    /**
     * Returns recorded interactions.
     */
    get() {
        return [...this.log];
    }
}

class VerifyError extends Error {
    constructor(message) {
        super(message);
    }
}

/**
 * @hidden
 */
class Verifier {
    constructor(reflector, callCounter, verifyFormatter) {
        this.reflector = reflector;
        this.callCounter = callCounter;
        this.verifyFormatter = verifyFormatter;
    }
    test(expected, times, expressions, mockName) {
        const expression = this.reflector.reflect(expected);
        const callCount = this.callCounter.count(expression, expressions);
        const passed = times.test(callCount);
        if (passed === false) {
            const message = this.verifyFormatter.format(expression, times.message, callCount, expressions, mockName);
            throw new VerifyError(message);
        }
    }
}

/**
 * @hidden
 */
class PrototypeStorage {
    constructor(mockTarget) {
        var _a;
        this.prototype = null;
        this.prototype = (_a = mockTarget === null || mockTarget === void 0 ? void 0 : mockTarget.prototype) !== null && _a !== void 0 ? _a : mockTarget;
    }
    get() {
        return this.prototype;
    }
    set(prototype) {
        this.prototype = prototype;
    }
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function stringify(token) {
    if (typeof token === "string") {
        return token;
    }
    if (Array.isArray(token)) {
        return `[${token.map(stringify).join(", ")}]`;
    }
    if (token == null) {
        return `${token}`;
    }
    if (token.overriddenName) {
        return `${token.overriddenName}`;
    }
    if (token.name) {
        return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
        return `${res}`;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function getClosureSafeProperty(objWithPropertyToExtract) {
    for (const key in objWithPropertyToExtract) {
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
            return key;
        }
    }
    throw Error("Could not find renamed property on target object.");
}

/* eslint-disable */
const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
 * a query is not yet defined.
 *
 * @usageNotes
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
 * @publicApi
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () {
        return stringify(this());
    };
    return forwardRefFn;
}
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * @usageNotes
 * ### Example
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
 *
 * @see `forwardRef`
 * @publicApi
 */
function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
}
/** Checks whether a function is wrapped by a `forwardRef`. */
function isForwardRef(fn) {
    return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) &&
        fn.__forward_ref__ === forwardRef;
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class InjectionToken {
    constructor(desc) {
        this.desc = desc;
    }
    toString() {
        return `InjectionToken ${this.desc}`;
    }
}

/* eslint-disable */
/**
 * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
 *
 * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
 * project.
 *
 * @publicApi
 */
const INJECTOR = new InjectionToken("INJECTOR");
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
const NG_TOKEN_PATH = "ngTokenPath";
const NEW_LINE = /\n/gm;
const NO_NEW_LINE = "ɵ";
const SOURCE = "__source";
const ɵ0 = getClosureSafeProperty;
const USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 });
class NullInjector {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
            error.name = "NullInjectorError";
            throw error;
        }
        return notFoundValue;
    }
}
function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) {
        tokenPath.unshift(token[SOURCE]);
    }
    e.message = formatError(`\n${e.message}`, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === "\n" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
        context = obj.map(stringify).join(" -> ");
    }
    else if (typeof obj === "object") {
        const parts = [];
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                parts.push(`${key}:${typeof value === "string" ? JSON.stringify(value) : stringify(value)}`);
            }
        }
        context = `{${parts.join(", ")}}`;
    }
    return `${injectorErrorName}${source ? `(${source})` : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection flags for DI.
 *
 * @publicApi
 */
var InjectFlags;
(function (InjectFlags) {
    // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
    /** Check self and check parent injector if needed */
    InjectFlags[InjectFlags["Default"] = 0] = "Default";
    /**
     * Specifies that an injector should retrieve a dependency from any injector until reaching the
     * host element of the current component. (Only used with Element Injector)
     */
    InjectFlags[InjectFlags["Host"] = 1] = "Host";
    /** Don't ascend to ancestors of the node requesting injection. */
    InjectFlags[InjectFlags["Self"] = 2] = "Self";
    /** Skip the node that is requesting injection. */
    InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
    /** Inject `defaultValue` instead if token not found. */
    InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type of the Optional metadata.
 */
class Optional {
}
/**
 * Type of the Self metadata.
 */
class Self {
}
/**
 * Type of the SkipSelf metadata.
 */
class SkipSelf {
}
/**
 * Type of the Host metadata.
 */
class Host {
}

/* eslint-disable */
const INJECTOR_IMPL = (providers, parent, name) => new StaticInjector(providers, parent, name);
/**
 * Concrete injectors implement this interface. Injectors are configured
 * with [providers](guide/glossary#provider) that associate
 * dependencies of various types with [injection tokens](guide/glossary#di-token).
 *
 * @see ["DI Providers"](guide/dependency-injection-providers).
 * @see `StaticProvider`
 *
 * @usageNotes
 *
 *  The following example creates a service injector instance.
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Usage example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @publicApi
 */
class Injector {
    static create(options, parent) {
        if (Array.isArray(options)) {
            return INJECTOR_IMPL(options, parent, "");
        }
        else {
            return INJECTOR_IMPL(options.providers, options.parent, options.name || "");
        }
    }
}
Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
Injector.NULL = new NullInjector();
/**
 * @internal
 * @nocollapse
 */
Injector.__NG_ELEMENT_ID__ = -1;
const IDENT = function (value) {
    return value;
};
const ɵ0$1 = IDENT;
const EMPTY = [];
const CIRCULAR = IDENT;
const MULTI_PROVIDER_FN = function () {
    return Array.prototype.slice.call(arguments);
};
const ɵ1 = MULTI_PROVIDER_FN;
class StaticInjector {
    constructor(providers, parent = new NullInjector(), source = null) {
        this.parent = parent;
        this.source = source;
        const records = this._records = new Map();
        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        this.scope = recursivelyProcessProviders(records, providers);
    }
    get(token, notFoundValue, flags = InjectFlags.Default) {
        const records = this._records;
        const record = records.get(token);
        if (record === undefined) {
            records.set(token, null);
        }
        try {
            return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            return catchInjectorError(e, token, "StaticInjectorError", this.source);
        }
    }
    toString() {
        const tokens = [];
        const records = this._records;
        records.forEach((v, token) => tokens.push(stringify(token)));
        return `StaticInjector[${tokens.join(", ")}]`;
    }
}
function resolveProvider(provider) {
    const deps = computeDeps(provider);
    let fn = IDENT;
    let value = EMPTY;
    let useNew = false;
    const provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value = provider.useValue;
    }
    else if (provider.useFactory) {
        fn = provider.useFactory;
    }
    else if (provider.useExisting) {
        // Just use IDENT
    }
    else if (provider.useClass) {
        useNew = true;
        fn = resolveForwardRef(provider.useClass);
    }
    else if (typeof provide === "function") {
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
    }
    return { deps, fn, useNew, value };
}
function multiProviderMixError(token) {
    return staticError("Cannot mix multi providers and regular providers", token);
}
function recursivelyProcessProviders(records, provider) {
    let scope = null;
    if (provider) {
        provider = resolveForwardRef(provider);
        if (Array.isArray(provider)) {
            // if we have an array recurse into the array
            for (let i = 0; i < provider.length; i++) {
                scope = recursivelyProcessProviders(records, provider[i]) || scope;
            }
        }
        else if (typeof provider === "function") {
            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
            // error messages
            throw staticError("Function/Class not supported", provider);
        }
        else if (provider && typeof provider === "object" && provider.provide) {
            // At this point we have what looks like a provider: {provide: ?, ....}
            let token = resolveForwardRef(provider.provide);
            const resolvedProvider = resolveProvider(provider);
            if (provider.multi === true) {
                // This is a multi provider.
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    // Create a placeholder factory which will look up the constituents of the multi provider.
                    records.set(token, multiProvider = {
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    });
                }
                // Treat the provider as the token.
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            const record = records.get(token);
            if (record && record.fn === MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError("Unexpected provider", provider);
        }
    }
    return scope;
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        if (record && record.value === CIRCULAR) {
            // Reset the Circular flag.
            record.value = EMPTY;
        }
        throw e;
    }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    let value;
    // eslint-disable-next-line no-bitwise
    if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;
        if (value === CIRCULAR) {
            throw Error(`${NO_NEW_LINE}Circular dependency`);
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            const { useNew, fn, deps: depRecords } = record;
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    const depRecord = depRecords[i];
                    const options = depRecord.options;
                    // eslint-disable-next-line no-bitwise
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(
                    // Current Token to resolve
                    depRecord.token, 
                    // A record which describes how to resolve the token.
                    // If undefined, this means we don't have such a record
                    childRecord, 
                    // Other records we know about.
                    records, 
                    // If we don't know how to resolve dependency and we should not check parent for it,
                    // than pass in Null injector.
                    // eslint-disable-next-line no-bitwise
                    !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, 
                    // eslint-disable-next-line no-bitwise
                    options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new fn(...deps) : fn.apply(undefined, deps);
        }
        // eslint-disable-next-line no-bitwise
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
        // eslint-disable-next-line no-bitwise
    }
    else if (!(flags & InjectFlags.Optional)) {
        value = Injector.NULL.get(token, notFoundValue);
    }
    else {
        value = Injector.NULL.get(token, typeof notFoundValue !== "undefined" ? notFoundValue : null);
    }
    return value;
}
function computeDeps(provider) {
    let deps = EMPTY;
    const providerDeps = provider.deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            let options = 6 /* Default */;
            let token = resolveForwardRef(providerDeps[i]);
            if (Array.isArray(token)) {
                for (let j = 0, annotations = token; j < annotations.length; j++) {
                    const annotation = annotations[j];
                    if (annotation instanceof Optional || annotation === Optional) {
                        // eslint-disable-next-line no-bitwise
                        options = options | 1 /* Optional */;
                    }
                    else if (annotation instanceof SkipSelf || annotation === SkipSelf) {
                        // eslint-disable-next-line no-bitwise
                        options = options & ~2 /* CheckSelf */;
                    }
                    else if (annotation instanceof Self || annotation === Self) {
                        // eslint-disable-next-line no-bitwise
                        options = options & ~4 /* CheckParent */;
                    }
                    else {
                        token = resolveForwardRef(annotation);
                    }
                }
            }
            deps.push({ token, options });
        }
    }
    else if (provider.useExisting) {
        const token = resolveForwardRef(provider.useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError("'deps' required", provider);
    }
    return deps;
}
function staticError(text, obj) {
    return new Error(formatError(text, obj, "StaticInjectorError"));
}

/**
 * Creates an angular based injector
 */
function injectorFactory(options, ...providers) {
    const { injectorConfig } = options;
    if (injectorConfig) {
        return Injector.create({ providers: injectorConfig.get(options, providers) });
    }
    throw new Error("injectorConfig is not defined");
}

/**
 * @Hidden
 */
const MOCK = new InjectionToken("IMock");

/**
 * @hidden
 */
const MOCK_OPTIONS = new InjectionToken("mock options");

/**
 * @hidden
 */
const PRESET_BUILDER_FACTORY = new InjectionToken("PRESET_BUILDER_FACTORY");

/**
 * @hidden
 */
class SequenceId {
    constructor() {
        this.value = 0;
    }
    next() {
        return this.value++;
    }
}

/**
 * @hidden
 */
const trackerProviders = [
    { provide: SequenceId, useClass: SequenceId, deps: [] },
    { provide: Tracker, useClass: Tracker, deps: [SequenceId] }
];

/**
 * @hidden
 */
const reflectorProviders = [
    { provide: ExpectedExpressionReflector, useClass: ExpectedExpressionReflector, deps: [] }
];

class MimicsPreset {
    constructor(playable, target, origin) {
        this.playable = playable;
        this.target = target;
        this.origin = origin;
    }
}

class ReturnsPreset {
    constructor(playable, target, value) {
        this.playable = playable;
        this.target = target;
        this.value = value;
    }
}

class ThrowsPreset {
    constructor(playable, target, exception) {
        this.playable = playable;
        this.target = target;
        this.exception = exception;
    }
}

class CallbacksPreset {
    constructor(playable, target, callback) {
        this.playable = playable;
        this.target = target;
        this.callback = callback;
    }
}

/**
 * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
 */
class PlayableExactly {
    constructor(count) {
        this.count = count;
        this.invoked = 0;
        this.update = (reason) => {
            if (reason === 0 /* OwnSetupWouldBePlayed */) {
                this.invoked++;
            }
        };
        this.isPlayable = () => this.invoked <= this.count;
    }
}

/**
 * The configured setup will be never applied to invocations.
 */
class PlayableNever {
    constructor() {
        this.update = () => undefined;
        this.isPlayable = () => false;
    }
}

/**
 * The configured setup will be applied only to the first invocation.
 */
class PlayableOnce {
    constructor() {
        this.played = false;
        this.update = (reason) => {
            if (reason === 0 /* OwnSetupWouldBePlayed */) {
                this.played = true;
            }
        };
        this.isPlayable = () => this.played === false;
    }
}

/**
 * The configured setup will be always applied to invocations.
 */
class PlayableAlways {
    constructor() {
        this.isPlayable = () => true;
        this.update = () => undefined;
    }
}

/**
 * The configured setup will be applied or not accordingly to the value in the sequence.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Sequence([false, true]))
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(undefined);
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
class PlayableSequence {
    constructor(sequence) {
        this.sequence = sequence;
        this.index = 0;
        this.update = () => {
            this.index++;
        };
        this.isPlayable = () => {
            if (this.index >= this.sequence.length)
                return false;
            return this.sequence[this.index];
        };
    }
}

/**
 * This class sets rules when a configured setup should be applied to the target invocation or not.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Once())
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
class PlayTimes {
    /**
     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
     */
    static Exactly(count) {
        return new PlayableExactly(count);
    }
    /**
     * The configured setup will be always applied to invocations.
     */
    static Always() {
        return PlayTimes.always;
    }
    /**
     * The configured setup will be never applied to invocations.
     */
    static Never() {
        return PlayTimes.never;
    }
    /**
     * The configured setup will be applied only to the first invocation.
     */
    static Once() {
        return new PlayableOnce();
    }
    /**
     * The configured setup will be applied or not accordingly to the value in the sequence.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Sequence([false, true]))
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(undefined);
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    static Sequence(sequence) {
        return new PlayableSequence(sequence);
    }
}
PlayTimes.always = new PlayableAlways();
PlayTimes.never = new PlayableNever();

/**
 * The default implementation of {@link IPresetBuilder} interface.
 * Is it not intended to be used outside of the moq library.
 *
 * @hidden
 */
class PresetBuilder {
    constructor(mock, set, target, playable = PlayTimes.Always()) {
        this.mock = mock;
        this.set = set;
        this.target = target;
        this.playable = playable;
    }
    mimics(origin) {
        const preset = new MimicsPreset(this.playable, this.target, origin);
        this.set(preset);
        return this.mock;
    }
    returns(value) {
        const preset = new ReturnsPreset(this.playable, this.target, value);
        this.set(preset);
        return this.mock;
    }
    throws(exception) {
        const preset = new ThrowsPreset(this.playable, this.target, exception);
        this.set(preset);
        return this.mock;
    }
    callback(callback) {
        const preset = new CallbacksPreset(this.playable, this.target, callback);
        this.set(preset);
        return this.mock;
    }
    play(playable) {
        this.playable = playable;
        return this;
    }
}

/**
 * @hidden
 */
class Presets {
    constructor() {
        this.presets = [];
    }
    add(preset) {
        this.presets.unshift(preset);
    }
    get() {
        return [...this.presets];
    }
}

const ɵ0$2 = (mock, presets) => (target) => new PresetBuilder(mock, preset => presets.add(preset), target);
/**
 * @hidden
 */
const presetsProviders = [
    { provide: Presets, useClass: Presets, deps: [] },
    {
        provide: PRESET_BUILDER_FACTORY,
        useFactory: ɵ0$2,
        deps: [MOCK, Presets]
    }
];

/**
 * @hidden
 */
class CallCounter {
    constructor(expressionMatcher) {
        this.expressionMatcher = expressionMatcher;
    }
    count(expected, expressions) {
        let count = 0;
        for (const expression of expressions) {
            if (this.expressionMatcher.matched(expression, expected) === true) {
                count += 1;
            }
        }
        return count;
    }
}

/**
 * @hidden
 */
class VerifyFormatter {
    constructor(expectedExpressionFormatter, trackedExpressionsFormatter) {
        this.expectedExpressionFormatter = expectedExpressionFormatter;
        this.trackedExpressionsFormatter = trackedExpressionsFormatter;
    }
    format(expected, timesMessage, haveBeenCalledTimes, trackedExpressions, mockName) {
        const expectedExpressionMessage = this.expectedExpressionFormatter.format(expected, timesMessage, haveBeenCalledTimes, mockName);
        const trackedExpressionsMessage = this.trackedExpressionsFormatter.format(trackedExpressions);
        const delimiter = "-------------------------------------";
        return `${expectedExpressionMessage}\n${delimiter}\nTracked calls:\n${trackedExpressionsMessage}\n${delimiter}\n`;
    }
}

/**
 * @hidden
 */
class ExpressionMatcher {
    constructor(getPropertyExpressionMatcher, setPropertyExpressionMatcher, methodExpressionMatcher, namedMethodExpressionMatcher, inOperatorExpressionMatcher) {
        this.getPropertyExpressionMatcher = getPropertyExpressionMatcher;
        this.setPropertyExpressionMatcher = setPropertyExpressionMatcher;
        this.methodExpressionMatcher = methodExpressionMatcher;
        this.namedMethodExpressionMatcher = namedMethodExpressionMatcher;
        this.inOperatorExpressionMatcher = inOperatorExpressionMatcher;
    }
    matched(left, right) {
        if (left === right)
            return true;
        if (right === undefined)
            return true;
        if (left instanceof GetPropertyInteraction && (right instanceof ExpectedGetPropertyExpression || right instanceof It)) {
            return this.getPropertyExpressionMatcher.matched(left, right);
        }
        if (left instanceof SetPropertyInteraction && (right instanceof ExpectedSetPropertyExpression || right instanceof It)) {
            return this.setPropertyExpressionMatcher.matched(left, right);
        }
        if (left instanceof InOperatorInteraction && (right instanceof ExpectedInOperatorExpression || right instanceof It)) {
            return this.inOperatorExpressionMatcher.matched(left, right);
        }
        if (left instanceof MethodInteraction && (right instanceof ExpectedMethodExpression || right instanceof It)) {
            return this.methodExpressionMatcher.matched(left, right);
        }
        if (left instanceof NamedMethodInteraction && (right instanceof ExpectedNamedMethodExpression || right instanceof It)) {
            return this.namedMethodExpressionMatcher.matched(left, right);
        }
        return false;
    }
}

/**
 * @hidden
 */
const verificationProviders = [
    { provide: Verifier, useClass: Verifier, deps: [ExpectedExpressionReflector, CallCounter, VerifyFormatter] },
    { provide: CallCounter, useClass: CallCounter, deps: [ExpressionMatcher] },
];

/**
 * @hidden
 */
class ApplyTrap {
    constructor(tracker, interactionPlayer) {
        this.tracker = tracker;
        this.interactionPlayer = interactionPlayer;
    }
    intercept(target, thisArg, argArray) {
        const expression = new MethodInteraction(argArray);
        this.tracker.add(expression);
        return this.interactionPlayer.play(expression);
    }
}

/**
 * @hidden
 */
class InteractionPlayer {
    constructor(playablePresetProvider, presetPlayablesUpdater, presetPlayer) {
        this.playablePresetProvider = playablePresetProvider;
        this.presetPlayablesUpdater = presetPlayablesUpdater;
        this.presetPlayer = presetPlayer;
    }
    play(interaction) {
        const preset = this.playablePresetProvider.get(interaction);
        this.presetPlayablesUpdater.update(interaction, preset);
        if (preset === undefined)
            return undefined;
        return this.presetPlayer.play(preset, interaction);
    }
}

/**
 * @hidden
 */
class GetTrap {
    constructor(mock, tracker, propertiesValueStorage, interactionPlayer, hasPropertyExplorer, hasMethodExplorer, spyFunctionProvider) {
        this.mock = mock;
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.hasPropertyExplorer = hasPropertyExplorer;
        this.hasMethodExplorer = hasMethodExplorer;
        this.spyFunctionProvider = spyFunctionProvider;
    }
    intercept(property) {
        const interaction = new GetPropertyInteraction(property);
        this.tracker.add(interaction);
        if (property === MoqAPI) {
            return this.mock;
        }
        if (this.propertiesValueStorage.has(property)) {
            return this.propertiesValueStorage.get(property);
        }
        if (this.hasPropertyExplorer.has(property)) {
            return this.interactionPlayer.play(interaction);
        }
        if (this.hasMethodExplorer.has(property)) {
            return this.spyFunctionProvider.get(property);
        }
        return this.interactionPlayer.play(interaction);
    }
}

class PropertiesValueStorage {
    constructor() {
        this.storage = new Map();
    }
    has(property) {
        return this.storage.has(property);
    }
    get(property) {
        return this.storage.get(property);
    }
    set(property, value) {
        this.storage.set(property, value);
    }
}

/**
 * @hidden
 */
class HasPropertyExplorer {
    constructor(presets, membersExplorer, explorer) {
        this.presets = presets;
        this.membersExplorer = membersExplorer;
        this.explorer = explorer;
    }
    has(name) {
        if (this.membersExplorer.hasProperty(name)) {
            return true;
        }
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class HasMethodExplorer {
    constructor(presets, membersExplorer, explorer) {
        this.presets = presets;
        this.membersExplorer = membersExplorer;
        this.explorer = explorer;
    }
    has(name) {
        if (this.membersExplorer.hasMethod(name)) {
            return true;
        }
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class SpyFunctionProvider {
    constructor(tracker, interactionPlayer) {
        this.tracker = tracker;
        this.interactionPlayer = interactionPlayer;
        this.map = new Map();
    }
    get(property) {
        if (this.map.has(property) === false) {
            this.map.set(property, (...args) => {
                const interaction = new NamedMethodInteraction(property, args);
                this.tracker.add(interaction);
                return this.interactionPlayer.play(interaction);
            });
        }
        return this.map.get(property);
    }
}

/**
 * @hidden
 */
class GetPrototypeOfTrap {
    constructor(prototypeStorage) {
        this.prototypeStorage = prototypeStorage;
    }
    intercept() {
        return this.prototypeStorage.get();
    }
}

/**
 * @hidden
 */
class HasTrap {
    constructor(tracker, propertiesValueStorage, interactionPlayer, inOperatorInteractionExplorer, hasPropertyExplorer, hasMethodExplorer, presetPlayablesUpdater) {
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.inOperatorInteractionExplorer = inOperatorInteractionExplorer;
        this.hasPropertyExplorer = hasPropertyExplorer;
        this.hasMethodExplorer = hasMethodExplorer;
        this.presetPlayablesUpdater = presetPlayablesUpdater;
    }
    intercept(property) {
        const interaction = new InOperatorInteraction(property);
        this.tracker.add(interaction);
        if (this.propertiesValueStorage.has(property)) {
            return true;
        }
        if (this.inOperatorInteractionExplorer.has(property)) {
            return this.interactionPlayer.play(interaction);
        }
        this.presetPlayablesUpdater.update(interaction, undefined);
        if (this.hasPropertyExplorer.has(property)) {
            return true;
        }
        if (this.hasMethodExplorer.has(property)) {
            return true;
        }
        return false;
    }
}

/**
 * @hidden
 */
class InOperatorInteractionExplorer {
    constructor(presets, explorer) {
        this.presets = presets;
        this.explorer = explorer;
    }
    has(name) {
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class PresetPlayablesUpdater {
    constructor(presets, matcher) {
        this.presets = presets;
        this.matcher = matcher;
    }
    update(interaction, playable) {
        for (const preset of this.presets.get()) {
            const { target, playable: { update } } = preset;
            if (this.matcher.matched(interaction, target)) {
                const reason = preset === playable ?
                    0 /* OwnSetupWouldBePlayed */ :
                    1 /* OtherSetupWouldBePlayed */;
                update(reason);
            }
        }
    }
}

/**
 * @hidden
 */
class SetTrap {
    constructor(tracker, propertiesValueStorage, interactionPlayer, propertyIsReadOnlyTester) {
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.propertyIsReadOnlyTester = propertyIsReadOnlyTester;
    }
    intercept(target, property, value) {
        const expression = new SetPropertyInteraction(property, value);
        this.tracker.add(expression);
        if (property === MoqAPI) {
            return false;
        }
        if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {
            return false;
        }
        const accepted = this.interactionPlayer.play(expression);
        if (accepted === true || accepted === undefined) {
            this.propertiesValueStorage.set(property, value);
        }
        return accepted === undefined ? true : accepted;
    }
}

/**
 * @hidden
 */
class SetPrototypeOfTrap {
    constructor(prototypeStorage) {
        this.prototypeStorage = prototypeStorage;
    }
    intercept(prototype) {
        if (prototype !== undefined) {
            this.prototypeStorage.set(prototype);
            return true;
        }
        return false;
    }
}

/**
 * @hidden
 */
class PropertyIsReadOnlyTester {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    isReadOnly(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.get instanceof Function && descriptor.set === undefined || descriptor.writable === false;
        }
        return false;
    }
}

const ɵ0$3 = ({ target }) => new PrototypeStorage(target);
/**
 * @hidden
 */
const interceptorsProviders = [
    {
        provide: ProxyFactory, useClass: ProxyFactory, deps: [
            MOCK_OPTIONS,
            GetTrap,
            SetTrap,
            HasTrap,
            ApplyTrap,
            GetPrototypeOfTrap,
            SetPrototypeOfTrap
        ]
    },
    { provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer] },
    {
        provide: GetTrap, useClass: GetTrap, deps: [
            MOCK,
            Tracker,
            PropertiesValueStorage,
            InteractionPlayer,
            HasPropertyExplorer,
            HasMethodExplorer,
            SpyFunctionProvider
        ]
    },
    { provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage] },
    {
        provide: HasTrap, useClass: HasTrap, deps: [
            Tracker,
            PropertiesValueStorage,
            InteractionPlayer,
            InOperatorInteractionExplorer,
            HasPropertyExplorer,
            HasMethodExplorer,
            PresetPlayablesUpdater
        ]
    },
    { provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: [] },
    { provide: PrototypeStorage, useFactory: ɵ0$3, deps: [MOCK_OPTIONS] },
    { provide: SetTrap, useClass: SetTrap, deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester] },
    { provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage] },
    { provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer] },
];

/**
 * @hidden
 */
const playablesProviders = [
    { provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionMatcher] }
];

/**
 * @hidden
 */
class PresetPlayer {
    constructor(callbackPresetPlayer, mimicsPresetPlayer) {
        this.callbackPresetPlayer = callbackPresetPlayer;
        this.mimicsPresetPlayer = mimicsPresetPlayer;
    }
    play(preset, interaction) {
        if (preset instanceof ReturnsPreset) {
            return preset.value;
        }
        if (preset instanceof CallbacksPreset) {
            return this.callbackPresetPlayer.play(preset.callback, interaction);
        }
        if (preset instanceof MimicsPreset) {
            return this.mimicsPresetPlayer.play(preset.origin, interaction);
        }
        if (preset instanceof ThrowsPreset) {
            throw preset.exception;
        }
    }
}

/**
 * @hidden
 */
class CallbackPresetPlayer {
    play(callback, interaction) {
        return callback.apply(undefined, [interaction]);
    }
}

/**
 * @hidden
 */
class MimicsPresetPlayer {
    constructor(apply) {
        this.apply = apply;
    }
    play(origin, interaction) {
        if (interaction instanceof GetPropertyInteraction) {
            return origin[interaction.name];
        }
        if (interaction instanceof SetPropertyInteraction) {
            origin[interaction.name] = interaction.value;
            return true;
        }
        if (interaction instanceof NamedMethodInteraction) {
            const method = origin[interaction.name];
            return this.apply(method, origin, interaction.args);
        }
        if (interaction instanceof MethodInteraction) {
            return this.apply(origin, undefined, interaction.args);
        }
        if (interaction instanceof InOperatorInteraction) {
            return interaction.name in origin;
        }
    }
}

/**
 * @hidden
 */
class PlayablePresetProvider {
    constructor(presets, matcher) {
        this.presets = presets;
        this.matcher = matcher;
    }
    get(interaction) {
        for (const preset of this.presets.get()) {
            const { target, playable: { isPlayable } } = preset;
            if (this.matcher.matched(interaction, target) && isPlayable() === true) {
                return preset;
            }
        }
    }
}

/**
 * @hidden
 */
const REFLECT_APPLY = new InjectionToken("Reflect Apply");

const ɵ0$4 = Reflect.apply;
/**
 * @hidden
 */
const interactionPlayersProviders = [
    { provide: REFLECT_APPLY, useValue: ɵ0$4, deps: [] },
    { provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer] },
    { provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionMatcher] },
    { provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY] },
    {
        provide: InteractionPlayer,
        useClass: InteractionPlayer,
        deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]
    },
    { provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: [] },
];

/**
 * @hidden
 */
class ExpectedExpressionFormatter {
    constructor(expressionFormatter) {
        this.expressionFormatter = expressionFormatter;
    }
    format(expected, timesMessage, haveBeenCalledTimes, mockName) {
        const expressionDescription = this.expressionFormatter.format(expected);
        const mockDescription = mockName !== undefined ? ` of ${mockName}` : "";
        return `${expressionDescription}${mockDescription} ${timesMessage.toLowerCase()}, but was called ${haveBeenCalledTimes} time(s)`;
    }
}

/**
 * @hidden
 */
class TrackedExpressionsFormatter {
    constructor(expressionFormatter) {
        this.expressionFormatter = expressionFormatter;
    }
    format(trackedExpressions) {
        let result = "";
        for (const expression of trackedExpressions) {
            result += `${this.expressionFormatter.format(expression)}\n`;
        }
        return result.substr(0, result.length - 1);
    }
}

/**
 * @hidden
 */
class ExpressionFormatter {
    constructor(getPropertyFormatter, setPropertyFormatter, methodFormatter, namedMethodFormatter, constantFormatter, inOperatorFormatter) {
        this.getPropertyFormatter = getPropertyFormatter;
        this.setPropertyFormatter = setPropertyFormatter;
        this.methodFormatter = methodFormatter;
        this.namedMethodFormatter = namedMethodFormatter;
        this.constantFormatter = constantFormatter;
        this.inOperatorFormatter = inOperatorFormatter;
    }
    format(expression) {
        if (expression instanceof GetPropertyInteraction)
            return this.getPropertyFormatter.format(expression);
        if (expression instanceof SetPropertyInteraction)
            return this.setPropertyFormatter.format(expression);
        if (expression instanceof InOperatorInteraction)
            return this.inOperatorFormatter.format(expression);
        if (expression instanceof MethodInteraction)
            return this.methodFormatter.format(expression);
        if (expression instanceof NamedMethodInteraction)
            return this.namedMethodFormatter.format(expression);
        if (expression instanceof It)
            return this.constantFormatter.format(expression);
        return undefined;
    }
}

/**
 * @hidden
 */
class SetPropertyExpressionFormatter {
    constructor(constantFormatter, propertyKeyFormatter) {
        this.constantFormatter = constantFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const value = this.constantFormatter.format(expression.value);
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `Assignment of ${value} to property \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
class ConstantFormatter {
    format(object) {
        if (object instanceof It)
            return `It.Is(${object.predicate})`;
        if (object instanceof String || typeof object === "string")
            return `\'${object}\'`;
        if (object instanceof Array) {
            const description = [];
            for (const index of Object.keys(object)) {
                description.push(new ConstantFormatter().format(object[index]));
            }
            return `[${description}]`;
        }
        return `${object}`;
    }
}

/**
 * @hidden
 */
class PropertyKeyFormatter {
    format(property) {
        return String(property);
    }
}

/**
 * @hidden
 */
class NamedMethodExpressionFormatter {
    constructor(constantFormatter, propertyKeyFormatter) {
        this.constantFormatter = constantFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const formatted = [];
        expression.args.forEach(arg => {
            formatted.push(this.constantFormatter.format(arg));
        });
        const value = formatted.join(", ");
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `${propertyKey}(${value})`;
    }
}

/**
 * @hidden
 */
class MethodExpressionFormatter {
    constructor(constantFormatter) {
        this.constantFormatter = constantFormatter;
    }
    format(expression) {
        const value = this.constantFormatter.format(expression.args);
        return `(${value})`;
    }
}

/**
 * @hidden
 */
class InOperatorFormatter {
    constructor(propertyKeyFormatter) {
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `In operator for \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
class GetPropertyExpressionFormatter {
    constructor(propertyKeyFormatter) {
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `Getter of \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
const formattersProviders = [
    {
        provide: VerifyFormatter,
        useClass: VerifyFormatter,
        deps: [ExpectedExpressionFormatter, TrackedExpressionsFormatter]
    },
    { provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [ExpressionFormatter] },
    {
        provide: SetPropertyExpressionFormatter,
        useClass: SetPropertyExpressionFormatter,
        deps: [ConstantFormatter, PropertyKeyFormatter]
    },
    { provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: [] },
    {
        provide: NamedMethodExpressionFormatter,
        useClass: NamedMethodExpressionFormatter,
        deps: [ConstantFormatter, PropertyKeyFormatter]
    },
    { provide: MethodExpressionFormatter, useClass: MethodExpressionFormatter, deps: [ConstantFormatter] },
    { provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter] },
    { provide: GetPropertyExpressionFormatter, useClass: GetPropertyExpressionFormatter, deps: [PropertyKeyFormatter] },
    {
        provide: ExpressionFormatter,
        useClass: ExpressionFormatter,
        deps: [
            GetPropertyExpressionFormatter,
            SetPropertyExpressionFormatter,
            MethodExpressionFormatter,
            NamedMethodExpressionFormatter,
            ConstantFormatter,
            InOperatorFormatter
        ]
    },
    { provide: ExpectedExpressionFormatter, useClass: ExpectedExpressionFormatter, deps: [ExpressionFormatter] },
    { provide: ConstantFormatter, useClass: ConstantFormatter, deps: [] },
];

/**
 * @hidden
 */
class SetPropertyExpressionMatcher {
    constructor(constantMatcher) {
        this.constantMatcher = constantMatcher;
    }
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        const rightExpression = right;
        if (left.name === rightExpression.name && this.constantMatcher.matched(left.value, rightExpression.value))
            return true;
        return false;
    }
}

/**
 * @hidden
 */
class ConstantMatcher {
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        return left === right;
    }
}

/**
 * @hidden
 */
class NamedMethodExpressionMatcher {
    constructor(argumentsMatcher) {
        this.argumentsMatcher = argumentsMatcher;
    }
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        const rightExpression = right;
        if (left.name === rightExpression.name) {
            return this.argumentsMatcher.matched(left.args, rightExpression.args);
        }
        return false;
    }
}

/**
 * @hidden
 */
class ArgumentsMatcher {
    constructor(constantMatcher) {
        this.constantMatcher = constantMatcher;
    }
    matched(left, right) {
        if (left === right)
            return true;
        if (left.length !== right.length)
            return false;
        for (let i = 0; i < left.length; i++) {
            const lvalue = left[i];
            const rvalue = right[i];
            if (this.constantMatcher.matched(lvalue, rvalue) === false) {
                return false;
            }
        }
        return true;
    }
}

/**
 * @hidden
 */
class MethodExpressionMatcher {
    constructor(argumentsMatcher) {
        this.argumentsMatcher = argumentsMatcher;
    }
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        const rightExpression = right;
        return this.argumentsMatcher.matched(left.args, rightExpression.args);
    }
}

/**
 * @hidden
 */
class InOperatorMatcher {
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        const rightExpression = right;
        if (left.name === rightExpression.name)
            return true;
        return false;
    }
}

/**
 * @hidden
 */
class GetPropertyExpressionMatcher {
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        const rightExpression = right;
        if (left.name === rightExpression.name)
            return true;
        return false;
    }
}

/**
 * @hidden
 */
const expressionMatchersProviders = [
    {
        provide: ExpressionMatcher,
        useClass: ExpressionMatcher,
        deps: [
            GetPropertyExpressionMatcher,
            SetPropertyExpressionMatcher,
            MethodExpressionMatcher,
            NamedMethodExpressionMatcher,
            InOperatorMatcher
        ]
    },
    { provide: SetPropertyExpressionMatcher, useClass: SetPropertyExpressionMatcher, deps: [ConstantMatcher] },
    { provide: NamedMethodExpressionMatcher, useClass: NamedMethodExpressionMatcher, deps: [ArgumentsMatcher] },
    { provide: MethodExpressionMatcher, useClass: MethodExpressionMatcher, deps: [ArgumentsMatcher] },
    { provide: InOperatorMatcher, useClass: InOperatorMatcher, deps: [] },
    { provide: GetPropertyExpressionMatcher, useClass: GetPropertyExpressionMatcher, deps: [] },
    { provide: ConstantMatcher, useClass: ConstantMatcher, deps: [] },
    { provide: ArgumentsMatcher, useClass: ArgumentsMatcher, deps: [ConstantMatcher] },
];

/**
 * @hidden
 */
class ExpressionHasMethodExplorer {
    has(name, expression) {
        if (expression instanceof ExpectedNamedMethodExpression) {
            return expression.name === name;
        }
        return false;
    }
}

/**
 * @hidden
 */
class MembersMethodExplorer {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    hasMethod(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.value instanceof Function;
        }
        return false;
    }
}

/**
 * @hidden
 */
class PresetHasMethodExplorer {
    constructor(expressionHasMethodExplorer, objectHasMethodExplorer) {
        this.expressionHasMethodExplorer = expressionHasMethodExplorer;
        this.objectHasMethodExplorer = objectHasMethodExplorer;
    }
    has(name, preset) {
        if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {
            return true;
        }
        return this.expressionHasMethodExplorer.has(name, preset.target);
    }
}

/**
 * @hidden
 */
class ObjectHasMethodExplorer {
    has(name, target) {
        return target[name] instanceof Function;
    }
}

/**
 * @hidden
 */
class ExpressionHasPropertyExplorer {
    has(name, expression) {
        if (expression instanceof It
            || expression instanceof ExpectedMethodExpression
            || expression instanceof ExpectedNamedMethodExpression
            || expression instanceof ExpectedInOperatorExpression) {
            return false;
        }
        return expression.name === name;
    }
}

/**
 * @hidden
 */
class MembersPropertyExplorer {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    hasProperty(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.get !== undefined || (descriptor.value instanceof Function) === false;
        }
        return false;
    }
}

/**
 * @hidden
 */
class PresetHasPropertyExplorer {
    constructor(expressionHasPropertyExplorer, objectHasPropertyExplorer) {
        this.expressionHasPropertyExplorer = expressionHasPropertyExplorer;
        this.objectHasPropertyExplorer = objectHasPropertyExplorer;
    }
    has(name, preset) {
        if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {
            return true;
        }
        return this.expressionHasPropertyExplorer.has(name, preset.target);
    }
}

/**
 * @hidden
 */
class ObjectHasPropertyExplorer {
    has(name, target) {
        return Reflect.has(target, name) && (target[name] instanceof Function) === false;
    }
}

/**
 * @hidden
 */
class PresetHasInOperatorExplorer {
    has(name, preset) {
        const { playable: { isPlayable } } = preset;
        if (isPlayable() === false) {
            return false;
        }
        if (preset.target instanceof ExpectedInOperatorExpression) {
            return preset.target.name === name;
        }
        if (preset.target instanceof It) {
            return preset.target.test(new InOperatorInteraction(name));
        }
        return false;
    }
}

/**
 * @hidden
 */
class PropertyDescriptorProvider {
    get(target, name) {
        let prototype = target;
        while (prototype !== null) {
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);
            if (descriptor !== undefined)
                return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
}

/**
 * @hidden
 */
const REFLECT_HAS = new InjectionToken("Reflect has");

const ɵ0$5 = Reflect.has;
/**
 * @hidden
 */
const typeExplorersProviders = [
    { provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: [] },
    {
        provide: HasMethodExplorer,
        useClass: HasMethodExplorer,
        deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]
    },
    { provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: [] },
    {
        provide: PresetHasMethodExplorer,
        useClass: PresetHasMethodExplorer,
        deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]
    },
    { provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: [] },
    {
        provide: HasPropertyExplorer,
        useClass: HasPropertyExplorer,
        deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]
    },
    { provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: [] },
    {
        provide: PresetHasPropertyExplorer,
        useClass: PresetHasPropertyExplorer,
        deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]
    },
    {
        provide: InOperatorInteractionExplorer,
        useClass: InOperatorInteractionExplorer,
        deps: [Presets, PresetHasInOperatorExplorer]
    },
    { provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: [] },
    {
        provide: MembersMethodExplorer,
        useClass: MembersMethodExplorer,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    {
        provide: PropertyIsReadOnlyTester,
        useClass: PropertyIsReadOnlyTester,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    {
        provide: MembersPropertyExplorer,
        useClass: MembersPropertyExplorer,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    { provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: [] },
    { provide: REFLECT_HAS, useValue: ɵ0$5, deps: [] },
];

/**
 * @hidden
 */
class MockOptionsBuilder {
    build(options) {
        const target = (() => undefined);
        return Object.assign({ target }, options);
    }
}

/**
 * @hidden
 */
function mockOptionsProviders(options) {
    return [
        { provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: [] },
        { provide: MOCK_OPTIONS, useFactory: builder => builder.build(options), deps: [MockOptionsBuilder] },
    ];
}

/**
 * Provides the default configuration for an angular based injector that would be used internally by {@link Mock} instance.
 */
class DefaultInjectorConfig {
    get(options, providers) {
        return [
            ...providers,
            ...mockOptionsProviders(options),
            ...trackerProviders,
            ...reflectorProviders,
            ...presetsProviders,
            ...verificationProviders,
            ...interceptorsProviders,
            ...playablesProviders,
            ...interactionPlayersProviders,
            ...formattersProviders,
            ...expressionMatchersProviders,
            ...typeExplorersProviders
        ];
    }
}

/**
 * The default implementation of {@link IMock} interface.
 */
class Mock {
    constructor(options = {}) {
        this.options = options;
        const preOptions = Object.assign(Object.assign({}, Mock.options), options);
        const provider = { provide: MOCK, useValue: this, deps: [] };
        const injector = injectorFactory(preOptions, provider);
        this.options = injector.get(MOCK_OPTIONS);
        this.tracker = injector.get(Tracker);
        this.expressionReflector = injector.get(ExpectedExpressionReflector);
        this.interceptor = injector.get(ProxyFactory);
        this.setupFactory = injector.get(PRESET_BUILDER_FACTORY);
        this.verifier = injector.get(Verifier);
        this.prototypeStorage = injector.get(PrototypeStorage);
    }
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
     * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
     * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
     */
    static get options() {
        if (Mock.Options === undefined) {
            Mock.Options = {
                target: () => undefined,
                injectorConfig: new DefaultInjectorConfig()
            };
        }
        return Mock.Options;
    }
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * If an options are passed as constructor parameter they will override the default options.
     */
    static set options(options) {
        Mock.Options = options;
    }
    get name() {
        return this.options.name;
    }
    setup(expression) {
        const expectedExpression = this.expressionReflector.reflect(expression);
        return this.setupFactory(expectedExpression);
    }
    verify(expression, times) {
        times = times === undefined ? Times.Once() : times;
        const expressions = this.tracker.get().map(record => record.expression);
        this.verifier.test(expression, times, expressions, this.name);
        return this;
    }
    object() {
        return this.interceptor.object();
    }
    prototypeof(prototype) {
        this.prototypeStorage.set(prototype);
        return this;
    }
    /**
     * @experimental
     */
    insequence(sequence, expression) {
        sequence.add(this, expression);
        return this;
    }
}
Mock.Options = undefined;

/**
 * This function dumps into console.log all interactions with the mocked object
 */
function dump(mock, writer = console) {
    const injector = injectorFactory(mock.options, { provide: MOCK, useValue: mock, deps: [] });
    const formatter = injector.get(TrackedExpressionsFormatter);
    const expressions = mock.tracker.get().map(record => record.expression);
    const output = formatter.format(expressions);
    const delimiter = "-------------------------------";
    writer.log(`Dump of ${mock.name === undefined ? "noname mock" : mock.name}`);
    writer.log(delimiter);
    writer.log(`\n${output}`);
    writer.log(delimiter);
}

/**
 * @hidden
 */
class EqualMatcher {
    constructor(typesMatcher, commonTypeProvider, primitiveMatcher, objectMatcher, functionMatcher) {
        this.typesMatcher = typesMatcher;
        this.commonTypeProvider = commonTypeProvider;
        this.primitiveMatcher = primitiveMatcher;
        this.objectMatcher = objectMatcher;
        this.functionMatcher = functionMatcher;
    }
    matched(left, right) {
        if (this.typesMatcher.matched(left, right) === false) {
            return false;
        }
        switch (this.commonTypeProvider.ofType(left, right)) {
            case "undefined":
                return this.primitiveMatcher.matched(left, right);
            case "object":
                return this.objectMatcher.matched(left, right);
            case "boolean":
                return this.primitiveMatcher.matched(left, right);
            case "number":
                return this.primitiveMatcher.matched(left, right);
            case "string":
                return this.primitiveMatcher.matched(left, right);
            case "function":
                return this.functionMatcher.matched(left, right);
            case "symbol":
                return this.primitiveMatcher.matched(left, right);
            case "bigint":
                return this.primitiveMatcher.matched(left, right);
        }
    }
}

/**
 * @hidden
 */
class EqualConstantMatcher {
    constructor(equalMatcher) {
        this.equalMatcher = equalMatcher;
    }
    matched(left, right) {
        if (right instanceof It) {
            return right.test(left);
        }
        return this.equalMatcher.matched(left, right);
    }
}

/**
 * @hidden
 */
class CommonTypeProvider {
    ofType(left, right) {
        return typeof left && typeof right;
    }
}

/**
 * @hidden
 */
class TypesMatcher {
    matched(left, right) {
        return typeof left === typeof right;
    }
}

/**
 * @hidden
 */
class PrimitiveMatcher {
    matched(left, right) {
        return left === right;
    }
}

/**
 * @hidden
 */
class ObjectMatcher {
    constructor(matchers) {
        this.matchers = matchers;
    }
    matched(left, right) {
        if (left === null && right === null)
            return true;
        if (left === right)
            return true;
        for (const matcher of this.matchers) {
            const matched = matcher.matched(left, right);
            if (matched === undefined) {
                continue;
            }
            return matched;
        }
        return false;
    }
}

/**
 * @hidden
 */
class FunctionMatcher {
    matched(left, right) {
        return left === right;
    }
}

/**
 * @hidden
 */
class IterableTester {
    verify(left, right) {
        return typeof left[Symbol.iterator] === "function" && typeof right[Symbol.iterator] === "function";
    }
}

/**
 * Matches objects that support Iterable protocol
 */
class IteratorMatcher {
    constructor(injector, iterableTester) {
        this.injector = injector;
        this.iterableTester = iterableTester;
    }
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    matched(left, right) {
        if (this.iterableTester.verify(left, right) === true) {
            const leftIterator = [...left[Symbol.iterator]()];
            const rightIterator = [...right[Symbol.iterator]()];
            if (leftIterator.length !== rightIterator.length)
                return false;
            const constantMatcher = this.injector.get(ConstantMatcher);
            for (let i = 0; i < leftIterator.length; i++) {
                const leftValue = leftIterator[i];
                const rightValue = rightIterator[i];
                if (constantMatcher.matched(leftValue, rightValue) === false) {
                    return false;
                }
            }
            return true;
        }
        return undefined;
    }
}

const OBJECT_MATCHERS = new InjectionToken("OBJECT_MATCHERS");

/**
 * Matches objects as POJO
 */
class POJOMatcher {
    constructor(mapMatcher, objectMapProvider) {
        this.mapMatcher = mapMatcher;
        this.objectMapProvider = objectMapProvider;
    }
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    matched(left, right) {
        const leftProps = this.objectMapProvider.get(left);
        const rightProps = this.objectMapProvider.get(right);
        return this.mapMatcher.matched(leftProps, rightProps);
    }
}

/**
 * @hidden
 */
class ObjectMapProvider {
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    get(object) {
        const props = this.getProps(object, []);
        const keys = [...new Set(props)];
        const map = new Map();
        for (const key of keys) {
            map.set(key, object[key]);
        }
        return map;
    }
    getProps(object, props) {
        if (object === null)
            return props;
        if (object === Object.prototype)
            return props;
        props = [...props, ...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
        return this.getProps(Object.getPrototypeOf(object), props);
    }
}

/**
 * Matches Map objects
 */
class MapMatcher {
    constructor(injector) {
        this.injector = injector;
    }
    matched(left, right) {
        if (left instanceof Map && right instanceof Map) {
            if (left.size !== right.size)
                return false;
            const constantMatcher = this.injector.get(ConstantMatcher);
            for (const [key, value] of left) {
                if (right.has(key) === false)
                    return false;
                if (constantMatcher.matched(value, right.get(key)) === false)
                    return false;
            }
            return true;
        }
        return undefined;
    }
}

/**
 * @hidden
 */
const equalMatchersProviders = [
    { provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: [] },
    { provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [EqualMatcher] },
    { provide: ConstantMatcher, useExisting: EqualConstantMatcher },
    {
        provide: EqualMatcher, useClass: EqualMatcher, deps: [
            TypesMatcher,
            CommonTypeProvider,
            PrimitiveMatcher,
            ObjectMatcher,
            FunctionMatcher
        ]
    },
    { provide: FunctionMatcher, useClass: FunctionMatcher, deps: [] },
    { provide: IterableTester, useClass: IterableTester, deps: [] },
    {
        provide: IteratorMatcher, useClass: IteratorMatcher, deps: [
            Injector,
            IterableTester
        ]
    },
    { provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS] },
    { provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider] },
    { provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: [] },
    { provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: [] },
    { provide: TypesMatcher, useClass: TypesMatcher, deps: [] },
    { provide: MapMatcher, useClass: MapMatcher, deps: [Injector] },
];

/**
 * Matches Date objects
 */
class DateMatcher {
    matched(left, right) {
        if (left instanceof Date && right instanceof Date) {
            return left.valueOf() === right.valueOf();
        }
        return undefined;
    }
}

/**
 * Provides the configuration for Angular based injector that would use equal logic for matching values.
 * By default, all values are matched with
 * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
 * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
 * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
 * and introduce deep equal comparison logic as well as an extension point for custom matchers.
 *
 * ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>()
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
 *  expect(actual).toBe(undefined);
 *  ```
 *  and compare with
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  expect(actual).toBe(2);
 *  ```
 *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
 *
 *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
 *  then more general matchers would be invoked.
 *
 *  The library comes with the following matchers:
 *  0. Custom matchers
 *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
 *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
 *  3. IteratorMatcher - matches objects that supports
 *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
 *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
 *
 *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *     matched<T extends object>(left: T, right: T): boolean | undefined {
 *         if (left instanceof Date && isMoment(right)) {
 *             return left.valueOf() === right.valueOf();
 *         }
 *         return undefined;
 *     }
 * }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *     provide: OBJECT_MATCHERS,
 *     useClass: MomentDateMatcher,
 *     multi: true,
 *     deps: []
 * }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
 *  So you can do a partial comparision.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
 *
 *  const func = () => undefined;
 *
 *  const injectorConfig = new EqualMatchingInjectorConfig();
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object({func});
 *
 *  expect(actual).toBe(2);
 *  ```
 */
class EqualMatchingInjectorConfig extends DefaultInjectorConfig {
    constructor(matchers = []) {
        super();
        this.matchers = matchers;
    }
    get(options, providers) {
        return [
            ...super.get(options, providers),
            ...equalMatchersProviders,
            ...this.matchers,
            { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] },
        ];
    }
}

/*
 * Public API Surface of moq.ts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DefaultInjectorConfig, EqualMatchingInjectorConfig, ExpectedGetPropertyExpression, ExpectedInOperatorExpression, ExpectedMethodExpression, ExpectedNamedMethodExpression, ExpectedSetPropertyExpression, GetPropertyInteraction, Host, INJECTOR, InOperatorInteraction, InjectFlags, InjectionToken, Injector, Interaction, It, MOCK, MOCK_OPTIONS, MethodInteraction, Mock, MoqAPI, NamedMethodInteraction, NullInjector, OBJECT_MATCHERS, Optional, PlayTimes, PlayableAlways, PlayableExactly, PlayableNever, PlayableOnce, PlayableSequence, Range, Self, SetPropertyInteraction, SkipSelf, Times, dump, forwardRef, getClosureSafeProperty, injectorFactory, isForwardRef };
//# sourceMappingURL=moq.ts.js.map
