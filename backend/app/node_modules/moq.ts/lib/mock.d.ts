import { IExpectedExpression } from "./expected-expressions/expected-expression-reflector";
import { IMock, IMockOptions, IPresetBuilder, ISequenceVerifier } from "./moq";
import { Times } from "./times";
import { Tracker } from "./tracker/tracker";
/**
 * The default implementation of {@link IMock} interface.
 */
export declare class Mock<T> implements IMock<T> {
    readonly options: IMockOptions<T>;
    private static Options;
    readonly tracker: Tracker;
    private expressionReflector;
    private interceptor;
    private readonly setupFactory;
    private verifier;
    private prototypeStorage;
    constructor(options?: IMockOptions<T>);
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
     * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
     * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
     */
    static get options(): IMockOptions<unknown>;
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * If an options are passed as constructor parameter they will override the default options.
     */
    static set options(options: IMockOptions<unknown>);
    get name(): string;
    setup<E extends IExpectedExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    verify(expression: IExpectedExpression<T>, times?: Times): IMock<T>;
    object(): T;
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     */
    insequence(sequence: ISequenceVerifier, expression: IExpectedExpression<T>): IMock<T>;
}
